# Webhook Metadata Correlation Check Implementation Plan

## Overview

Implement security verification to ensure that `supabase_user_id` in webhook metadata actually owns the Stripe customer ID, preventing cross-account privilege escalation attacks. This adds defense-in-depth protection against metadata manipulation by attackers with Stripe dashboard access or compromised API keys.

## Current State Analysis

**Existing Security Measures (Good):**
- ‚úÖ Webhook signature verification implemented (route.ts:32-36)
- ‚úÖ Idempotency tracking via `webhook_events` table (route.ts:40-59)
- ‚úÖ `stripe_customers` table has `userId` as primary key (enforces one customer per user)
- ‚úÖ `stripeCustomerId` is unique (enforces one record per Stripe customer)

**Security Vulnerability (Critical):**
- ‚ùå `handleSubscriptionChange()` trusts `metadata.supabase_user_id` without verification (route.ts:468)
- ‚ùå `handleSubscriptionDeleted()` trusts `metadata.supabase_user_id` without verification (route.ts:517)
- ‚ùå `handleCheckoutCompleted()` trusts `metadata.supabase_user_id` without verification (route.ts:193)
- ‚ùå `handleCustomerCreated()` could create poisoned mappings (route.ts:167)

**Attack Scenario:**
1. Attacker with Stripe dashboard access creates subscription: `{customer: 'cus_attacker', metadata: {supabase_user_id: 'victim-id'}}`
2. Webhook fires, handler trusts metadata
3. Victim gets premium access paid by attacker (or attacker downgrades victim's legitimate subscription)

**Threat Level:** üü° Medium-Low likelihood, Medium severity
- Requires Stripe dashboard access OR compromised API key
- Consequences: Complete billing bypass, privilege escalation, revenue loss

## Desired End State

All webhook handlers verify that Stripe customer IDs belong to the user specified in metadata BEFORE granting access or modifying subscriptions. Metadata mismatches are logged as security warnings and do NOT update user profiles.

### Verification Criteria:

#### Automated Verification:
- [ ] TypeScript compilation passes: `pnpm build`
- [ ] All type checks pass (no TypeScript errors)
- [ ] Code follows existing patterns (uses Drizzle ORM, webhook-logger utilities)

#### Manual Verification:
- [ ] Create test subscription via Stripe CLI with wrong metadata - verify rejection
- [ ] Create test subscription with correct metadata - verify acceptance
- [ ] Check logs for security warnings on metadata mismatches
- [ ] Verify legitimate users can still subscribe successfully
- [ ] Test new customer creation (no existing mapping) works correctly
- [ ] Test existing customer (with mapping) correlation check works

## What We're NOT Doing

- ‚ùå Automated security alerting to external services (Sentry, etc.) - planned for future
- ‚ùå Admin dashboard for viewing correlation failures
- ‚ùå Historical audit of all customer-user relationships
- ‚ùå Automated remediation of metadata mismatches
- ‚ùå Customer ID migration for duplicate customers
- ‚ùå Additional database constraints (current schema already sufficient)

## Implementation Approach

We'll create a reusable `verifyCustomerOwnership()` helper function that queries the `stripe_customers` table to verify customer-user relationships. All webhook handlers will call this function before updating user profiles. The database is our source of truth, not the metadata.

**Key Principle:** Trust the database mapping (`stripe_customers` table), not the webhook metadata.

---

## Phase 1: Create Security Helper Function

### Overview

Create `lib/stripe-security.ts` with a `verifyCustomerOwnership()` function that validates customer-user relationships by querying the `stripe_customers` table.

### Changes Required:

#### 1. Create Security Helper Module

**File**: `lib/stripe-security.ts` (new file)
**Changes**: Create new security utility module

```typescript
import { db } from '@/db';
import { stripeCustomers } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { logWebhookWarning, logWebhookError } from './webhook-logger';

/**
 * Verify that a Stripe customer ID belongs to the specified user
 *
 * Security: Prevents privilege escalation via metadata manipulation
 *
 * @param stripeCustomerId - Stripe customer ID from webhook event
 * @param claimedUserId - User ID from webhook metadata (untrusted)
 * @returns Object with validation result and actual user ID if found
 */
export async function verifyCustomerOwnership(
  stripeCustomerId: string,
  claimedUserId: string
): Promise<{ valid: boolean; actualUserId?: string }> {
  try {
    // Query database for actual customer-user mapping
    const customerRecord = await db
      .select()
      .from(stripeCustomers)
      .where(eq(stripeCustomers.stripeCustomerId, stripeCustomerId))
      .limit(1);

    // Case 1: Customer not in database
    if (customerRecord.length === 0) {
      logWebhookWarning('Stripe customer not found in database', {
        stripeCustomerId,
        claimedUserId,
      });
      return { valid: false };
    }

    const actualUserId = customerRecord[0].userId;

    // Case 2: Customer belongs to different user (SECURITY ISSUE)
    if (actualUserId !== claimedUserId) {
      logWebhookError('üö® SECURITY: Customer-User mismatch detected', {
        stripeCustomerId,
        claimedUserId,
        actualUserId,
        severity: 'HIGH',
      });
      return { valid: false, actualUserId };
    }

    // Case 3: Valid - customer belongs to claimed user
    return { valid: true, actualUserId };
  } catch (error) {
    logWebhookError('Error verifying customer ownership', error);
    return { valid: false };
  }
}
```

**Rationale:**
- Returns structured result with both validation status and actual user ID
- Logs security warnings for suspicious activity
- Handles three cases: not found, mismatch, valid
- Uses existing webhook-logger utilities for consistency
- Fail-safe: returns `valid: false` on database errors

### Success Criteria:

#### Automated Verification:
- [x] File compiles without TypeScript errors: `pnpm build`
- [x] Imports resolve correctly (db, schema, drizzle-orm, webhook-logger)

#### Manual Verification:
- [ ] Function signature is clear and well-documented
- [ ] Error handling covers all edge cases
- [ ] Logging uses existing webhook-logger patterns

---

## Phase 2: Add Correlation Check to Subscription Handlers

### Overview

Update `handleSubscriptionChange()` and `handleSubscriptionDeleted()` to verify customer ownership before updating user profiles. These handlers process recurring subscription events.

### Changes Required:

#### 1. Update handleSubscriptionChange()

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Lines 467-511
**Changes**: Add correlation check after extracting metadata

```typescript
import { verifyCustomerOwnership } from '@/lib/stripe-security';

async function handleSubscriptionChange(subscription: any) {
  const userId = subscription.metadata?.supabase_user_id;
  const customerId = subscription.customer; // Stripe customer ID

  if (!userId) {
    logWebhookError("No supabase_user_id in subscription metadata");
    return;
  }

  // ‚úÖ NEW: Verify customer belongs to this user
  const ownership = await verifyCustomerOwnership(customerId, userId);

  if (!ownership.valid) {
    logWebhookError('Customer-User correlation check failed - NOT updating plan', {
      handler: 'handleSubscriptionChange',
      claimedUserId: userId,
      actualUserId: ownership.actualUserId,
      stripeCustomerId: customerId,
      subscriptionId: subscription.id,
      severity: 'HIGH',
    });
    return; // ‚ùå DO NOT UPDATE PROFILE
  }

  logWebhookInfo('Customer-User correlation verified', {
    userId,
    customerId,
  });

  // Continue with existing logic (no changes below)...
  const priceId = subscription.items.data[0]?.price.id;
  if (!priceId) {
    logWebhookError("No price ID in subscription");
    return;
  }

  const plan = mapPriceToPlan(priceId);
  if (!plan) {
    logWebhookError(`Unknown price ID: ${priceId}`);
    return;
  }

  // Only update if subscription is active
  if (subscription.status === "active" || subscription.status === "trialing") {
    try {
      await db
        .update(profile)
        .set({
          planSelected: plan,
          planSelectedAt: new Date(),
          subscriptionStatus: subscription.status,
          currentPeriodEnd: subscription.current_period_end,
          cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
          billingVersion: sql`billing_version + 1`,
        })
        .where(eq(profile.id, userId));

      logWebhookSuccess(
        `Updated plan_selected to '${plan}' for user: ${userId}`
      );
    } catch (error) {
      logWebhookError(`Error updating plan for user ${userId}`, error);
      throw error;
    }
  }
}
```

**Rationale:**
- Checks correlation BEFORE any database updates
- Early return on failure prevents privilege escalation
- Logs detailed context for security investigation
- Minimal changes to existing logic (only adds 13 lines)

#### 2. Update handleSubscriptionDeleted()

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Lines 516-544
**Changes**: Add correlation check after extracting metadata

```typescript
async function handleSubscriptionDeleted(subscription: any) {
  const userId = subscription.metadata?.supabase_user_id;
  const customerId = subscription.customer;

  if (!userId) {
    logWebhookError("No supabase_user_id in subscription metadata");
    return;
  }

  // ‚úÖ NEW: Verify customer belongs to this user
  const ownership = await verifyCustomerOwnership(customerId, userId);

  if (!ownership.valid) {
    logWebhookError('Customer-User correlation check failed - NOT reverting plan', {
      handler: 'handleSubscriptionDeleted',
      claimedUserId: userId,
      actualUserId: ownership.actualUserId,
      stripeCustomerId: customerId,
      severity: 'HIGH',
    });
    return; // ‚ùå DO NOT REVERT PLAN
  }

  // Continue with existing logic (no changes below)...
  try {
    await db
      .update(profile)
      .set({
        planSelected: "free",
        planSelectedAt: new Date(),
        subscriptionStatus: "canceled",
        currentPeriodEnd: null,
        cancelAtPeriodEnd: false,
        billingVersion: sql`billing_version + 1`,
      })
      .where(eq(profile.id, userId));

    logWebhookSuccess(`Reverted to free tier for user: ${userId}`);
  } catch (error) {
    logWebhookError(`Error reverting user ${userId} to free tier`, error);
    throw error;
  }
}
```

**Rationale:**
- Prevents attackers from downgrading legitimate users
- Same security pattern as `handleSubscriptionChange()`
- Early return prevents unauthorized plan changes

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] Import statement added correctly
- [x] No TypeScript errors in modified functions

#### Manual Verification:
- [ ] Test subscription.created with wrong metadata - verify rejection
- [ ] Test subscription.updated with correct metadata - verify acceptance
- [ ] Test subscription.deleted with wrong metadata - verify rejection
- [ ] Check logs show security warnings for mismatches
- [ ] Verify legitimate subscription updates still work

---

## Phase 3: Add Correlation Check to Checkout Handler

### Overview

Update `handleCheckoutCompleted()` to verify customer ownership for both subscription and payment mode checkouts. This is more complex because new customers may not have a database record yet.

### Changes Required:

#### 1. Update handleCheckoutCompleted() - Payment Mode Section

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Lines 240-353 (payment mode section)
**Changes**: Add correlation check AFTER customer record is inserted/updated

```typescript
// For payment mode (lifetime), check payment status first
if (session.mode === "payment") {
  logPaymentEvent("Payment mode detected - checking payment status");

  try {
    const lineItems = await stripe.checkout.sessions.listLineItems(
      session.id
    );
    const priceId = lineItems.data[0]?.price?.id;

    logWebhookDebug("Line items", {
      count: lineItems.data.length,
      priceId,
    });

    if (!priceId) {
      logWebhookError("No price ID found in line items");
      return;
    }

    const plan = mapPriceToPlan(priceId);
    logWebhookDebug("Mapped price to plan", { priceId, plan });

    if (!plan) {
      logWebhookError(`Unknown price ID: ${priceId}`);
      return;
    }

    // ‚úÖ NEW: Verify customer ownership if customer ID exists
    if (customerId) {
      const ownership = await verifyCustomerOwnership(customerId, userId);

      if (!ownership.valid) {
        logWebhookError('Customer-User correlation check failed for lifetime purchase', {
          handler: 'handleCheckoutCompleted',
          mode: 'payment',
          claimedUserId: userId,
          actualUserId: ownership.actualUserId,
          stripeCustomerId: customerId,
          sessionId: session.id,
          severity: 'HIGH',
        });
        return; // ‚ùå DO NOT GRANT LIFETIME ACCESS
      }

      logWebhookInfo('Customer-User correlation verified for lifetime purchase', {
        userId,
        customerId,
      });
    }

    // Continue with existing payment status logic (no changes below)...
    const paymentStatus = session.payment_status;
    logWebhookDebug("Payment status", { paymentStatus, sessionId: session.id });

    if (paymentStatus === "paid") {
      // ... existing code for paid status ...
    } else if (paymentStatus === "unpaid") {
      // ... existing code for unpaid status ...
    } else if (paymentStatus === "no_payment_required") {
      // ... existing code for no_payment_required ...
    } else {
      logWebhookWarning(`Unknown payment status: ${paymentStatus} for session ${session.id}`);
    }

  } catch (error) {
    logWebhookError("Error processing payment mode checkout", error);
    throw error;
  }
}
```

**Important Note:** The correlation check happens AFTER the customer record insertion (lines 214-227) but BEFORE granting access. This ensures:
1. New customers get their mapping created first
2. Existing customers are verified against the database
3. If metadata is malicious, access is denied

**Rationale:**
- Only verifies if `customerId` exists (some sessions might not have one)
- Check happens after customer record is inserted (database is now source of truth)
- Prevents lifetime access grants via metadata manipulation
- Maintains existing payment status logic

#### 2. Subscription Mode - No Changes Needed

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Lines 232-238 (subscription mode section)
**Changes**: None required

```typescript
// For subscription mode, wait for subscription.created event to update plan
if (session.mode === "subscription") {
  logSubscriptionEvent(
    "Subscription checkout - will update plan on subscription.created"
  );
  return;
}
```

**Rationale:**
- Subscription mode checkouts don't grant access immediately
- Access is granted when `subscription.created` fires
- That handler (`handleSubscriptionChange()`) already has correlation check from Phase 2
- No duplication needed

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors in modified sections

#### Manual Verification:
- [ ] Test new customer lifetime purchase - verify success
- [ ] Test existing customer lifetime purchase with wrong metadata - verify rejection
- [ ] Test existing customer lifetime purchase with correct metadata - verify success
- [ ] Test subscription mode checkout - verify it still waits for subscription.created
- [ ] Check logs show correlation verification messages

---

## Phase 4: Add Defensive Check to Customer Creation Handler

### Overview

Add defensive validation to `handleCustomerCreated()` to detect and warn about suspicious customer creation attempts. This prevents "poisoning" the customer-user mapping.

### Changes Required:

#### 1. Update handleCustomerCreated()

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Lines 166-187
**Changes**: Check if user already has a customer before inserting

```typescript
async function handleCustomerCreated(customer: any) {
  const userId = customer.metadata?.supabase_user_id;

  if (!userId) {
    logWebhookError("No supabase_user_id in customer metadata");
    return;
  }

  try {
    // ‚úÖ NEW: Check if user already has a customer (defensive)
    const existingCustomer = await db
      .select()
      .from(stripeCustomers)
      .where(eq(stripeCustomers.userId, userId))
      .limit(1);

    if (existingCustomer.length > 0) {
      // User already has a customer - this is suspicious
      logWebhookWarning('üö® SECURITY: Attempt to create duplicate customer for user', {
        userId,
        existingCustomerId: existingCustomer[0].stripeCustomerId,
        newCustomerId: customer.id,
        severity: 'MEDIUM',
      });

      // Don't insert - primary key constraint would fail anyway
      // But log for security monitoring
      return;
    }

    // Proceed with customer creation
    await db
      .insert(stripeCustomers)
      .values({
        userId,
        stripeCustomerId: customer.id,
      })
      .onConflictDoNothing(); // Still keep this as safety net

    logWebhookSuccess(`Stripe customer created for user: ${userId}`);
  } catch (error) {
    logWebhookError("Error creating stripe customer record", error);
  }
}
```

**Rationale:**
- Detects duplicate customer creation attempts (potential attack)
- Primary key constraint would prevent insertion anyway, but this logs it explicitly
- Helps identify compromised accounts or malicious activity
- Early return avoids unnecessary database operations
- `.onConflictDoNothing()` kept as additional safety net

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors in modified function

#### Manual Verification:
- [ ] Test normal customer creation - verify success
- [ ] Test duplicate customer creation attempt - verify warning logged
- [ ] Verify primary key constraint still prevents duplicates
- [ ] Check logs show security warnings for duplicate attempts

---

## Testing Strategy

### Unit Tests (Future Work - Out of Scope)

Future tickets could add:
- `verifyCustomerOwnership()` unit tests
- Mock database queries for different scenarios
- Test valid, invalid, and not-found cases

### Integration Tests (Future Work - Out of Scope)

Future tickets could add:
- Full webhook flow tests with test Stripe events
- Database state verification after webhook processing
- Security scenario testing (wrong metadata, duplicate customers)

### Manual Testing Steps

**Prerequisites:**
- Local development environment running
- Stripe CLI installed: `stripe listen --forward-to localhost:3000/api/stripe/webhook`
- Test Stripe account configured

**Test 1: Normal Subscription Creation (Should Succeed)**
```bash
# 1. Create customer with metadata
stripe customers create \
  --email=test@example.com \
  --metadata[supabase_user_id]=user-123

# 2. Create subscription with matching metadata
stripe subscriptions create \
  --customer=<customer_id_from_step_1> \
  --items[0][price]=<premium_price_id> \
  --metadata[supabase_user_id]=user-123

# 3. Expected: Logs show "Customer-User correlation verified"
# 4. Expected: User profile updated with premium plan
```

**Test 2: Subscription with Wrong Metadata (Should Fail)**
```bash
# 1. Use existing customer from Test 1 (belongs to user-123)

# 2. Create subscription with WRONG metadata
stripe subscriptions create \
  --customer=<customer_id> \
  --items[0][price]=<premium_price_id> \
  --metadata[supabase_user_id]=user-456

# 3. Expected: Logs show "Customer-User correlation check failed"
# 4. Expected: User-456 profile NOT updated (still free tier)
# 5. Expected: User-123 profile NOT updated either
```

**Test 3: Lifetime Purchase (Should Succeed)**
```bash
# 1. Create checkout session via app UI for lifetime plan
# 2. Complete payment using test card: 4242 4242 4242 4242
# 3. Expected: checkout.session.completed webhook fires
# 4. Expected: Correlation check passes
# 5. Expected: User profile updated with lifetime plan
```

**Test 4: Duplicate Customer Creation (Should Warn)**
```bash
# 1. Create customer for user-123 (if not exists)
stripe customers create \
  --email=test@example.com \
  --metadata[supabase_user_id]=user-123

# 2. Trigger customer.created webhook (should succeed)

# 3. Try to create ANOTHER customer for same user
stripe customers create \
  --email=test2@example.com \
  --metadata[supabase_user_id]=user-123

# 4. Expected: Logs show security warning about duplicate customer
# 5. Expected: Database still has only one customer for user-123
```

**Test 5: Subscription Deletion (Should Revert to Free)**
```bash
# 1. Use subscription from Test 1

# 2. Cancel subscription
stripe subscriptions cancel <subscription_id>

# 3. Expected: subscription.deleted webhook fires
# 4. Expected: Correlation check passes
# 5. Expected: User reverted to free tier
```

### Performance Considerations

- Each correlation check adds ~10-20ms to webhook processing (one database query)
- Query uses index on `stripeCustomerId` (unique constraint = index)
- Acceptable overhead for security benefit
- No caching needed unless processing >100 webhooks/second
- Webhook timeout limit is 30 seconds (plenty of headroom)

### Security Benefits

1. **Prevents Privilege Escalation**
   - Attackers with Stripe access cannot grant arbitrary users premium access
   - Metadata manipulation is detected and blocked

2. **Defense in Depth**
   - Adds security layer beyond webhook signature verification
   - Protects against insider threats and compromised API keys

3. **Data Integrity**
   - Ensures billing records match actual customer ownership
   - Database is single source of truth for customer-user relationships

4. **Audit Trail**
   - All correlation failures logged with full context
   - Security warnings help detect attack attempts
   - Can be integrated with future monitoring systems

---

## Definition of Done

#### Automated Verification:
- [x] All TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors in any modified files
- [x] New `lib/stripe-security.ts` file compiles correctly

#### Manual Verification:
- [ ] `verifyCustomerOwnership()` function created and documented
- [ ] `handleSubscriptionChange()` updated with correlation check
- [ ] `handleSubscriptionDeleted()` updated with correlation check
- [ ] `handleCheckoutCompleted()` updated with correlation check (payment mode)
- [ ] `handleCustomerCreated()` updated with defensive check
- [ ] Security warnings logged for metadata mismatches
- [ ] Profile updates prevented when correlation check fails
- [ ] Manual Test 1 (Normal subscription) passes
- [ ] Manual Test 2 (Wrong metadata) properly rejects
- [ ] Manual Test 3 (Lifetime purchase) passes
- [ ] Manual Test 4 (Duplicate customer) shows warning
- [ ] Manual Test 5 (Subscription deletion) passes
- [ ] Legitimate users can still subscribe successfully
- [ ] No regressions in existing webhook functionality

---

## Implementation Notes

### Edge Cases Handled

1. **New Customer (No Database Record)**
   - `handleCheckoutCompleted()` inserts customer record first
   - Correlation check happens after insertion
   - Database becomes source of truth immediately

2. **Missing Customer ID**
   - Payment mode checkouts without customer ID skip correlation check
   - Logged as warning for investigation
   - Rare but possible in some Stripe configurations

3. **Database Query Failure**
   - `verifyCustomerOwnership()` returns `valid: false` on errors
   - Fail-safe: denies access rather than risking false positive
   - Error logged for debugging

4. **Duplicate Customer Attempts**
   - `handleCustomerCreated()` detects and logs duplicates
   - Primary key constraint prevents insertion
   - Security warning helps identify malicious activity

### Code Patterns Followed

- ‚úÖ Uses Drizzle ORM for database queries
- ‚úÖ Uses webhook-logger utilities for consistent logging
- ‚úÖ Follows existing error handling patterns (throw to trigger Stripe retry)
- ‚úÖ Early returns for validation failures
- ‚úÖ Structured logging with context objects
- ‚úÖ TypeScript strict typing

### Files Modified

1. `lib/stripe-security.ts` (new file, ~50 lines)
2. `app/api/stripe/webhook/route.ts` (4 functions modified, ~40 lines added)

**Total Code Added:** ~90 lines
**Security Impact:** High (blocks privilege escalation attack)
**Performance Impact:** Negligible (~10-20ms per webhook)

---

## References

- Original ticket: `.claude/tickets/0019-add-webhook-metadata-correlation-check.md`
- Webhook handler: `app/api/stripe/webhook/route.ts`
- Database schema: `db/schema.ts:347-374` (stripe_customers table)
- Webhook logger: `lib/webhook-logger.ts`
- Stripe library: `lib/stripe.ts`
