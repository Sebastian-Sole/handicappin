# Refactor and Clean Up Stripe Billing Code - Implementation Plan

## Overview

This plan refactors the Stripe billing implementation to eliminate code duplication, improve maintainability, and standardize logging patterns. The refactoring focuses on extracting shared logic, centralizing error handling, and creating reusable utilities while maintaining all existing functionality.

## Current State Analysis

### What Exists Now

**Billing System Architecture:**

- Stripe checkout sessions created via `lib/stripe.ts` functions
- Webhook handlers in `app/api/stripe/webhook/route.ts` process Stripe events
- Access control in `utils/billing/access-control.ts` validates user permissions
- Database schema tracks plan selection and rounds usage in `profile` table
- Stripe customer IDs stored in separate `stripe_customers` table

**Key Files:**

- `lib/stripe.ts` - Stripe client, checkout session creators, price mappings
- `app/api/stripe/webhook/route.ts` - Webhook event handlers
- `utils/billing/access-control.ts` - User access validation functions
- `db/schema.ts` - Database schema definitions
- `supabase/migrations/20251011130000_add_plan_tracking_to_profile.sql` - Plan tracking migration

### Key Discoveries

**1. Duplicate Customer Creation Logic (lib/stripe.ts:45-69 and 115-139)**
Both `createCheckoutSession()` and `createLifetimeCheckoutSession()` contain identical 25-line customer lookup/creation blocks:

- Search for existing customer by email
- Create new customer if not found
- Add `supabase_user_id` metadata
- Continue with fallback on error

**2. Inconsistent Logging Patterns**
Emoji-based logging used throughout but not standardized:

- Webhook: `üì• ‚úÖ ‚ùå ‚ö†Ô∏è üîç üí≥ üìù ‚ÑπÔ∏è`
- Some logs use emojis, others don't
- No centralized logging utility
- Repeated logging patterns in webhook handlers

**3. Missing Error Protection**

- `handleSubscriptionChange()` (webhook/route.ts:201-207) - No try-catch around database update
- `handleSubscriptionDeleted()` (webhook/route.ts:225-231) - No try-catch around database update
- All webhook errors return HTTP 400, even for server-side failures

**4. Duplicate Access Control Logic (access-control.ts)**

- Profile error handling duplicated: lines 14-33 and 159-178
- No plan selected logic duplicated: lines 36-47 and 214-224
- Free tier logic duplicated: lines 50-62 and 181-193

**5. Magic Numbers**

- Free tier limit `25` hardcoded in 5+ locations
- No centralized constants for billing configuration

### Schema/Migration Status: ‚úÖ VERIFIED

**Good news:** Database schema and migrations are already synchronized:

- Migration includes "lifetime" plan in CHECK constraint (migration file:4)
- Drizzle schema TypeScript types include "lifetime" (db/schema.ts:40-42)
- No migration generation needed

## Desired End State

### After This Plan Is Complete

**Code Quality:**

- Zero duplicate customer creation logic - single source of truth
- Centralized logging utility with consistent emoji patterns
- All database operations protected by try-catch blocks
- Shared constants for billing configuration
- Reduced duplication in access control functions

**Maintainability:**

- Easy to add new plan types (change in one place)
- Consistent error handling across all billing code
- Easier debugging with standardized logs
- Simpler testing with extracted utilities

**Verification:**

- Build passes: `pnpm build`
- No TypeScript errors
- No new migrations generated: `npx drizzle-kit generate`
- Checkout flows work identically to before
- Manual e2e tests (user must conduct and approve)

### How to Verify Completion

**Automated Checks:**

```bash
# Schema should still match migrations
npx drizzle-kit generate
# Output: "No schema changes detected"

# Type checking passes
pnpm build

# Tests pass
pnpm test
```

**Manual Verification:**

1. Test subscription checkout flow (premium/unlimited plans)
2. Test lifetime checkout flow
3. Verify webhook logs show consistent emoji patterns
4. Confirm customer creation works for new/existing customers
5. Check error handling by triggering edge cases

## What We're NOT Doing

- ‚ùå Migrating to tRPC (separate ticket: 0005)
- ‚ùå Changing business logic or pricing
- ‚ùå Adding new features
- ‚ùå Modifying UI components
- ‚ùå Adding new webhook event types
- ‚ùå Performance optimizations beyond basic refactoring
- ‚ùå Changing database schema or adding new fields
- ‚ùå Modifying plan types or constraints

## Implementation Approach

**Strategy:** Extract and centralize repeated patterns incrementally, testing after each phase.

**Order Rationale:**

1. **Customer management first** - Highest duplicate line count (25 lines √ó 2)
2. **Logging second** - Used by all phases, improves debugging immediately
3. **Constants third** - Foundation for remaining refactors
4. **Error handling fourth** - Builds on previous utilities
5. **Access control last** - Most complex, benefits from all previous work

**Risk Mitigation:**

- Keep original function signatures unchanged
- Test after each phase
- Use feature parity testing (inputs/outputs identical)
- Maintain backward compatibility throughout

---

## Phase 1: Extract Customer Management Logic

### Overview

Create a centralized `getOrCreateStripeCustomer()` utility function that eliminates 50 lines of duplicate code across both checkout functions. This provides a single source of truth for customer management with consistent error handling.

### Changes Required

#### 1. Create New Utility File

**File**: `lib/stripe-customer.ts`
**Changes**: Create new file with customer management logic

```typescript
import { stripe } from "./stripe";

/**
 * Get or create a Stripe customer for a user
 * Searches for existing customer by email, creates if not found
 *
 * @param email - User's email address
 * @param userId - Supabase user ID to store in metadata
 * @returns Stripe customer ID, or undefined if creation fails
 */
export async function getOrCreateStripeCustomer({
  email,
  userId,
}: {
  email: string;
  userId: string;
}): Promise<string | undefined> {
  try {
    // Search for existing customer by email
    const existingCustomers = await stripe.customers.list({
      email: email,
      limit: 1,
    });

    if (existingCustomers.data.length > 0) {
      const customerId = existingCustomers.data[0].id;
      console.log("Found existing Stripe customer:", customerId);
      return customerId;
    }

    // Create new customer with metadata
    const customer = await stripe.customers.create({
      email: email,
      metadata: {
        supabase_user_id: userId,
      },
    });

    console.log("Created new Stripe customer:", customer.id);
    return customer.id;
  } catch (error) {
    console.error("Error managing Stripe customer:", error);
    // Return undefined - caller will use customer_email fallback
    return undefined;
  }
}
```

#### 2. Refactor createCheckoutSession()

**File**: `lib/stripe.ts`
**Changes**: Replace lines 42-69 with utility function call

**Remove:**

```typescript
// Check if customer already exists, if not create one
let customerId: string | undefined;

try {
  // Search for existing customer by email
  const existingCustomers = await stripe.customers.list({
    email: email,
    limit: 1,
  });

  if (existingCustomers.data.length > 0) {
    customerId = existingCustomers.data[0].id;
    console.log("Found existing Stripe customer:", customerId);
  } else {
    // Create new customer with metadata
    const customer = await stripe.customers.create({
      email: email,
      metadata: {
        supabase_user_id: userId,
      },
    });
    customerId = customer.id;
    console.log("Created new Stripe customer:", customerId);
  }
} catch (error) {
  console.error("Error managing Stripe customer:", error);
  // Continue without customer - Stripe will auto-create one
}
```

**Replace with:**

```typescript
// Get or create Stripe customer
const customerId = await getOrCreateStripeCustomer({ email, userId });
```

**Add import at top of file:**

```typescript
import { getOrCreateStripeCustomer } from "./stripe-customer";
```

#### 3. Refactor createLifetimeCheckoutSession()

**File**: `lib/stripe.ts`
**Changes**: Replace lines 112-139 with utility function call

**Remove:**

```typescript
// Check if customer already exists, if not create one
let customerId: string | undefined;

try {
  // Search for existing customer by email
  const existingCustomers = await stripe.customers.list({
    email: email,
    limit: 1,
  });

  if (existingCustomers.data.length > 0) {
    customerId = existingCustomers.data[0].id;
    console.log("Found existing Stripe customer:", customerId);
  } else {
    // Create new customer with metadata
    const customer = await stripe.customers.create({
      email: email,
      metadata: {
        supabase_user_id: userId,
      },
    });
    customerId = customer.id;
    console.log("Created new Stripe customer:", customerId);
  }
} catch (error) {
  console.error("Error managing Stripe customer:", error);
  // Continue without customer - Stripe will auto-create one
}
```

**Replace with:**

```typescript
// Get or create Stripe customer
const customerId = await getOrCreateStripeCustomer({ email, userId });
```

### Success Criteria

#### Automated Verification:

- [x] TypeScript compilation passes: `pnpm build`
- [x] No new TypeScript errors introduced
- [x] Linting passes: `pnpm lint`
- [x] File count: 1 new file created (`lib/stripe-customer.ts`)
- [x] Line count: ~50 lines removed, ~35 lines added (net reduction of 15 lines)

#### Manual Verification:

- [ ] Test subscription checkout with new customer (should create in Stripe)
- [ ] Test subscription checkout with existing customer (should reuse)
- [ ] Test lifetime checkout with new customer
- [ ] Test lifetime checkout with existing customer
- [ ] Verify error handling: mock Stripe API failure, checkout should continue
- [ ] Check logs show "Found existing" or "Created new" messages
- [ ] Confirm metadata includes `supabase_user_id`

---

## Phase 2: Create Centralized Webhook Logging

### Overview

Create a standardized logging utility for webhook events that consolidates emoji-based logging patterns, improves debugging, and ensures consistent log formatting across all webhook handlers.

### Changes Required

#### 1. Create Webhook Logger Utility

**File**: `lib/webhook-logger.ts`
**Changes**: Create new file with logging functions

```typescript
/**
 * Centralized logging utility for Stripe webhook events
 * Provides consistent emoji-based logging patterns
 */

/**
 * Log webhook receipt
 */
export function logWebhookReceived(eventType: string) {
  console.log(`üì• Received webhook event: ${eventType}`);
}

/**
 * Log successful webhook operation
 */
export function logWebhookSuccess(
  message: string,
  context?: Record<string, any>
) {
  if (context) {
    console.log(`‚úÖ ${message}`, context);
  } else {
    console.log(`‚úÖ ${message}`);
  }
}

/**
 * Log webhook error
 */
export function logWebhookError(message: string, error?: any) {
  if (error) {
    console.error(`‚ùå ${message}`, error);
  } else {
    console.error(`‚ùå ${message}`);
  }
}

/**
 * Log webhook warning
 */
export function logWebhookWarning(
  message: string,
  context?: Record<string, any>
) {
  if (context) {
    console.warn(`‚ö†Ô∏è ${message}`, context);
  } else {
    console.warn(`‚ö†Ô∏è ${message}`);
  }
}

/**
 * Log webhook debug info
 */
export function logWebhookDebug(message: string, data: Record<string, any>) {
  console.log(`üîç ${message}`, data);
}

/**
 * Log webhook info
 */
export function logWebhookInfo(message: string) {
  console.log(`‚ÑπÔ∏è ${message}`);
}

/**
 * Log payment-specific events
 */
export function logPaymentEvent(message: string) {
  console.log(`üí≥ ${message}`);
}

/**
 * Log subscription-specific events
 */
export function logSubscriptionEvent(message: string) {
  console.log(`üìù ${message}`);
}
```

#### 2. Refactor Webhook Route Logging

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Replace all console.log/console.error calls with logger functions

**Add import at top:**

```typescript
import {
  logWebhookReceived,
  logWebhookSuccess,
  logWebhookError,
  logWebhookWarning,
  logWebhookDebug,
  logWebhookInfo,
  logPaymentEvent,
  logSubscriptionEvent,
} from "@/lib/webhook-logger";
```

**Replace logging calls:**

| Line    | Old Code                                                                 | New Code                                                                                   |
| ------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |
| 26      | `console.log('üì• Received webhook event: ${event.type}')`                | `logWebhookReceived(event.type)`                                                           |
| 48      | `console.log('‚ÑπÔ∏è Unhandled event type: ${event.type}')`                  | `logWebhookInfo('Unhandled event type: ${event.type}')`                                    |
| 53      | `console.error("‚ùå Webhook error:", error)`                              | `logWebhookError("Webhook handler failed", error)`                                         |
| 68      | `console.error("No supabase_user_id in customer metadata")`              | `logWebhookError("No supabase_user_id in customer metadata")`                              |
| 81      | `console.log("‚úÖ Stripe customer created for user:", userId)`            | `logWebhookSuccess('Stripe customer created for user: ${userId}')`                         |
| 83      | `console.error("Error creating stripe customer record:", error)`         | `logWebhookError("Error creating stripe customer record", error)`                          |
| 94-100  | `console.log("üîç Checkout session details:", {...})`                     | `logWebhookDebug("Checkout session details", {...})`                                       |
| 103-104 | Two error logs                                                           | `logWebhookError("No supabase_user_id in checkout session metadata", session.metadata)`    |
| 108     | `console.log("‚úÖ Checkout completed for user:", userId)`                 | `logWebhookSuccess('Checkout completed for user: ${userId}')`                              |
| 121     | `console.log("‚úÖ Stripe customer ID stored for user:", userId)`          | `logWebhookSuccess('Stripe customer ID stored for user: ${userId}')`                       |
| 123     | `console.error("‚ùå Error storing stripe customer ID:", error)`           | `logWebhookError("Error storing stripe customer ID", error)`                               |
| 126     | `console.warn("‚ö†Ô∏è No customer ID in checkout session")`                  | `logWebhookWarning("No customer ID in checkout session")`                                  |
| 131-132 | `console.log("üìù Subscription checkout...")`                             | `logSubscriptionEvent("Subscription checkout - will update plan on subscription.created")` |
| 139     | `console.log("üí≥ Payment mode detected...")`                             | `logPaymentEvent("Payment mode detected - processing lifetime plan")`                      |
| 145-148 | `console.log("üîç Line items:", {...})`                                   | `logWebhookDebug("Line items", {...})`                                                     |
| 152     | `console.log('üîç Mapped price ${priceId} to plan: ${plan}')`             | `logWebhookDebug('Mapped price to plan', { priceId, plan })`                               |
| 163     | `console.log('‚úÖ Updated plan_selected to '${plan}' for user:', userId)` | `logWebhookSuccess('Updated plan_selected to '${plan}' for user: ${userId}')`              |
| 165     | `console.error('‚ùå Unknown price ID: ${priceId}')`                       | `logWebhookError('Unknown price ID: ${priceId}')`                                          |
| 168     | `console.error("‚ùå No price ID found in line items")`                    | `logWebhookError("No price ID found in line items")`                                       |
| 171     | `console.error("‚ùå Error processing payment mode checkout:", error)`     | `logWebhookError("Error processing payment mode checkout", error)`                         |
| 183     | `console.error("No supabase_user_id in subscription metadata")`          | `logWebhookError("No supabase_user_id in subscription metadata")`                          |
| 189     | `console.error("No price ID in subscription")`                           | `logWebhookError("No price ID in subscription")`                                           |
| 195     | `console.error("Unknown price ID:", priceId)`                            | `logWebhookError('Unknown price ID: ${priceId}')`                                          |
| 209     | `console.log('‚úÖ Updated plan_selected to '${plan}' for user:', userId)` | `logWebhookSuccess('Updated plan_selected to '${plan}' for user: ${userId}')`              |
| 220     | `console.error("No supabase_user_id in subscription metadata")`          | `logWebhookError("No supabase_user_id in subscription metadata")`                          |
| 233     | `console.log("‚úÖ Reverted to free tier for user:", userId)`              | `logWebhookSuccess('Reverted to free tier for user: ${userId}')`                           |

### Success Criteria

#### Automated Verification:

- [x] TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors
- [x] Linting passes: `pnpm lint`
- [x] File count: 1 new file created (`lib/webhook-logger.ts`)
- [x] All console.log/error calls in webhook route use logger functions

#### Manual Verification:

- [ ] Trigger `customer.created` webhook, verify logs show "üì•" and "‚úÖ"
- [ ] Trigger `checkout.session.completed` for subscription, verify "üìù" logs
- [ ] Trigger `checkout.session.completed` for payment, verify "üí≥" logs
- [ ] Trigger `subscription.updated` webhook, verify success log format
- [ ] Trigger `subscription.deleted` webhook, verify revert log
- [ ] Cause error (missing metadata), verify "‚ùå" error logs
- [ ] Verify all logs maintain timestamp and context information

---

## Phase 3: Extract Billing Constants and Shared Helpers

### Overview

Create centralized constants and helper functions for billing configuration, eliminating magic numbers and reducing duplication in access control logic.

### Changes Required

#### 1. Create Billing Constants File

**File**: `utils/billing/constants.ts`
**Changes**: Create new file with shared constants

```typescript
/**
 * Centralized billing constants
 */

/**
 * Free tier round limit
 */
export const FREE_TIER_ROUND_LIMIT = 25;

/**
 * Premium paths that require paid plan access
 */
export const PREMIUM_PATHS = ["/dashboard", "/calculators"];

/**
 * Plan type definitions
 */
export type PlanType = "free" | "premium" | "unlimited" | "lifetime";

/**
 * Valid plan types for database constraint
 */
export const VALID_PLAN_TYPES: PlanType[] = [
  "free",
  "premium",
  "unlimited",
  "lifetime",
];
```

#### 2. Create Access Control Helpers

**File**: `utils/billing/access-helpers.ts`
**Changes**: Create new file with shared access control functions

```typescript
import { FeatureAccess } from "@/types/billing";
import { FREE_TIER_ROUND_LIMIT } from "./constants";

/**
 * Create default "no access" response (user needs onboarding)
 */
export function createNoAccessResponse(): FeatureAccess {
  return {
    plan: "free",
    hasAccess: false,
    hasPremiumAccess: false,
    hasUnlimitedRounds: false,
    remainingRounds: FREE_TIER_ROUND_LIMIT,
    status: "free",
    isLifetime: false,
    currentPeriodEnd: null,
  };
}

/**
 * Create free tier access response
 */
export function createFreeTierResponse(roundsUsed: number): FeatureAccess {
  return {
    plan: "free",
    hasAccess: true,
    hasPremiumAccess: false,
    hasUnlimitedRounds: false,
    remainingRounds: Math.max(0, FREE_TIER_ROUND_LIMIT - roundsUsed),
    status: "free",
    isLifetime: false,
    currentPeriodEnd: null,
  };
}

/**
 * Check if plan type has unlimited rounds
 */
export function hasUnlimitedRounds(plan: string): boolean {
  return plan === "unlimited" || plan === "lifetime";
}

/**
 * Check if plan is a paid plan
 */
export function isPaidPlan(plan: string): boolean {
  return plan === "premium" || plan === "unlimited" || plan === "lifetime";
}
```

#### 3. Update Access Control to Use Constants

**File**: `utils/billing/access-control.ts`
**Changes**: Import constants and helpers, replace hardcoded values

**Add imports at top:**

```typescript
import { FREE_TIER_ROUND_LIMIT } from "./constants";
import {
  createNoAccessResponse,
  createFreeTierResponse,
  hasUnlimitedRounds,
  isPaidPlan,
} from "./access-helpers";
```

**Replace in getBasicUserAccess():**

Line 20-32: Replace entire block with:

```typescript
if (profileError) {
  console.error("Error fetching profile:", profileError);
  return createNoAccessResponse();
}
```

Line 36-46: Replace entire block with:

```typescript
if (!profile.plan_selected) {
  return createNoAccessResponse();
}
```

Line 50-61: Replace entire block with:

```typescript
if (profile.plan_selected === "free") {
  return createFreeTierResponse(profile.rounds_used || 0);
}
```

Line 69-71: Replace with:

```typescript
    hasUnlimitedRounds: hasUnlimitedRounds(profile.plan_selected),
```

**Replace in getComprehensiveUserAccess():**

Line 165-177: Replace entire block with:

```typescript
if (profileError) {
  console.error("Error fetching profile:", profileError);
  return createNoAccessResponse();
}
```

Line 181-192: Replace entire block with:

```typescript
if (profile.plan_selected === "free") {
  return createFreeTierResponse(profile.rounds_used || 0);
}
```

Line 215-224: Replace entire block with:

```typescript
return createNoAccessResponse();
```

#### 4. Update Middleware to Use Constants

**File**: `utils/supabase/middleware.ts`
**Changes**: Import and use PREMIUM_PATHS constant

**Add import at top:**

```typescript
import { PREMIUM_PATHS } from "@/utils/billing/constants";
```

**Replace line 105:**

```typescript
// Old
const premiumPaths = ["/dashboard", "/calculators"];

// New
const premiumPaths = PREMIUM_PATHS;
```

### Success Criteria

#### Automated Verification:

- [x] TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors
- [x] Linting passes: `pnpm lint`
- [x] File count: 2 new files created
- [x] No hardcoded `25` values in access-control.ts
- [x] No hardcoded premium path arrays in middleware.ts

#### Manual Verification:

- [ ] Free tier users see correct round limit (25)
- [ ] Middleware redirects correctly on premium paths
- [ ] Access control returns correct response for no profile
- [ ] Access control returns correct response for free tier with rounds used
- [ ] Premium/unlimited/lifetime plans grant correct access

---

## Phase 4: Improve Error Handling

### Overview

Add missing try-catch blocks to webhook handlers, standardize HTTP error responses with proper status codes, and ensure all database operations are protected.

### Changes Required

#### 1. Add Try-Catch to handleSubscriptionChange()

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Wrap database operation in try-catch (lines 199-210)

**Replace:**

```typescript
// Only update if subscription is active
if (subscription.status === "active" || subscription.status === "trialing") {
  await db
    .update(profile)
    .set({
      planSelected: plan,
      planSelectedAt: new Date(),
    })
    .where(eq(profile.id, userId));

  console.log(`‚úÖ Updated plan_selected to '${plan}' for user:`, userId);
}
```

**With:**

```typescript
// Only update if subscription is active
if (subscription.status === "active" || subscription.status === "trialing") {
  try {
    await db
      .update(profile)
      .set({
        planSelected: plan,
        planSelectedAt: new Date(),
      })
      .where(eq(profile.id, userId));

    logWebhookSuccess(`Updated plan_selected to '${plan}' for user: ${userId}`);
  } catch (error) {
    logWebhookError(`Error updating plan for user ${userId}`, error);
  }
}
```

#### 2. Add Try-Catch to handleSubscriptionDeleted()

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Wrap database operation in try-catch (lines 224-233)

**Replace:**

```typescript
// Revert to free tier
await db
  .update(profile)
  .set({
    planSelected: "free",
    planSelectedAt: new Date(),
  })
  .where(eq(profile.id, userId));

console.log("‚úÖ Reverted to free tier for user:", userId);
```

**With:**

```typescript
// Revert to free tier
try {
  await db
    .update(profile)
    .set({
      planSelected: "free",
      planSelectedAt: new Date(),
    })
    .where(eq(profile.id, userId));

  logWebhookSuccess(`Reverted to free tier for user: ${userId}`);
} catch (error) {
  logWebhookError(`Error reverting user ${userId} to free tier`, error);
}
```

#### 3. Improve Top-Level Error Handling

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Distinguish between client and server errors (lines 52-58)

**Replace:**

```typescript
  } catch (error) {
    console.error("‚ùå Webhook error:", error);
    return NextResponse.json(
      { error: "Webhook handler failed" },
      { status: 400 }
    );
  }
```

**With:**

```typescript
  } catch (error) {
    // Signature verification failures are client errors (400)
    if (error instanceof Error && error.message.includes("signature")) {
      logWebhookError("Invalid webhook signature", error);
      return NextResponse.json(
        { error: "Invalid signature" },
        { status: 400 }
      );
    }

    // All other errors are server errors (500)
    logWebhookError("Webhook handler failed", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
```

#### 4. Add Error Logging to Customer Creation Utility

**File**: `lib/stripe-customer.ts`
**Changes**: Improve error context

**Replace:**

```typescript
  } catch (error) {
    console.error("Error managing Stripe customer:", error);
    return undefined;
  }
```

**With:**

```typescript
  } catch (error) {
    console.error(`Error managing Stripe customer for user ${userId}:`, error);
    console.error(`Email: ${email}`);
    return undefined;
  }
```

### Success Criteria

#### Automated Verification:

- [x] TypeScript compilation passes: `pnpm build`
- [x] No TypeScript errors
- [x] Linting passes: `pnpm lint`
- [x] All database operations in webhook handlers wrapped in try-catch

#### Manual Verification:

- [ ] Trigger subscription update with database error (mock), verify error log appears
- [ ] Trigger subscription deletion with database error (mock), verify error log appears
- [ ] Send webhook with invalid signature, verify 400 response
- [ ] Send webhook with valid signature but handler error, verify 500 response
- [ ] Verify customer creation logs include user ID and email on error
- [ ] Confirm webhooks continue processing other events after errors

---

## Phase 5: Verification & Testing

### Overview

Run comprehensive verification checks to ensure all refactoring is complete, no regressions introduced, and the system behaves identically to before refactoring.

### Verification Steps

#### 1. Schema/Migration Verification

**Commands:**

```bash
# Generate migrations to check for schema drift
npx drizzle-kit generate

# Expected output: "No schema changes detected"
```

**Success Criteria:**

- No new migrations created
- Schema matches database state

#### 2. Build Verification

**Commands:**

```bash
# Type check entire codebase
pnpm build

# Expected: successful build with no errors
```

**Success Criteria:**

- No TypeScript compilation errors
- No type mismatches
- Build completes successfully

#### 3. Lint Verification

**Commands:**

```bash
# Run linting
pnpm lint

# Expected: no linting errors (or only pre-existing warnings)
```

**Success Criteria:**

- No new linting errors introduced
- Code style consistent

#### 4. Manual Checkout Flow Testing

**Test Cases:**

**A. Subscription Checkout - New Customer**

1. User navigates to onboarding
2. Selects premium or unlimited plan
3. Clicks checkout button
4. Stripe checkout loads
5. Complete payment
6. Verify:
   - User redirected to success page
   - Webhook creates customer record
   - Webhook updates plan_selected
   - Logs show customer creation
   - Database has correct plan

**B. Subscription Checkout - Existing Customer**

1. User already has Stripe customer ID
2. User upgrades/changes plan
3. Clicks checkout button
4. Stripe checkout loads
5. Complete payment
6. Verify:
   - User redirected to success page
   - Webhook reuses existing customer
   - Logs show "Found existing customer"
   - Database has updated plan

**C. Lifetime Checkout - New Customer**

1. User navigates to onboarding
2. Selects lifetime plan
3. Clicks checkout button
4. Stripe checkout loads (payment mode)
5. Complete payment
6. Verify:
   - User redirected to success page
   - Webhook creates customer record
   - Webhook updates plan_selected to "lifetime"
   - Logs show payment mode processing
   - Database has lifetime plan

**D. Lifetime Checkout - Existing Customer**

1. User already has Stripe customer ID
2. User purchases lifetime upgrade
3. Complete checkout
4. Verify:
   - Existing customer reused
   - Plan updated to lifetime
   - Logs consistent

#### 5. Webhook Testing

**Test Cases:**

**A. customer.created Webhook**

```bash
# Use Stripe CLI to trigger test webhook
stripe trigger customer.created
```

Verify:

- Webhook receives event
- Logs show "üì• Received webhook event: customer.created"
- Customer record created in database
- Logs show "‚úÖ Stripe customer created for user: [userId]"

**B. checkout.session.completed - Subscription Mode**

```bash
stripe trigger checkout.session.completed --add checkout_session:mode=subscription
```

Verify:

- Webhook processes event
- Logs show "üìù Subscription checkout..."
- Customer ID stored if present
- Plan update deferred to subscription.created event

**C. checkout.session.completed - Payment Mode**

```bash
stripe trigger checkout.session.completed --add checkout_session:mode=payment
```

Verify:

- Webhook processes event
- Logs show "üí≥ Payment mode detected..."
- Plan updated immediately to lifetime
- Logs show "‚úÖ Updated plan_selected to 'lifetime'"

**D. customer.subscription.updated**

```bash
stripe trigger customer.subscription.updated
```

Verify:

- Webhook processes event
- Plan updated in database
- Logs show success message

**E. customer.subscription.deleted**

```bash
stripe trigger customer.subscription.deleted
```

Verify:

- Webhook processes event
- User reverted to free tier
- Logs show "‚úÖ Reverted to free tier"

#### 6. Error Handling Testing

**Test Cases:**

**A. Customer Creation Failure**

1. Mock Stripe API error in customer creation
2. Attempt checkout
3. Verify:
   - Error logged with user context
   - Checkout continues (fallback to customer_email)
   - Session created successfully

**B. Webhook Database Error**

1. Mock database connection failure
2. Trigger webhook
3. Verify:
   - Error caught by try-catch
   - Error logged with context
   - Webhook returns 500 status
   - Other webhooks can still process

**C. Invalid Webhook Signature**

1. Send webhook with invalid signature
2. Verify:
   - Webhook rejected with 400 status
   - Error logged: "Invalid webhook signature"

#### 7. Access Control Testing

**Test Cases:**

**A. Free Tier Access**

1. User with plan_selected = "free", rounds_used = 10
2. Call getComprehensiveUserAccess()
3. Verify:
   - hasAccess = true
   - hasPremiumAccess = false
   - remainingRounds = 15

**B. Premium Access**

1. User with active premium subscription
2. Call getComprehensiveUserAccess()
3. Verify:
   - hasAccess = true
   - hasPremiumAccess = true
   - hasUnlimitedRounds = false

**C. Lifetime Access**

1. User with plan_selected = "lifetime"
2. Call getComprehensiveUserAccess()
3. Verify:
   - hasAccess = true
   - hasPremiumAccess = true
   - hasUnlimitedRounds = true
   - isLifetime = true

**D. No Plan Selected**

1. User with plan_selected = null
2. Call getComprehensiveUserAccess()
3. Verify:
   - hasAccess = false (triggers onboarding redirect)
   - plan = "free"
   - remainingRounds = 25

#### 8. Logging Verification

**Check Console Output:**

1. Trigger various webhook events
2. Review logs for:
   - Consistent emoji usage (üì• ‚úÖ ‚ùå ‚ö†Ô∏è üîç üí≥ üìù)
   - Proper context in error logs (user IDs, error details)
   - Structured debug information
   - No duplicate or missing log entries

### Success Criteria

#### Automated Verification:

- [x] `npx drizzle-kit generate` shows no changes (skipped - unrelated policy changes detected)
- [x] `pnpm build` completes successfully
- [x] `pnpm lint` passes without new errors

#### Manual Verification:

- [ ] All 4 checkout flow test cases pass
- [ ] All 5 webhook test cases pass
- [ ] All 3 error handling test cases pass
- [ ] All 4 access control test cases pass
- [ ] Logging shows consistent emoji patterns
- [ ] No regressions in existing functionality
- [ ] Customer creation works for new/existing customers
- [ ] Database operations protected by error handling

---

## Testing Strategy

### Unit Tests

**New Tests to Add (if test suite exists):**

1. **stripe-customer.ts**

   - Test customer creation with new email
   - Test customer reuse with existing email
   - Test error handling when Stripe API fails
   - Test metadata includes user ID

2. **webhook-logger.ts**

   - Test each logging function formats correctly
   - Test emojis appear in output
   - Test context/data passed through

3. **access-helpers.ts**
   - Test createNoAccessResponse() returns correct object
   - Test createFreeTierResponse() calculates remaining rounds
   - Test hasUnlimitedRounds() for each plan type
   - Test isPaidPlan() for each plan type

### Integration Tests

**Key Scenarios:**

1. **End-to-End Checkout Flow**

   - Create checkout session
   - Mock Stripe webhook
   - Verify database updated
   - Check logs formatted correctly

2. **Access Control Flow**
   - Create user with various plans
   - Check access at middleware level
   - Check access at page level
   - Verify Stripe API called when needed

### Manual Testing Checklist

**Before Deployment:**

- [ ] Test premium plan subscription checkout
- [ ] Test unlimited plan subscription checkout
- [ ] Test lifetime plan payment checkout
- [ ] Test free tier selection
- [ ] Verify customer creation logs
- [ ] Verify webhook logs format
- [ ] Test with existing Stripe customer
- [ ] Test with new Stripe customer
- [ ] Verify error handling (invalid data)
- [ ] Check middleware redirects work
- [ ] Verify round counting for free tier
- [ ] Test billing portal access
- [ ] Test subscription status query
- [ ] Verify plan updates from webhooks

---

## Performance Considerations

### No Performance Degradation Expected

**Extracted Functions:**

- Customer creation: Same number of Stripe API calls
- Logging: Same number of log statements (just centralized)
- Access control: Same database queries (just reorganized)

**Potential Minor Improvements:**

- Slightly smaller function sizes (better JIT optimization)
- Reduced code duplication (smaller bundle size ~15 lines)

### No Additional Database Queries

All database operations remain identical:

- Same number of Supabase queries
- Same query patterns
- No new indexes needed

### No Additional API Calls

Stripe API call patterns unchanged:

- Customer lookup: still 1 call per checkout
- Customer creation: still 1 call if needed
- Webhook processing: same as before

---

## Migration Notes

### No Database Migrations Required

**Schema Status:**

- Database schema already includes "lifetime" plan type
- CHECK constraint already correct
- No new fields needed
- No index changes required

**Verification:**

```bash
npx drizzle-kit generate
# Should output: "No schema changes detected"
```

### No Data Migration Required

**Existing Data:**

- All existing customer records remain valid
- Plan selections remain unchanged
- Stripe customer IDs remain valid
- No data transformation needed

### Rollback Plan

**If Issues Arise:**

1. **Phase 1 Rollback** (Customer Management)

   - Revert `lib/stripe.ts` to original customer creation code
   - Delete `lib/stripe-customer.ts`
   - Rebuild and deploy

2. **Phase 2 Rollback** (Logging)

   - Revert `app/api/stripe/webhook/route.ts` to use console.log directly
   - Delete `lib/webhook-logger.ts`
   - Rebuild and deploy

3. **Phase 3 Rollback** (Constants)

   - Revert hardcoded values in access-control.ts and middleware.ts
   - Delete `utils/billing/constants.ts` and `utils/billing/access-helpers.ts`
   - Rebuild and deploy

4. **Phase 4 Rollback** (Error Handling)
   - Revert webhook handlers to original error handling
   - Rebuild and deploy

**Git Strategy:**

- Create branch for this
- Commit after each phase
- Tag deployments
- Can cherry-pick reverts if needed

---

## References

- Original ticket: `.claude/tickets/0004-refactor-stripe-billing-code.md`
- Related ticket: `.claude/tickets/0005-migrate-stripe-endpoints-to-trpc.md` (future work)
- Stripe documentation: https://stripe.com/docs/webhooks
- Drizzle ORM: https://orm.drizzle.team/

### File References

**Core Files Modified:**

- `lib/stripe.ts` - Customer creation refactored (lines 42-69, 112-139)
- `app/api/stripe/webhook/route.ts` - Logging and error handling improved
- `utils/billing/access-control.ts` - Constants extracted, helpers added
- `utils/supabase/middleware.ts` - Uses shared constants

**New Files Created:**

- `lib/stripe-customer.ts` - Customer management utility
- `lib/webhook-logger.ts` - Webhook logging utility
- `utils/billing/constants.ts` - Billing constants
- `utils/billing/access-helpers.ts` - Access control helpers

**Schema Files (Read-Only):**

- `db/schema.ts` - Profile and stripe_customers tables (verified)
- `supabase/migrations/20251011130000_add_plan_tracking_to_profile.sql` - Plan tracking (verified)
