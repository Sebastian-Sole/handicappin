# Stripe Checkout & Billing Entitlements System Implementation Plan

## Overview

Implement a robust, enterprise-grade billing system using Stripe Checkout Sessions and Customer Portal with a dedicated `billing` schema. Feature access is controlled by Stripe-derived entitlements with webhook-driven synchronization, forced onboarding flow, and strict access control.

**Architecture:** Supabase Backend → Stripe Webhooks → Dedicated Billing Schema → Next.js Frontend

## Current State Analysis

### Existing Infrastructure

**Database (Drizzle ORM):**

- Schema defined in `db/schema.ts` (public schema only)
- Migrations in `supabase/migrations/`
- Profile table: `id`, `email`, `name`, `handicapIndex`, `verified`, `createdAt`
- Round tracking: `round`, `score`, `course`, `teeInfo`, `hole` tables
- RLS policies enabled on all tables

**Authentication & Middleware:**

- Supabase Auth with email verification (`/app/verify-email/page.tsx`)
- Middleware: `utils/supabase/middleware.ts` - basic auth checks, redirects unauthenticated users
- Public paths: `/`, `/login`, `/signup`, `/calculators`, `/about`, `/api`, `/verify-email`, `/forgot-password`
- Post-verification flow: Redirects to `/login?verified=true` (manual login required)

**API Infrastructure:**

- tRPC API in `server/api/routers/`
- `authedProcedure` middleware for authentication
- Single API route: `/app/api/trpc/[trpc]/route.ts`
- Environment variables managed via `env.js` with Zod validation

**Current User Flow:**

```
Signup → Email Verification → Manual Login → Dashboard
```

### What Doesn't Exist

- ❌ No billing or subscription infrastructure
- ❌ No onboarding flow (empty `/app/onboarding/` directory exists)
- ❌ No Stripe integration
- ❌ No feature gating or access control beyond authentication
- ❌ No round limit tracking or enforcement
- ❌ No entitlement checking

### Key Discoveries

**File References:**

- Database schema: `db/schema.ts:1-331`
- Middleware: `utils/supabase/middleware.ts:7-118`
- tRPC config: `server/api/trpc.ts:93-105` (`authedProcedure`)
- Environment config: `env.js:1-53`
- Drizzle config: `drizzle.config.ts:1-16` (schema filter: `["public"]`)
- Verification flow: `app/verify-email/page.tsx:59` (redirects to `/login?verified=true`)
- Round submission: `server/api/routers/round.ts:151-389` (no limits)

## Desired End State

### Target User Flow

```
Signup → Email Verification → Manual Login → Forced Onboarding → Plan Selection → App Access
```

**For Free Tier:**

```
Onboarding → Select "Free" → Server creates entitlement → Dashboard access → 25 round limit
```

**For Paid Tiers:**

```
Onboarding → Select Plan → Stripe Checkout → Payment → Webhook → Entitlement created → Dashboard access
```

### Database Schema (Billing)

**New `billing` schema with 3 tables:**

1. `billing.customers` - Links Supabase users to Stripe customers
2. `billing.subscriptions` - Stores subscription status and entitlements
3. `billing.events` - Audit log for webhook events

**Integration:** All managed via Drizzle ORM with proper schema filtering

### Feature Access Logic

```typescript
// Premium access: active subscription OR lifetime purchase OR free tier
const hasPremiumAccess = (
  (plan IN ('premium', 'unlimited') AND status IN ('active', 'trialing'))
  OR is_lifetime === true
)

// Round limit: free tier only
const canAddRound = (
  subscription.plan !== 'free'
  OR roundCount < 25
)
```

### Verification Criteria

**Automated Verification:**

- [ ] All TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] Environment variables validated
- [ ] Database migration succeeds: `supabase db reset` (reset local db)

**Manual Verification:**

- [ ] User cannot access dashboard without entitlement
- [ ] Onboarding blocks app access until plan selected
- [ ] Free plan creates entitlement without Stripe
- [ ] Paid plan redirects to Stripe Checkout
- [ ] Webhook creates entitlement after payment
- [ ] Customer Portal allows subscription management
- [ ] Promotion code works (100% off Premium)
- [ ] Round limit enforced for free tier (25 rounds)

## What We're NOT Doing

**Out of Scope (Per Ticket):**

- Team/seat-based billing (single-user only)
- Usage-based metering (fixed tiers)
- Multi-tenant organizations
- Custom proration logic (use Stripe defaults)
- Referral system
- Affiliate tracking
- Custom invoice generation
- Multiple payment methods (cards only)
- Tax calculation (use Stripe Tax if needed later)
- Advanced analytics dashboard
- Reconciliation job (future enhancement)
- Email change syncing to Stripe (future enhancement)

**Separate Tasks:**

- Automatic login after email verification (complex, deferred)

## Implementation Approach

### Strategy

1. **Database-First:** Create billing schema with Drizzle, generate migrations, test locally
2. **Stripe Integration:** Set up library, types, and environment variables
3. **API Routes:** Build Checkout, Portal, and Webhook handlers
4. **Forced Flow:** Implement onboarding page and middleware checks
5. **Access Control:** Add entitlement checks throughout the app
6. **Testing:** Local testing with Stripe CLI, then production validation

### Key Technical Decisions

**Decision 1: Drizzle Schema Management**

- **Choice:** Update `drizzle.config.ts` to include `billing` schema in schema filter
- **Rationale:** Keeps all database changes in Drizzle ORM for consistency
- **Impact:** Single source of truth for schema, generates proper migrations

**Decision 2: Billing Schema Separation**

- **Choice:** Create dedicated `billing` schema (not `public` schema)
- **Rationale:** Security isolation, prevents accidental client-side access
- **Impact:** Better RLS policy management, clear separation of concerns

**Decision 3: Webhook RPC Pattern**

- **Choice:** Use PostgreSQL RPC function `upsert_subscription()` for atomic updates
- **Rationale:** Idempotent webhook handling, prevents race conditions
- **Impact:** Safe duplicate webhook processing, simpler error handling

**Decision 4: Login Flow**

- **Choice:** Keep manual login after verification (don't implement auto-login)
- **Rationale:** Complex to implement securely, deferred to separate task
- **Impact:** User flow: verify email → login → onboarding (one extra step)

---

## Phase 1: Database Schema & Environment Setup

### Overview

Set up the billing schema with Drizzle ORM, configure environment variables, and generate migrations. This establishes the foundation for all subscription and entitlement management.

### Changes Required

#### 1. Update Drizzle Configuration

**File:** `drizzle.config.ts`

**Changes:** Add `billing` schema to schema filter

```typescript
import { config } from "dotenv";
import { defineConfig } from "drizzle-kit";

config({ path: ".env" });

export default defineConfig({
  schema: "./db/schema.ts",
  out: "./supabase/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
  schemaFilter: ["public", "billing"], // ← Add "billing" schema
  migrations: { prefix: "supabase" },
});
```

**Reason:** Allows Drizzle to manage both `public` and `billing` schemas

#### 2. Add Billing Schema to Database Schema

**File:** `db/schema.ts`

**Changes:** Add billing schema tables at the end of the file

```typescript
// ... existing imports and public schema tables ...

// ============================================
// BILLING SCHEMA
// ============================================

const billingSchema = pgSchema("billing");

// billing.customers - Links Supabase users to Stripe customers
export const billingCustomers = billingSchema.table(
  "customers",
  {
    userId: uuid("user_id")
      .primaryKey()
      .notNull()
      .references(() => usersInAuth.id, { onDelete: "cascade" }),
    stripeCustomerId: text("stripe_customer_id").unique().notNull(),
    createdAt: timestamp("created_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
  },
  (table) => [
    pgPolicy("Users can view their own customer record", {
      as: "permissive",
      for: "select",
      to: ["authenticated"],
      using: sql`(auth.uid()::uuid = user_id)`,
    }),
  ]
);

export const billingCustomersSchema = createSelectSchema(billingCustomers);
export type BillingCustomer = InferSelectModel<typeof billingCustomers>;

// billing.subscriptions - Stores subscription status and entitlements
export const billingSubscriptions = billingSchema.table(
  "subscriptions",
  {
    userId: uuid("user_id")
      .primaryKey()
      .notNull()
      .references(() => usersInAuth.id, { onDelete: "cascade" }),
    stripeSubscriptionId: text("stripe_subscription_id"), // NULL for free tier and lifetime
    plan: text("plan").notNull(), // 'free' | 'premium' | 'unlimited'
    status: text("status").notNull(), // 'active' | 'canceled' | 'past_due' | 'incomplete' | 'trialing'
    currentPeriodEnd: timestamp("current_period_end"), // NULL for free and lifetime
    isLifetime: boolean("is_lifetime").default(false).notNull(),
    updatedAt: timestamp("updated_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
  },
  (table) => [
    pgPolicy("Users can view their own subscription", {
      as: "permissive",
      for: "select",
      to: ["authenticated"],
      using: sql`(auth.uid()::uuid = user_id)`,
    }),
  ]
);

export const billingSubscriptionsSchema =
  createSelectSchema(billingSubscriptions);
export type BillingSubscription = InferSelectModel<typeof billingSubscriptions>;

// billing.events - Audit log for webhook events
export const billingEvents = billingSchema.table(
  "events",
  {
    id: serial("id").primaryKey(),
    userId: uuid("user_id"), // NULL if event not tied to specific user
    type: text("type").notNull(),
    payload: text("payload").notNull(), // JSON string
    createdAt: timestamp("created_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
  },
  (table) => [
    pgPolicy("Service role can insert events", {
      as: "permissive",
      for: "insert",
      to: ["service_role"],
      withCheck: sql`true`,
    }),
  ]
);

export const billingEventsSchema = createSelectSchema(billingEvents);
export type BillingEvent = InferSelectModel<typeof billingEvents>;
```

**Reason:** Defines billing tables with proper RLS policies and foreign keys

#### 3. Add PostgreSQL RPC Function for Upsert

**File:** `db/schema.ts` (add after billing tables)

**Note:** Drizzle doesn't natively support RPC functions, so we'll create this in a post-migration SQL script

**Post-Migration SQL:** Create file `supabase/migrations/manual_post_billing_setup.sql`

```sql
-- RPC function for atomic subscription upserts (idempotent webhook handling)
CREATE OR REPLACE FUNCTION billing.upsert_subscription(
  p_user_id UUID,
  p_stripe_subscription_id TEXT,
  p_plan TEXT,
  p_status TEXT,
  p_current_period_end TIMESTAMPTZ,
  p_is_lifetime BOOLEAN
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO billing.subscriptions (
    user_id,
    stripe_subscription_id,
    plan,
    status,
    current_period_end,
    is_lifetime,
    updated_at
  )
  VALUES (
    p_user_id,
    p_stripe_subscription_id,
    p_plan,
    p_status,
    p_current_period_end,
    p_is_lifetime,
    NOW()
  )
  ON CONFLICT (user_id)
  DO UPDATE SET
    stripe_subscription_id = EXCLUDED.stripe_subscription_id,
    plan = EXCLUDED.plan,
    status = EXCLUDED.status,
    current_period_end = EXCLUDED.current_period_end,
    is_lifetime = EXCLUDED.is_lifetime,
    updated_at = NOW();
END;
$$;

-- Grant execute permission to service role
GRANT EXECUTE ON FUNCTION billing.upsert_subscription TO service_role;
```

**Reason:** Atomic, idempotent subscription updates for webhook handling

#### 4. Update Environment Variables

**File:** `env.js`

**Changes:** Add Stripe environment variables to server and client schemas

```typescript
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    DATABASE_URL: z.string().url(),
    DIRECT_URL: z.string().url(),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),

    // Stripe server-side keys
    STRIPE_SECRET_KEY: z.string().startsWith("sk_"),
    STRIPE_WEBHOOK_SECRET: z.string().startsWith("whsec_"),

    // Stripe Price IDs
    STRIPE_PREMIUM_PRICE_ID: z.string().startsWith("price_"),
    STRIPE_UNLIMITED_PRICE_ID: z.string().startsWith("price_"),
    STRIPE_UNLIMITED_LIFETIME_PRICE_ID: z.string().startsWith("price_"),

    // Supabase Service Role Key (for webhook writes)
    SUPABASE_SERVICE_ROLE_KEY: z.string(),
  },

  client: {
    NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
    NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string(),
    NEXT_PUBLIC_BASE_URL: z.string().url().optional(),

    // Stripe publishable key
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().startsWith("pk_"),

    // Site URL for Stripe redirects
    NEXT_PUBLIC_SITE_URL: z.string().url().default("http://localhost:3000"),
  },

  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    DIRECT_URL: process.env.DIRECT_URL,
    NODE_ENV: process.env.NODE_ENV,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
    NEXT_PUBLIC_BASE_URL: process.env.NEXT_PUBLIC_BASE_URL,

    // Stripe
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
    STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
    STRIPE_PREMIUM_PRICE_ID: process.env.STRIPE_PREMIUM_PRICE_ID,
    STRIPE_UNLIMITED_PRICE_ID: process.env.STRIPE_UNLIMITED_PRICE_ID,
    STRIPE_UNLIMITED_LIFETIME_PRICE_ID:
      process.env.STRIPE_UNLIMITED_LIFETIME_PRICE_ID,
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:
      process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,
    NEXT_PUBLIC_SITE_URL: process.env.NEXT_PUBLIC_SITE_URL,
    SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  },

  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  emptyStringAsUndefined: true,
});
```

**Reason:** Type-safe environment variable validation for Stripe integration

#### 5. Create .env.local Template

**File:** `.env.example` (create if doesn't exist)

**Add these entries:**

```bash
# Stripe API Keys (Test Mode)
STRIPE_SECRET_KEY=sk_test_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Stripe Price IDs (from Stripe Dashboard)
STRIPE_PREMIUM_PRICE_ID=price_...
STRIPE_UNLIMITED_PRICE_ID=price_...
STRIPE_UNLIMITED_LIFETIME_PRICE_ID=price_...

# Site URL
NEXT_PUBLIC_SITE_URL=http://localhost:3000

# Supabase Service Role Key (for webhook writes)
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key_here
```

**Reason:** Documentation for required environment variables

### Success Criteria

#### Automated Verification:

- [x] TypeScript compiles: `pnpm build`
- [x] No linting errors: `pnpm lint`
- [ ] Drizzle generates migration: `npx drizzle-kit generate` (user must run)
- [ ] Migration file created in `supabase/migrations/` (user must run)
- [ ] Local database reset succeeds: `npx supabase db reset` (user must run)
- [ ] Billing schema exists: Query `SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'billing'` (user must run)
- [ ] Tables created: Query `SELECT table_name FROM information_schema.tables WHERE table_schema = 'billing'` (user must run)

#### Manual Verification:

- [x] `.env.local` has all Stripe variables template in `.env.example`
- [x] Drizzle config includes both schemas
- [ ] Migration file contains billing tables (after generation)
- [ ] RLS policies created on billing tables (after migration)
- [ ] `upsert_subscription` RPC function exists (SQL file created)

---

## Phase 2: Stripe Library & Type Definitions

### Overview

Create Stripe client library, billing types, and helper functions for checkout, portal, and subscription management.

### Changes Required

#### 1. Install Stripe Dependencies

**Command:**

```bash
pnpm add stripe @stripe/stripe-js
pnpm add -D @types/node
```

**Reason:** Stripe SDK for server and client-side integration

#### 2. Create Stripe Library

**File:** `lib/stripe.ts` (create new file)

```typescript
import Stripe from "stripe";
import { env } from "@/env";

// Initialize Stripe client with secret key
export const stripe = new Stripe(env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-11-20.acacia",
  typescript: true,
});

// Price ID to Plan mapping
export const PRICE_TO_PLAN_MAP: Record<string, "premium" | "unlimited"> = {
  [env.STRIPE_PREMIUM_PRICE_ID]: "premium",
  [env.STRIPE_UNLIMITED_PRICE_ID]: "unlimited",
  [env.STRIPE_UNLIMITED_LIFETIME_PRICE_ID]: "unlimited",
};

// Plan to Price ID mapping (for UI)
export const PLAN_TO_PRICE_MAP = {
  premium: env.STRIPE_PREMIUM_PRICE_ID,
  unlimited: env.STRIPE_UNLIMITED_PRICE_ID,
  "unlimited-lifetime": env.STRIPE_UNLIMITED_LIFETIME_PRICE_ID,
} as const;

/**
 * Map Stripe price ID to internal plan type
 */
export function mapPriceToPlan(
  priceId: string
): "premium" | "unlimited" | null {
  return PRICE_TO_PLAN_MAP[priceId] ?? null;
}

/**
 * Get or create Stripe customer for a Supabase user
 */
export async function getOrCreateCustomer(
  userId: string,
  email: string,
  stripeCustomerId?: string | null
): Promise<string> {
  // If we already have a customer ID, return it
  if (stripeCustomerId) {
    return stripeCustomerId;
  }

  // Create new Stripe customer with user metadata
  const customer = await stripe.customers.create({
    email,
    metadata: {
      supabase_user_id: userId,
    },
  });

  return customer.id;
}

/**
 * Create Stripe Checkout Session for subscription or one-time payment
 */
export async function createCheckoutSession({
  customerId,
  priceId,
  mode,
  userId,
  successUrl,
  cancelUrl,
}: {
  customerId: string;
  priceId: string;
  mode: "subscription" | "payment";
  userId: string;
  successUrl: string;
  cancelUrl: string;
}): Promise<Stripe.Checkout.Session> {
  const session = await stripe.checkout.sessions.create({
    customer: customerId,
    mode,
    line_items: [
      {
        price: priceId,
        quantity: 1,
      },
    ],
    success_url: successUrl,
    cancel_url: cancelUrl,
    client_reference_id: userId,
    metadata: {
      supabase_user_id: userId,
    },
    allow_promotion_codes: true, // Enable promo codes
    billing_address_collection: "auto",
  });

  return session;
}

/**
 * Create Stripe Customer Portal session for subscription management
 */
export async function createPortalSession({
  customerId,
  returnUrl,
}: {
  customerId: string;
  returnUrl: string;
}): Promise<Stripe.BillingPortal.Session> {
  const session = await stripe.billingPortal.sessions.create({
    customer: customerId,
    return_url: returnUrl,
  });

  return session;
}
```

**Reason:** Centralized Stripe operations with type-safe helpers

#### 3. Create Billing Types

**File:** `types/billing.ts` (create new file)

```typescript
import { z } from "zod";

// Plan types
export const planSchema = z.enum(["free", "premium", "unlimited"]);
export type Plan = z.infer<typeof planSchema>;

// Subscription status types (matches Stripe)
export const subscriptionStatusSchema = z.enum([
  "active",
  "canceled",
  "incomplete",
  "incomplete_expired",
  "past_due",
  "trialing",
  "unpaid",
]);
export type SubscriptionStatus = z.infer<typeof subscriptionStatusSchema>;

// Subscription type
export const subscriptionSchema = z.object({
  userId: z.string().uuid(),
  stripeSubscriptionId: z.string().nullable(),
  plan: planSchema,
  status: subscriptionStatusSchema,
  currentPeriodEnd: z.date().nullable(),
  isLifetime: z.boolean(),
  updatedAt: z.date(),
});
export type Subscription = z.infer<typeof subscriptionSchema>;

// Customer type
export const customerSchema = z.object({
  userId: z.string().uuid(),
  stripeCustomerId: z.string(),
  createdAt: z.date(),
});
export type Customer = z.infer<typeof customerSchema>;

// Checkout request
export const checkoutRequestSchema = z.object({
  priceId: z.string().startsWith("price_"),
  mode: z.enum(["subscription", "payment"]),
});
export type CheckoutRequest = z.infer<typeof checkoutRequestSchema>;

// Feature access helper types
export interface FeatureAccess {
  hasPremiumAccess: boolean;
  hasUnlimitedRounds: boolean;
  plan: Plan;
  status: SubscriptionStatus | "free";
  isLifetime: boolean;
}
```

**Reason:** Type-safe billing domain models with Zod validation

#### 4. Create Billing Utilities

**File:** `utils/billing/entitlements.ts` (create new file)

```typescript
import { createServerComponentClient } from "@/utils/supabase/server";
import type { FeatureAccess, Plan, SubscriptionStatus } from "@/types/billing";

/**
 * Get user's subscription and feature access
 * Used in server components and API routes
 */
export async function getUserSubscription(
  userId: string
): Promise<FeatureAccess | null> {
  const supabase = await createServerComponentClient();

  const { data: subscription, error } = await supabase
    .from("subscriptions")
    .select("*")
    .eq("user_id", userId)
    .single();

  if (error || !subscription) {
    return null;
  }

  const plan = subscription.plan as Plan;
  const status = subscription.status as SubscriptionStatus;
  const isLifetime = subscription.is_lifetime;

  // Premium access logic
  const hasPremiumAccess =
    (["premium", "unlimited"].includes(plan) &&
      ["active", "trialing"].includes(status)) ||
    isLifetime;

  // Unlimited rounds logic
  const hasUnlimitedRounds = plan !== "free" || isLifetime;

  return {
    hasPremiumAccess,
    hasUnlimitedRounds,
    plan,
    status,
    isLifetime,
  };
}

/**
 * Check if user can add a new round
 */
export async function canAddRound(userId: string): Promise<boolean> {
  const access = await getUserSubscription(userId);

  if (!access) {
    return false; // No subscription = no access
  }

  // Unlimited rounds for non-free tiers
  if (access.hasUnlimitedRounds) {
    return true;
  }

  // Free tier: check round count
  const supabase = await createServerComponentClient();
  const { count, error } = await supabase
    .from("round")
    .select("*", { count: "exact", head: true })
    .eq("userId", userId);

  if (error || count === null) {
    return false;
  }

  return count < 25;
}

/**
 * Get remaining rounds for free tier users
 */
export async function getRemainingRounds(
  userId: string
): Promise<number | null> {
  const access = await getUserSubscription(userId);

  if (!access || access.plan !== "free") {
    return null; // Not free tier
  }

  const supabase = await createServerComponentClient();
  const { count, error } = await supabase
    .from("round")
    .select("*", { count: "exact", head: true })
    .eq("userId", userId);

  if (error || count === null) {
    return null;
  }

  return Math.max(0, 25 - count);
}
```

**Reason:** Reusable entitlement checking for server components and API routes

**File:** `utils/billing/access-control.ts` (create new file)

```typescript
import { getUserSubscription } from "./entitlements";
import type { Plan } from "@/types/billing";

/**
 * Feature flags based on plan
 */
export const PLAN_FEATURES = {
  free: {
    roundLogging: true,
    basicHandicap: true,
    scoreHistory: true,
    roundInsights: false,
    analytics: false,
    advancedCalculators: false,
    prioritySupport: false,
  },
  premium: {
    roundLogging: true,
    basicHandicap: true,
    scoreHistory: true,
    roundInsights: false,
    analytics: false,
    advancedCalculators: false,
    prioritySupport: false,
  },
  unlimited: {
    roundLogging: true,
    basicHandicap: true,
    scoreHistory: true,
    roundInsights: true,
    analytics: true,
    advancedCalculators: true,
    prioritySupport: true,
  },
} as const;

/**
 * Check if user has access to a specific feature
 */
export async function hasFeatureAccess(
  userId: string,
  feature: keyof typeof PLAN_FEATURES.unlimited
): Promise<boolean> {
  const access = await getUserSubscription(userId);

  if (!access) {
    return false;
  }

  return PLAN_FEATURES[access.plan][feature];
}
```

**Reason:** Feature gating logic for conditional UI rendering

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] Stripe library exports work
- [ ] Type definitions valid

#### Manual Verification:

- [ ] `lib/stripe.ts` initializes Stripe client
- [ ] Price mapping functions work correctly
- [ ] Billing types export properly
- [ ] Entitlement utilities type-check

---

## Phase 3: Stripe API Routes

### Overview

Create Next.js API routes for Stripe Checkout Session creation, Customer Portal access, and webhook event handling.

### Changes Required

#### 1. Checkout Session API Route

**File:** `app/api/stripe/checkout/route.ts` (create new file)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import { checkoutRequestSchema } from "@/types/billing";
import { createCheckoutSession, getOrCreateCustomer } from "@/lib/stripe";
import { env } from "@/env";
import { db } from "@/db";
import { billingCustomers } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function POST(request: NextRequest) {
  try {
    // 1. Get authenticated user
    const supabase = await createServerComponentClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse and validate request body
    const body = await request.json();
    const validationResult = checkoutRequestSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: "Invalid request", details: validationResult.error },
        { status: 400 }
      );
    }

    const { priceId, mode } = validationResult.data;

    // 3. Get or create billing customer
    const existingCustomer = await db
      .select()
      .from(billingCustomers)
      .where(eq(billingCustomers.userId, user.id))
      .limit(1);

    let stripeCustomerId: string;

    if (existingCustomer[0]) {
      stripeCustomerId = existingCustomer[0].stripeCustomerId;
    } else {
      // Create new Stripe customer
      stripeCustomerId = await getOrCreateCustomer(user.id, user.email!, null);

      // Store in database
      await db.insert(billingCustomers).values({
        userId: user.id,
        stripeCustomerId,
      });
    }

    // 4. Create Checkout Session
    const session = await createCheckoutSession({
      customerId: stripeCustomerId,
      priceId,
      mode,
      userId: user.id,
      successUrl: `${env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
      cancelUrl: `${env.NEXT_PUBLIC_SITE_URL}/onboarding`,
    });

    // 5. Return checkout URL
    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("Checkout session creation error:", error);
    return NextResponse.json(
      { error: "Failed to create checkout session" },
      { status: 500 }
    );
  }
}
```

**Reason:** Server-side Checkout Session creation with user metadata

#### 2. Customer Portal API Route

**File:** `app/api/stripe/portal/route.ts` (create new file)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import { createPortalSession } from "@/lib/stripe";
import { env } from "@/env";
import { db } from "@/db";
import { billingCustomers } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function POST(request: NextRequest) {
  try {
    // 1. Get authenticated user
    const supabase = await createServerComponentClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Get Stripe customer ID
    const customer = await db
      .select()
      .from(billingCustomers)
      .where(eq(billingCustomers.userId, user.id))
      .limit(1);

    if (!customer[0]) {
      return NextResponse.json(
        { error: "No billing customer found" },
        { status: 404 }
      );
    }

    // 3. Create Portal Session
    const session = await createPortalSession({
      customerId: customer[0].stripeCustomerId,
      returnUrl: `${env.NEXT_PUBLIC_SITE_URL}/billing`,
    });

    // 4. Return portal URL
    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("Portal session creation error:", error);
    return NextResponse.json(
      { error: "Failed to create portal session" },
      { status: 500 }
    );
  }
}
```

**Reason:** Server-side Portal Session creation for subscription management

#### 3. Stripe Webhook Handler

**File:** `app/api/stripe/webhook/route.ts` (create new file)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { headers } from "next/headers";
import Stripe from "stripe";
import { stripe, mapPriceToPlan } from "@/lib/stripe";
import { env } from "@/env";
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@/types/supabase";

// Initialize Supabase client with service role key (bypasses RLS)
const supabaseAdmin = createClient<Database>(
  env.NEXT_PUBLIC_SUPABASE_URL,
  env.SUPABASE_SERVICE_ROLE_KEY,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  }
);

/**
 * Log webhook event to billing.events table
 */
async function logEvent(
  type: string,
  payload: unknown,
  userId?: string | null
) {
  await supabaseAdmin.from("events").insert({
    user_id: userId ?? null,
    type,
    payload: JSON.stringify(payload),
  });
}

/**
 * Handle checkout.session.completed event
 */
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No user ID in checkout session metadata");
    return;
  }

  await logEvent("checkout.session.completed", session, userId);

  if (session.mode === "subscription") {
    // Subscription mode: fetch subscription details
    const subscriptionId = session.subscription as string;
    const subscription = await stripe.subscriptions.retrieve(subscriptionId);

    const priceId = subscription.items.data[0]?.price.id;
    if (!priceId) {
      console.error("No price ID in subscription");
      return;
    }

    const plan = mapPriceToPlan(priceId);
    if (!plan) {
      console.error("Unknown price ID:", priceId);
      return;
    }

    // Upsert subscription using RPC
    await supabaseAdmin.rpc("upsert_subscription", {
      p_user_id: userId,
      p_stripe_subscription_id: subscriptionId,
      p_plan: plan,
      p_status: subscription.status,
      p_current_period_end: new Date(
        subscription.current_period_end * 1000
      ).toISOString(),
      p_is_lifetime: false,
    });
  } else if (session.mode === "payment") {
    // One-time payment (lifetime)
    await supabaseAdmin.rpc("upsert_subscription", {
      p_user_id: userId,
      p_stripe_subscription_id: null,
      p_plan: "unlimited",
      p_status: "active",
      p_current_period_end: null,
      p_is_lifetime: true,
    });
  }
}

/**
 * Handle customer.subscription.* events
 */
async function handleSubscriptionUpdate(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No user ID in subscription metadata");
    return;
  }

  await logEvent("customer.subscription.updated", subscription, userId);

  const priceId = subscription.items.data[0]?.price.id;
  if (!priceId) {
    console.error("No price ID in subscription");
    return;
  }

  const plan = mapPriceToPlan(priceId);
  if (!plan) {
    console.error("Unknown price ID:", priceId);
    return;
  }

  await supabaseAdmin.rpc("upsert_subscription", {
    p_user_id: userId,
    p_stripe_subscription_id: subscription.id,
    p_plan: plan,
    p_status: subscription.status,
    p_current_period_end: new Date(
      subscription.current_period_end * 1000
    ).toISOString(),
    p_is_lifetime: false,
  });
}

/**
 * Handle customer.subscription.deleted event
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No user ID in subscription metadata");
    return;
  }

  await logEvent("customer.subscription.deleted", subscription, userId);

  const priceId = subscription.items.data[0]?.price.id;
  if (!priceId) {
    console.error("No price ID in subscription");
    return;
  }

  const plan = mapPriceToPlan(priceId);
  if (!plan) {
    console.error("Unknown price ID:", priceId);
    return;
  }

  await supabaseAdmin.rpc("upsert_subscription", {
    p_user_id: userId,
    p_stripe_subscription_id: subscription.id,
    p_plan: plan,
    p_status: "canceled",
    p_current_period_end: new Date(
      subscription.current_period_end * 1000
    ).toISOString(),
    p_is_lifetime: false,
  });
}

/**
 * Main webhook handler
 */
export async function POST(request: NextRequest) {
  const body = await request.text();
  const headersList = await headers();
  const signature = headersList.get("stripe-signature");

  if (!signature) {
    return NextResponse.json({ error: "No signature" }, { status: 400 });
  }

  let event: Stripe.Event;

  try {
    // Verify webhook signature
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      env.STRIPE_WEBHOOK_SECRET
    );
  } catch (error) {
    console.error("Webhook signature verification failed:", error);
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  try {
    // Handle events
    switch (event.type) {
      case "checkout.session.completed":
        await handleCheckoutCompleted(event.data.object);
        break;

      case "customer.subscription.created":
      case "customer.subscription.updated":
        await handleSubscriptionUpdate(event.data.object);
        break;

      case "customer.subscription.deleted":
        await handleSubscriptionDeleted(event.data.object);
        break;

      case "invoice.payment_succeeded":
      case "invoice.payment_failed":
        // Log but don't process (subscription updates handle these)
        await logEvent(event.type, event.data.object);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("Webhook handler error:", error);
    return NextResponse.json(
      { error: "Webhook handler failed" },
      { status: 500 }
    );
  }
}
```

**Reason:** Secure webhook handling with signature verification and idempotent updates

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] API routes respond to requests

#### Manual Verification:

- [ ] `/api/stripe/checkout` creates Checkout Session
- [ ] `/api/stripe/portal` creates Portal Session
- [ ] `/api/stripe/webhook` verifies signatures
- [ ] Webhook events logged to `billing.events`
- [ ] Subscription upserts work correctly

---

## Phase 4: Onboarding Flow

### Overview

Create forced onboarding page that requires plan selection before app access. Free tier creates entitlement immediately, paid tiers redirect to Stripe Checkout.

### Changes Required

#### 1. Onboarding Page (Server Component)

**File:** `app/onboarding/page.tsx` (create new file)

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import { getUserSubscription } from "@/utils/billing/entitlements";
import { PlanSelector } from "@/components/billing/plan-selector";

export default async function OnboardingPage() {
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Check if user already has a subscription
  const subscription = await getUserSubscription(user.id);

  if (subscription) {
    // User already has entitlement, redirect to dashboard
    redirect("/dashboard");
  }

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-4xl font-bold text-center mb-4">
          Welcome to Handicappin!
        </h1>
        <p className="text-lg text-center text-gray-600 mb-12">
          Choose a plan to get started with tracking your golf handicap
        </p>

        <PlanSelector userId={user.id} />
      </div>
    </div>
  );
}
```

**Reason:** Server-side entitlement check, forces plan selection

#### 2. Plan Selector Component

**File:** `components/billing/plan-selector.tsx` (create new file)

```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { PLAN_TO_PRICE_MAP } from "@/lib/stripe";
import { createFreeTierSubscription } from "@/app/onboarding/actions";

const PLANS = [
  {
    name: "Free",
    price: "$0",
    period: "forever",
    features: [
      "25 rounds total",
      "Basic handicap calculation",
      "Score history",
      "Round logging",
    ],
    action: "free",
  },
  {
    name: "Premium",
    price: "$19",
    period: "per year",
    features: [
      "Unlimited rounds",
      "Basic handicap calculation",
      "Score history",
      "Round logging",
    ],
    priceId: PLAN_TO_PRICE_MAP.premium,
    mode: "subscription" as const,
    popular: false,
  },
  {
    name: "Unlimited",
    price: "$29",
    period: "per year",
    features: [
      "Unlimited rounds",
      "Advanced handicap insights",
      "Performance analytics",
      "Trend charts",
      "Advanced calculators",
      "Priority support",
    ],
    priceId: PLAN_TO_PRICE_MAP.unlimited,
    mode: "subscription" as const,
    popular: true,
  },
  {
    name: "Unlimited Lifetime",
    price: "$149",
    period: "one-time",
    features: [
      "Everything in Unlimited",
      "Pay once, use forever",
      "No recurring charges",
      "Early access to new features",
    ],
    priceId: PLAN_TO_PRICE_MAP["unlimited-lifetime"],
    mode: "payment" as const,
    popular: false,
  },
];

interface PlanSelectorProps {
  userId: string;
}

export function PlanSelector({ userId }: PlanSelectorProps) {
  const router = useRouter();
  const [loading, setLoading] = useState<string | null>(null);

  async function handleFreeTier() {
    setLoading("free");
    try {
      await createFreeTierSubscription(userId);
      router.push("/dashboard");
    } catch (error) {
      console.error("Free tier creation error:", error);
      alert("Failed to create free tier subscription");
    } finally {
      setLoading(null);
    }
  }

  async function handlePaidPlan(
    priceId: string,
    mode: "subscription" | "payment"
  ) {
    setLoading(priceId);
    try {
      const response = await fetch("/api/stripe/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ priceId, mode }),
      });

      const data = await response.json();

      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error("No checkout URL returned");
      }
    } catch (error) {
      console.error("Checkout error:", error);
      alert("Failed to start checkout");
      setLoading(null);
    }
  }

  return (
    <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-6">
      {PLANS.map((plan) => (
        <Card
          key={plan.name}
          className={`p-6 relative ${
            plan.popular ? "border-blue-500 border-2" : ""
          }`}
        >
          {plan.popular && (
            <div className="absolute -top-3 left-1/2 transform -translate-x-1/2">
              <span className="bg-blue-500 text-white px-3 py-1 rounded-full text-sm font-semibold">
                Most Popular
              </span>
            </div>
          )}

          <h3 className="text-2xl font-bold mb-2">{plan.name}</h3>
          <div className="mb-4">
            <span className="text-3xl font-bold">{plan.price}</span>
            <span className="text-gray-600"> {plan.period}</span>
          </div>

          <ul className="space-y-2 mb-6">
            {plan.features.map((feature) => (
              <li key={feature} className="flex items-start">
                <span className="text-green-500 mr-2">✓</span>
                <span className="text-sm">{feature}</span>
              </li>
            ))}
          </ul>

          <Button
            onClick={() => {
              if (plan.action === "free") {
                handleFreeTier();
              } else if (plan.priceId && plan.mode) {
                handlePaidPlan(plan.priceId, plan.mode);
              }
            }}
            disabled={loading !== null}
            className="w-full"
            variant={plan.popular ? "default" : "outline"}
          >
            {loading === (plan.action === "free" ? "free" : plan.priceId)
              ? "Loading..."
              : plan.action === "free"
              ? "Start Free"
              : "Subscribe"}
          </Button>

          {plan.priceId && (
            <p className="text-xs text-center text-gray-500 mt-2">
              Have a promo code? Apply at checkout
            </p>
          )}
        </Card>
      ))}
    </div>
  );
}
```

**Reason:** Client component for plan selection with Stripe Checkout integration

#### 3. Free Tier Server Action

**File:** `app/onboarding/actions.ts` (create new file)

```typescript
"use server";

import { createServerComponentClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";

export async function createFreeTierSubscription(userId: string) {
  const supabase = await createServerComponentClient();

  // Verify user is authenticated
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user || user.id !== userId) {
    throw new Error("Unauthorized");
  }

  // Create free tier subscription in billing.subscriptions
  const { error } = await supabase.from("subscriptions").insert({
    user_id: userId,
    stripe_subscription_id: null,
    plan: "free",
    status: "active",
    current_period_end: null,
    is_lifetime: false,
  });

  if (error) {
    console.error("Free tier creation error:", error);
    throw new Error("Failed to create free tier subscription");
  }

  return { success: true };
}
```

**Reason:** Server action for creating free tier entitlement without Stripe

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Onboarding page displays 4 plans
- [ ] Free plan creates entitlement and redirects to dashboard
- [ ] Paid plans redirect to Stripe Checkout
- [ ] User with existing entitlement redirects to dashboard
- [ ] Unauthenticated user redirects to login

---

## Phase 5: Middleware Integration & Entitlement Checks

### Overview

Update middleware to enforce entitlement checks, redirect users to onboarding if missing subscription, and protect app routes.

### Changes Required

#### 1. Update Middleware Utility

**File:** `utils/supabase/middleware.ts`

**Changes:** Add entitlement check after auth check

```typescript
import { Database } from "@/types/supabase";
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";
import { jwtVerify } from "jose";
import { PasswordResetPayload } from "@/types/auth";

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const { pathname } = request.nextUrl;

  const publicPaths = [
    "/login",
    "/signup",
    "/calculators",
    "/about",
    "/api",
    "/verify-email",
    "/forgot-password",
    "/",
  ];

  const isPublic = publicPaths.some((path) => pathname.startsWith(path));

  // Password reset flow
  if (!user && pathname === "/update-password") {
    const resetToken = request.nextUrl.searchParams.get("token");
    if (!resetToken) {
      const url = request.nextUrl.clone();
      url.pathname = "/login";
      return NextResponse.redirect(url);
    }

    try {
      const secret = new TextEncoder().encode(process.env.RESET_TOKEN_SECRET);
      const { payload } = await jwtVerify<PasswordResetPayload>(
        resetToken,
        secret
      );

      if (payload.metadata.type === "password-reset") {
        const url = request.nextUrl.clone();
        url.searchParams.set("email", payload.email);
        return NextResponse.rewrite(url);
      }
    } catch (err) {
      console.error("Invalid reset token:", err);
      const url = request.nextUrl.clone();
      url.pathname = "/login";
      return NextResponse.redirect(url);
    }
  }

  // Auth check
  if (!user && !isPublic) {
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    return NextResponse.redirect(url);
  }

  // Redirect authenticated users away from login/signup
  if (
    user &&
    (pathname.startsWith("/login") || pathname.startsWith("/signup"))
  ) {
    const url = request.nextUrl.clone();
    url.pathname = "/";
    return NextResponse.redirect(url);
  }

  // ============================================
  // NEW: Entitlement check
  // ============================================
  if (
    user &&
    !isPublic &&
    pathname !== "/onboarding" &&
    pathname !== "/billing"
  ) {
    // Check if user has a subscription in billing.subscriptions
    const { data: subscription, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", user.id)
      .maybeSingle();

    // If no subscription exists, redirect to onboarding
    if (!subscription) {
      const url = request.nextUrl.clone();
      url.pathname = "/onboarding";
      return NextResponse.redirect(url);
    }

    // Optional: Check if subscription is active
    // For past_due or incomplete, you might want to redirect to billing page
    if (
      subscription.status === "past_due" ||
      subscription.status === "incomplete"
    ) {
      const url = request.nextUrl.clone();
      url.pathname = "/billing";
      url.searchParams.set("error", "subscription_issue");
      return NextResponse.redirect(url);
    }
  }

  return supabaseResponse;
}
```

**Reason:** Enforces entitlement before app access, redirects to onboarding if missing

#### 2. Update tRPC Context for Subscription Access

**File:** `server/api/trpc.ts`

**Changes:** Optionally add subscription to context (for convenience)

```typescript
import { initTRPC, TRPCError } from "@trpc/server";
import superjson from "superjson";
import { ZodError } from "zod";

import { createServerComponentClient } from "@/utils/supabase/server";
import { getUserSubscription } from "@/utils/billing/entitlements";

export const createTRPCContext = async (opts: { headers: Headers }) => {
  const supabase = await createServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Get subscription if user exists
  const subscription = user ? await getUserSubscription(user.id) : null;

  return {
    supabase,
    user,
    subscription,
    ...opts,
  };
};

const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

export const createCallerFactory = t.createCallerFactory;
export const createTRPCRouter = t.router;
export const publicProcedure = t.procedure;

export const authedProcedure = t.procedure.use(async function isAuthed(opts) {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" });
  }

  return opts.next({
    ctx: {
      user: ctx.user,
      subscription: ctx.subscription,
    },
  });
});

// NEW: Paid procedure (requires premium access)
export const paidProcedure = authedProcedure.use(async function isPaid(opts) {
  const { ctx } = opts;

  if (!ctx.subscription || !ctx.subscription.hasPremiumAccess) {
    throw new TRPCError({
      code: "FORBIDDEN",
      message: "This feature requires a premium subscription",
    });
  }

  return opts.next({
    ctx,
  });
});
```

**Reason:** Adds subscription context to tRPC, creates paid procedure for premium features

#### 3. Add Round Limit Check to Round Router

**File:** `server/api/routers/round.ts`

**Changes:** Add round limit check before submission

```typescript
import { z } from "zod";
import { createTRPCRouter, authedProcedure } from "@/server/api/trpc";
import { round, score, profile, teeInfo, course, hole } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { TRPCError } from "@trpc/server";

import { db } from "@/db";
import { Scorecard, scorecardSchema } from "@/types/scorecard";
import {
  calculateAdjustedPlayedScore,
  calculateCourseHandicap,
  calculateScoreDifferential,
  calculateAdjustedGrossScore,
} from "@/utils/calculations/handicap";
import { canAddRound, getUserSubscription } from "@/utils/billing/entitlements";

// ... existing helper functions ...

export const roundRouter = createTRPCRouter({
  // ... existing queries ...

  submitScorecard: authedProcedure
    .input(scorecardSchema)
    .mutation(async ({ ctx, input }) => {
      const { userId } = input;

      // ============================================
      // NEW: Check round limit for free tier users
      // ============================================
      const canAdd = await canAddRound(userId);

      if (!canAdd) {
        const subscription = await getUserSubscription(userId);

        if (subscription?.plan === "free") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message:
              "You've reached your 25 round limit. Please upgrade to continue tracking rounds.",
          });
        }

        throw new TRPCError({
          code: "FORBIDDEN",
          message:
            "Unable to add round. Please check your subscription status.",
        });
      }

      // ... rest of existing submitScorecard logic ...
      const {
        teePlayed,
        scores,
        notes,
        approvalStatus,
        course: coursePlayed,
        teeTime,
      } = input;

      // ... continue with existing implementation ...
    }),
});
```

**Reason:** Enforces 25 round limit for free tier users

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Middleware redirects users without subscription to onboarding
- [ ] Users with `past_due` status redirected to billing page
- [ ] Round submission blocked at 25 rounds for free tier
- [ ] Premium users can submit unlimited rounds
- [ ] tRPC `paidProcedure` blocks free tier users

---

## Phase 6: Billing Page & Success/Cancel Flows

### Overview

Create billing management page with subscription status display, Customer Portal access, and Checkout success/cancel handling.

### Changes Required

#### 1. Billing Page

**File:** `app/billing/page.tsx` (create new file)

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import {
  getUserSubscription,
  getRemainingRounds,
} from "@/utils/billing/entitlements";
import { BillingPortalButton } from "@/components/billing/portal-button";
import { UpgradePrompt } from "@/components/billing/upgrade-prompt";

export default async function BillingPage({
  searchParams,
}: {
  searchParams: Promise<{ session_id?: string; error?: string }>;
}) {
  const params = await searchParams;
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const subscription = await getUserSubscription(user.id);

  if (!subscription) {
    redirect("/onboarding");
  }

  const remainingRounds = await getRemainingRounds(user.id);

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-4xl font-bold mb-8">Billing & Subscription</h1>

        {params.session_id && (
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-6">
            ✓ Payment successful! Your subscription is now active.
          </div>
        )}

        {params.error === "subscription_issue" && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6">
            There's an issue with your subscription. Please update your payment
            method.
          </div>
        )}

        <div className="bg-white shadow rounded-lg p-6 mb-6">
          <h2 className="text-2xl font-semibold mb-4">Current Plan</h2>

          <div className="space-y-2">
            <p>
              <span className="font-semibold">Plan:</span>{" "}
              <span className="capitalize">{subscription.plan}</span>
              {subscription.isLifetime && " (Lifetime)"}
            </p>

            <p>
              <span className="font-semibold">Status:</span>{" "}
              <span className="capitalize">{subscription.status}</span>
            </p>

            {subscription.currentPeriodEnd && (
              <p>
                <span className="font-semibold">Renews:</span>{" "}
                {new Date(subscription.currentPeriodEnd).toLocaleDateString()}
              </p>
            )}

            {remainingRounds !== null && (
              <p>
                <span className="font-semibold">Rounds Remaining:</span>{" "}
                {remainingRounds} / 25
              </p>
            )}
          </div>

          {subscription.plan !== "free" && !subscription.isLifetime && (
            <div className="mt-6">
              <BillingPortalButton />
            </div>
          )}
        </div>

        {subscription.plan === "free" && (
          <UpgradePrompt remainingRounds={remainingRounds} />
        )}
      </div>
    </div>
  );
}
```

**Reason:** Displays subscription status and manages billing

#### 2. Billing Portal Button Component

**File:** `components/billing/portal-button.tsx` (create new file)

```typescript
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";

export function BillingPortalButton() {
  const [loading, setLoading] = useState(false);

  async function handlePortalAccess() {
    setLoading(true);
    try {
      const response = await fetch("/api/stripe/portal", {
        method: "POST",
      });

      const data = await response.json();

      if (data.url) {
        window.location.href = data.url;
      } else {
        throw new Error("No portal URL returned");
      }
    } catch (error) {
      console.error("Portal access error:", error);
      alert("Failed to access billing portal");
      setLoading(false);
    }
  }

  return (
    <Button onClick={handlePortalAccess} disabled={loading}>
      {loading ? "Loading..." : "Manage Subscription"}
    </Button>
  );
}
```

**Reason:** Client component for Customer Portal access

#### 3. Upgrade Prompt Component

**File:** `components/billing/upgrade-prompt.tsx` (create new file)

```typescript
"use client";

import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";

interface UpgradePromptProps {
  remainingRounds: number | null;
}

export function UpgradePrompt({ remainingRounds }: UpgradePromptProps) {
  return (
    <Card className="p-6 bg-gradient-to-r from-blue-50 to-indigo-50">
      <h3 className="text-xl font-semibold mb-2">Upgrade for More</h3>

      {remainingRounds !== null && remainingRounds <= 5 && (
        <p className="text-orange-600 font-semibold mb-4">
          ⚠️ Only {remainingRounds} rounds remaining!
        </p>
      )}

      <p className="mb-4">
        Upgrade to Premium or Unlimited to get unlimited rounds, advanced
        analytics, and more.
      </p>

      <Button onClick={() => (window.location.href = "/onboarding")}>
        View Plans
      </Button>
    </Card>
  );
}
```

**Reason:** Encourages free tier users to upgrade

#### 4. Billing Success Page

**File:** `app/billing/success/page.tsx` (create new file)

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";

export default async function BillingSuccessPage({
  searchParams,
}: {
  searchParams: Promise<{ session_id?: string }>;
}) {
  const params = await searchParams;
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Wait a moment for webhook to process (optional)
  await new Promise((resolve) => setTimeout(resolve, 2000));

  // Redirect to billing page with success message
  redirect(`/billing?session_id=${params.session_id}`);
}
```

**Reason:** Handles post-checkout redirect and waits for webhook processing

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Billing page displays subscription status
- [ ] Portal button redirects to Stripe Customer Portal
- [ ] Success page shows confirmation message
- [ ] Free tier users see upgrade prompt
- [ ] Remaining rounds displayed for free tier

---

## Phase 7: Navbar Integration & UI Improvements

### Overview

Add billing/upgrade links to navbar, display subscription status, and add conditional rendering based on plan.

### Changes Required

#### 1. Update Navbar

**File:** `components/layout/navbar.tsx`

**Changes:** Add billing link and subscription status indicator

```typescript
// ... existing imports ...
import { getUserSubscription } from "@/utils/billing/entitlements";
import { Badge } from "@/components/ui/badge";

export async function Navbar() {
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  const subscription = user ? await getUserSubscription(user.id) : null;

  return (
    <nav className="...">
      {/* ... existing nav items ... */}

      {user && subscription && (
        <div className="flex items-center gap-4">
          {/* Subscription badge */}
          <Badge
            variant={subscription.plan === "free" ? "secondary" : "default"}
          >
            {subscription.plan === "free" ? "Free" : subscription.plan}
            {subscription.isLifetime && " (Lifetime)"}
          </Badge>

          {/* Billing link */}
          <a href="/billing" className="text-sm hover:underline">
            Billing
          </a>

          {/* Upgrade button for free tier */}
          {subscription.plan === "free" && (
            <Button size="sm" asChild>
              <a href="/onboarding">Upgrade</a>
            </Button>
          )}
        </div>
      )}

      {/* ... existing auth buttons ... */}
    </nav>
  );
}
```

**Reason:** Makes billing accessible and encourages upgrades

### Success Criteria

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Navbar shows subscription badge
- [ ] Billing link visible for authenticated users
- [ ] Upgrade button shows for free tier users
- [ ] Badge displays correct plan and lifetime status

---

## Testing Strategy

### Local Development Testing with Stripe CLI

**Setup:**

```bash
# Install Stripe CLI
brew install stripe/stripe-cli/stripe

# Login
stripe login

# Forward webhooks to local endpoint
stripe listen --forward-to localhost:3000/api/stripe/webhook

# Copy webhook signing secret to .env.local
# STRIPE_WEBHOOK_SECRET=whsec_...
```

**Test Scenarios:**

#### 1. Free Plan Onboarding

- [ ] Sign up new user
- [ ] Verify email
- [ ] Login manually
- [ ] Redirected to `/onboarding`
- [ ] Select "Free" plan
- [ ] Entitlement created in `billing.subscriptions`
- [ ] Redirected to dashboard
- [ ] Add 25 rounds successfully
- [ ] 26th round blocked with upgrade prompt

#### 2. Premium Yearly Subscription

- [ ] New user completes onboarding
- [ ] Select "Premium" plan
- [ ] Redirected to Stripe Checkout
- [ ] Use test card: `4242 4242 4242 4242`
- [ ] Complete checkout
- [ ] Webhook received and processed
- [ ] Entitlement created with `plan='premium'`, `status='active'`
- [ ] Redirected to `/billing/success`
- [ ] Can add unlimited rounds
- [ ] Cannot access premium features (analytics, etc.)

#### 3. Promotion Code (100% off Premium)

- [ ] Create promo code in Stripe Dashboard
- [ ] Start Premium checkout
- [ ] Enter promo code at checkout
- [ ] Complete with $0 payment
- [ ] Webhook creates subscription with `plan='premium'`, `status='active'`
- [ ] Unlimited rounds granted
- [ ] Verify promotion code redemption count

#### 4. Customer Portal

- [ ] User with active subscription
- [ ] Navigate to `/billing`
- [ ] Click "Manage Subscription"
- [ ] Redirected to Stripe Customer Portal
- [ ] Cancel subscription
- [ ] Webhook updates `status='canceled'`
- [ ] Access maintained until period end
- [ ] After period end, downgraded to free

#### 5. Unlimited Lifetime Purchase

- [ ] New user onboarding
- [ ] Select "Unlimited Lifetime"
- [ ] Complete one-time payment
- [ ] Webhook creates entitlement with `is_lifetime=true`, `plan='unlimited'`
- [ ] All premium features unlocked
- [ ] Unlimited rounds
- [ ] No expiration date

#### 6. Webhook Idempotency

- [ ] Trigger same webhook event twice (using Stripe CLI)
- [ ] Verify no duplicate entitlements
- [ ] Verify `billing.events` logs both events
- [ ] Subscription status remains correct

### Edge Cases

#### 1. Past Due Subscription

- [ ] Simulate failed payment (test mode)
- [ ] Webhook updates `status='past_due'`
- [ ] Middleware redirects to `/billing` with error
- [ ] User prompted to update payment method

#### 2. Incomplete Subscription

- [ ] Start checkout but don't complete
- [ ] User has no entitlement
- [ ] Cannot access app (redirected to onboarding)

#### 3. Lifetime Purchase While Subscribed

- [ ] User has active yearly subscription
- [ ] Purchase lifetime plan
- [ ] Webhook sets `is_lifetime=true`
- [ ] Subscription remains active until period end
- [ ] After period, lifetime access continues

#### 4. Email Change

- [ ] User changes email in Supabase Auth
- [ ] Stripe customer still linked via `metadata.supabase_user_id`
- [ ] No breaking of entitlement linkage

### Automated Testing (Optional Future Enhancement)

```typescript
// tests/integration/billing.test.ts
import { describe, it, expect } from "vitest";
import { mapPriceToPlan } from "@/lib/stripe";

describe("Billing Integration", () => {
  it("maps price IDs to plans correctly", () => {
    expect(mapPriceToPlan(process.env.STRIPE_PREMIUM_PRICE_ID!)).toBe(
      "premium"
    );
    expect(mapPriceToPlan(process.env.STRIPE_UNLIMITED_PRICE_ID!)).toBe(
      "unlimited"
    );
    expect(mapPriceToPlan("price_unknown")).toBeNull();
  });

  // Add more tests for entitlement checks, etc.
});
```

---

## Performance Considerations

### Database Queries

- Subscription checks in middleware are cached per request
- RLS policies ensure efficient filtering
- Indexes on `user_id` and `stripe_customer_id` for fast lookups

### Webhook Processing

- Idempotent upserts prevent duplicate processing
- Events logged asynchronously to `billing.events`
- Stripe retries failed webhooks automatically

### Client-Side Performance

- Onboarding page uses server components (no client-side fetching)
- Plan selector only client component (small bundle)
- Stripe Checkout hosted (no additional bundle size)

---

## Migration Notes

### Database Migration Sequence

1. Update `drizzle.config.ts` to include `billing` schema
2. Update `db/schema.ts` with billing tables
3. Run `npx drizzle-kit generate` to create migration
4. Run `npx supabase db reset` to apply migration locally
5. Manually run `manual_post_billing_setup.sql` to create RPC function
6. Verify tables and function exist
7. Push to production: `npx supabase db push` (after testing)

### Environment Variable Setup

**Local (.env.local):**

1. Add Stripe test keys from Stripe Dashboard
2. Create test products/prices in Stripe
3. Add price IDs to environment variables
4. Set webhook secret from Stripe CLI

**Production:**

1. Switch to live Stripe keys
2. Create live products/prices
3. Update price IDs in environment
4. Configure live webhook endpoint in Stripe Dashboard
5. Update `NEXT_PUBLIC_SITE_URL` to production URL

### Stripe Dashboard Setup

**Products & Prices:**

1. Create "Premium" product (recurring, yearly, $19)
2. Create "Unlimited" product (recurring, yearly, $29)
3. Create "Unlimited Lifetime" product (one-time, $149)
4. Copy price IDs to environment variables

**Promotion Code:**

1. Navigate to Stripe Dashboard → Products → Coupons
2. Create new coupon: 100% off, applies to Premium price
3. Duration: Forever
4. Max redemptions: 100
5. Create promotion code: e.g., "PREMIUM100"

**Webhook:**

1. Developers → Webhooks → Add endpoint
2. Endpoint URL: `https://your-domain.com/api/stripe/webhook`
3. Events: `checkout.session.completed`, `customer.subscription.*`, `invoice.payment_*`
4. Copy signing secret to `STRIPE_WEBHOOK_SECRET`

**Customer Portal:**

1. Settings → Customer Portal
2. Enable subscription cancellation
3. Enable payment method updates
4. Set business information (name, support email)

---

## References

- **Original Ticket:** `.cursor/tickets/0002-stripe-checkout-billing-entitlements-system.md`
- **Alternative Approach:** `.cursor/tickets/0001-stripe-subscription-and-monetization-system.md`
- **Stripe Documentation:** https://stripe.com/docs/billing/subscriptions/overview
- **Supabase RLS:** https://supabase.com/docs/guides/auth/row-level-security
- **Drizzle Migrations:** https://orm.drizzle.team/kit-docs/overview

---

## Completion Checklist

### Phase 1: Database & Environment

- [ ] Updated `drizzle.config.ts`
- [ ] Added billing schema to `db/schema.ts`
- [ ] Created RPC function in post-migration SQL
- [ ] Updated `env.js` with Stripe variables
- [ ] Generated migration with Drizzle
- [ ] Reset local database successfully
- [ ] Verified tables and RLS policies exist

### Phase 2: Stripe Library & Types

- [ ] Installed Stripe dependencies
- [ ] Created `lib/stripe.ts`
- [ ] Created `types/billing.ts`
- [ ] Created `utils/billing/entitlements.ts`
- [ ] Created `utils/billing/access-control.ts`

### Phase 3: API Routes

- [ ] Created `/api/stripe/checkout/route.ts`
- [ ] Created `/api/stripe/portal/route.ts`
- [ ] Created `/api/stripe/webhook/route.ts`
- [ ] Tested checkout session creation
- [ ] Tested webhook signature verification

### Phase 4: Onboarding Flow

- [ ] Created `/app/onboarding/page.tsx`
- [ ] Created `components/billing/plan-selector.tsx`
- [ ] Created `app/onboarding/actions.ts`
- [ ] Tested free tier creation
- [ ] Tested paid plan redirect

### Phase 5: Middleware & Access Control

- [ ] Updated `utils/supabase/middleware.ts`
- [ ] Updated `server/api/trpc.ts`
- [ ] Updated `server/api/routers/round.ts`
- [ ] Tested entitlement redirects
- [ ] Tested round limit enforcement

### Phase 6: Billing Page

- [ ] Created `/app/billing/page.tsx`
- [ ] Created `components/billing/portal-button.tsx`
- [ ] Created `components/billing/upgrade-prompt.tsx`
- [ ] Created `/app/billing/success/page.tsx`
- [ ] Tested billing page display
- [ ] Tested portal access

### Phase 7: UI Integration

- [ ] Updated `components/layout/navbar.tsx`
- [ ] Tested subscription badge display
- [ ] Tested upgrade button for free tier

### Testing

- [ ] All local test scenarios passed
- [ ] Stripe CLI webhooks working
- [ ] Promotion code tested
- [ ] Edge cases handled
- [ ] Production webhook configured
- [ ] Live payment tested and refunded

### Documentation

- [ ] Updated `.env.example`
- [ ] Stripe Dashboard configured
- [ ] Team documentation updated
- [ ] Implementation plan marked complete
