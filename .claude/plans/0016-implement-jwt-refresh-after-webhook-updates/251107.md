# JWT Refresh After Webhook Updates - Implementation Plan

## Overview

Implement real-time JWT refresh for users actively using the app when Stripe webhooks update their billing data. This eliminates the 30-60 minute security window where users retain stale JWT claims after subscription changes, while providing immediate access after purchase.

**Key Insight:** Users who are offline during billing changes don't need this feature - they get fresh JWTs on next login. This solution is specifically for active users with valid sessions.

## Current State Analysis

### What Works Today:

**Webhook Flow:**
- All 8 webhook handlers correctly update profile table (`app/api/stripe/webhook/route.ts`)
- `billing_version` is incremented on every update (lines 341, 463, 512, 568, 700, 812, 1046, 1098)
- JWT hook reads from profile and injects billing claims (`supabase/migrations/20251025154500_fix_jwt_hook_null_handling.sql`)
- Middleware uses JWT claims for authorization (`utils/supabase/middleware.ts:60-84`)

**Billing Success Page Polling:**
- `/billing/success` polls `refreshSession()` every 2 seconds for 16 seconds (lines 46-86)
- Handles typical webhook latency (2-5 seconds) reasonably well
- Falls back to redirect if webhook delayed > 16 seconds

### The Gap:

**Security Risk (High Priority):**
- User with active session at 10:00 AM
- Subscription expires/cancels ‚Üí webhook fires ‚Üí DB updated
- User's JWT still has old claims until natural refresh (~30-60 minutes)
- **Result:** 30-60 minute window of unauthorized premium access

**Edge Case (Medium Priority):**
- Webhook delayed > 16 seconds on checkout
- Polling gives up, user redirected to dashboard with old JWT
- Middleware sees `plan = 'free'`, redirects to `/upgrade`
- **Result:** User sees upgrade page despite just paying

### Key Discoveries:

**From Research:**
- Supabase Realtime is enabled (`supabase/config.toml:33-34`)
- NO existing Realtime subscriptions in codebase (clean slate)
- Profile table NOT yet in `supabase_realtime` publication
- `@supabase/supabase-js: ^2.56.0` supports Realtime
- Middleware manually decodes JWT to get custom claims (session.user.app_metadata doesn't include custom claims)
- `billing_version` field exists in JWT but not currently used for staleness detection

## Desired End State

### User Experience After Implementation:

**Immediate Access (Purchase Flow):**
1. User completes checkout ‚Üí redirected to `/billing/success`
2. Webhook arrives (2-5 seconds typical)
3. Profile updated ‚Üí Realtime notification fired
4. `<BillingSync>` component receives update ‚Üí calls `refreshSession()`
5. New JWT obtained with premium claims
6. User redirected to dashboard with premium access
7. **Total time: < 5 seconds** (vs 0-16 seconds currently)

**Immediate Revocation (Security Flow):**
1. User browsing dashboard at 10:00 AM
2. Subscription expires ‚Üí webhook fires ‚Üí profile updated
3. Realtime notification ‚Üí JWT refresh triggered
4. Next middleware check (on navigation) sees revoked access
5. User redirected to `/upgrade`
6. **Total time: < 1 second** (vs 30-60 minutes currently)

**Multi-Tab/Device Support:**
- User has 3 tabs open ‚Üí all receive Realtime notification
- All tabs refresh JWT simultaneously
- Consistent state across all sessions

### How to Verify:

**Automated:**
- `pnpm build` passes (TypeScript compilation)
- `pnpm lint` passes (no ESLint errors)
- Migration applies cleanly (`supabase db reset`)

**Manual:**
1. Trigger `checkout.session.completed` webhook
2. Watch browser console for: `üîÑ Billing update detected, refreshing JWT...`
3. Verify JWT refresh happens in < 1 second
4. Confirm new billing claims in JWT payload
5. Verify premium access granted immediately

## What We're NOT Doing

**Out of Scope:**
- Offline sync/retry mechanism (eventual consistency on next login is acceptable)
- Custom polling fallback for browsers without WebSocket support (Realtime handles reconnection)
- Admin dashboard for monitoring JWT refresh rates (can be added later)
- Removing existing `/billing/success` polling (keep as defense-in-depth)
- Background refresh intervals (only refresh on actual changes)
- Client-side billing_version staleness detection (not needed with Realtime)
- Email notifications when JWT refresh fails (log only)

## Implementation Approach

**Strategy:** Use Supabase Realtime PostgreSQL changes subscription

**Why Realtime?**
- Native Supabase feature (already enabled)
- < 1 second latency (vs 5-10 seconds for polling)
- Leverages existing `billing_version` increment
- Single WebSocket connection (efficient)
- Automatic reconnection and error handling
- ~50 lines of code + 1 migration

**Architecture:**
```
Stripe Webhook ‚Üí Update Profile ‚Üí Increment billing_version
                                         ‚Üì
                          Supabase Realtime Publication
                                         ‚Üì
                          WebSocket Notification
                                         ‚Üì
                      <BillingSync> Component (all tabs)
                                         ‚Üì
                    supabase.auth.refreshSession()
                                         ‚Üì
                          New JWT with Fresh Claims
```

**Key Design Decisions:**
1. **Listen to `billing_version` changes only** - Ignore non-billing profile updates (name, handicap, etc.)
2. **Mount in root layout** - Global component, only renders for authenticated users
3. **No UI** - Invisible background sync component
4. **Graceful degradation** - Log errors but don't block user experience
5. **Keep existing polling** - Defense-in-depth on `/billing/success` page

---

## Phase 1: Enable Supabase Realtime for Profile Table

### Overview

Add the profile table to Supabase Realtime publication and configure replica identity to receive both old and new values in change notifications.

### Changes Required:

#### 1. Database Migration

**File:** `supabase/migrations/20251107000000_enable_profile_realtime.sql` (new file)

```sql
-- Enable Realtime for profile table
-- This allows clients to subscribe to profile table changes via WebSocket

-- Add profile table to the Realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE profile;

-- Set replica identity to FULL to get both old and new values in change events
-- This is necessary to detect billing_version changes (compare old vs new)
ALTER TABLE profile REPLICA IDENTITY FULL;

-- Note: No RLS changes needed - Realtime subscriptions already respect RLS
-- Users can only subscribe to their own profile due to existing RLS policies
```

**Why REPLICA IDENTITY FULL?**
- Sends both `payload.old` and `payload.new` in change notifications
- Allows us to compare `old.billing_version` vs `new.billing_version`
- Only triggers refresh if billing_version actually changed (not on unrelated profile updates)

### Success Criteria:

#### Automated Verification:
- [x] Migration applies without errors: `supabase db reset`
- [x] Profile table appears in Realtime publication: `SELECT * FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'profile';`
- [x] Replica identity is FULL: `SELECT relreplident FROM pg_class WHERE relname = 'profile';` (should return 'f')

#### Manual Verification:
- [ ] No RLS errors when subscribing to profile changes as authenticated user
- [ ] Webhook updates trigger Realtime notifications in browser console (test in Phase 2)

---

## Phase 2: Create BillingSync Component

### Overview

Create a client-side React component that subscribes to profile table changes via Supabase Realtime and triggers JWT refresh when `billing_version` changes.

### Changes Required:

#### 1. BillingSync Component

**File:** `components/billing-sync.tsx` (new file)

```typescript
"use client";

import { useEffect } from "react";
import { createClientComponentClient } from "@/utils/supabase/client";
import { useRouter } from "next/navigation";

interface BillingSyncProps {
  userId: string;
}

/**
 * Background component that listens for billing changes via Supabase Realtime
 * and triggers JWT refresh when billing_version increments.
 *
 * Mounted in root layout for all authenticated users.
 * No UI - purely functional.
 */
export function BillingSync({ userId }: BillingSyncProps) {
  const supabase = createClientComponentClient();
  const router = useRouter();

  useEffect(() => {
    console.log(`üîÑ BillingSync mounted for user ${userId}`);

    // Subscribe to profile changes for this user
    const channel = supabase
      .channel(`billing-changes-${userId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "profile",
          filter: `id=eq.${userId}`,
        },
        async (payload) => {
          // Only refresh if billing_version changed (ignore other profile updates)
          const newBillingVersion = payload.new?.billing_version;
          const oldBillingVersion = payload.old?.billing_version;

          if (
            newBillingVersion !== undefined &&
            oldBillingVersion !== undefined &&
            newBillingVersion !== oldBillingVersion
          ) {
            console.log(
              "üîÑ Billing update detected, refreshing JWT...",
              {
                old: oldBillingVersion,
                new: newBillingVersion,
                plan: payload.new?.plan_selected,
                status: payload.new?.subscription_status,
              }
            );

            try {
              // Force JWT refresh to get new billing claims
              const { data, error } = await supabase.auth.refreshSession();

              if (error) {
                console.error("‚ùå JWT refresh failed:", error);
                return;
              }

              if (data.session) {
                console.log("‚úÖ JWT refreshed with new billing data");

                // Refresh server components to reflect new JWT claims
                router.refresh();
              }
            } catch (err) {
              console.error("‚ùå Error during JWT refresh:", err);
            }
          }
        }
      )
      .subscribe((status) => {
        if (status === "SUBSCRIBED") {
          console.log(`‚úÖ Subscribed to billing updates for user ${userId}`);
        } else if (status === "CHANNEL_ERROR") {
          console.error(`‚ùå Failed to subscribe to billing updates for user ${userId}`);
        }
      });

    // Cleanup on unmount
    return () => {
      console.log(`üîÑ BillingSync unmounting for user ${userId}`);
      supabase.removeChannel(channel);
    };
  }, [userId, supabase, router]);

  // No UI - this component is invisible
  return null;
}
```

**Key Implementation Details:**
- **Unique channel per user:** `billing-changes-${userId}` prevents conflicts across tabs
- **Filter by user ID:** `filter: \`id=eq.${userId}\`` - only receive own profile updates (RLS redundancy)
- **Version comparison:** Only refresh if `billing_version` changed (ignore handicap updates, etc.)
- **Error handling:** Log but don't throw - degraded experience is better than broken app
- **Cleanup:** Unsubscribe on unmount to prevent memory leaks

#### 2. Root Layout Integration

**File:** `app/layout.tsx`

**Changes:** Add BillingSync component for authenticated users

```typescript
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { TRPCReactProvider } from "@/trpc/react";
import { Toaster } from "@/components/ui/toaster";
import { ThemeProvider } from "@/components/theme-provider";
import { Navbar } from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";
import { Analytics } from "@vercel/analytics/next";
import { BillingSync } from "@/components/billing-sync"; // NEW
import { createServerComponentClient } from "@/utils/supabase/server"; // NEW

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Handicappin'",
  description: "Golf made easy",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // NEW: Get authenticated user for BillingSync
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <div className="flex flex-col min-h-screen">
          <TRPCReactProvider>
            <ThemeProvider
              attribute="class"
              defaultTheme="system"
              enableSystem
              disableTransitionOnChange
            >
              {/* NEW: Mount BillingSync for authenticated users only */}
              {user && <BillingSync userId={user.id} />}

              <Navbar />
              <section className="pt-16 grow bg-background">{children}</section>
              <Footer />
              <Toaster />
            </ThemeProvider>
          </TRPCReactProvider>
        </div>
        <Analytics />
      </body>
    </html>
  );
}
```

**Why in Root Layout?**
- Mounted once per page, not per component
- Available on all pages (dashboard, calculators, settings)
- Automatically unmounts on logout (user becomes null)
- Works across all routes without repetition

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No ESLint errors: `pnpm lint`
- [x] Component exports correctly: `import { BillingSync } from "@/components/billing-sync"`
- [ ] Layout renders without errors in dev mode: `pnpm dev`

#### Manual Verification:
- [ ] Component mounts on login (check console for "BillingSync mounted")
- [ ] Realtime subscription succeeds (check console for "Subscribed to billing updates")
- [ ] Component unmounts on logout (check console for "BillingSync unmounting")
- [ ] No memory leaks when navigating between pages (check browser DevTools)

---

## Phase 3: Integration Testing

### Overview

Test the complete flow end-to-end to verify JWT refresh happens automatically within 1 second of webhook updates.

### Manual Testing Steps:

#### Test 1: Subscription Purchase (Immediate Access)

**Setup:**
```bash
# Terminal 1: Start dev server
pnpm dev

# Terminal 2: Forward Stripe webhooks to localhost
stripe listen --forward-to localhost:3000/api/stripe/webhook
```

**Steps:**
1. Open browser to `http://localhost:3000/login`
2. Login as test user
3. Open browser DevTools console
4. Navigate to `/onboarding` and select "Premium" plan
5. Complete Stripe checkout with test card `4242 4242 4242 4242`
6. Observe `/billing/success` page console logs

**Expected Console Output:**
```
üîÑ BillingSync mounted for user abc-123-def
‚úÖ Subscribed to billing updates for user abc-123-def
üîÑ Waiting for webhook to update plan...
‚è≥ Polling for plan update (attempt 1/8)...
üîÑ Billing update detected, refreshing JWT... { old: 1, new: 2, plan: 'premium', status: 'active' }
‚úÖ JWT refreshed with new billing data
‚úÖ Plan updated successfully to 'premium'!
üöÄ Redirecting to dashboard...
```

**Verification:**
- [ ] "Billing update detected" appears in < 5 seconds
- [ ] JWT refresh succeeds
- [ ] User redirected to dashboard with premium access
- [ ] No "Upgrade to Premium" redirect

#### Test 2: Subscription Cancellation (Immediate Revocation)

**Steps:**
1. User logged in with premium subscription
2. Open dashboard page
3. Open browser DevTools console
4. In Stripe Dashboard, cancel the subscription immediately (don't wait for period end)
5. Trigger `customer.subscription.deleted` webhook (or wait ~10 seconds for Stripe to send)

**Expected Console Output:**
```
üîÑ Billing update detected, refreshing JWT... { old: 5, new: 6, plan: 'free', status: 'canceled' }
‚úÖ JWT refreshed with new billing data
```

**Verification:**
- [ ] "Billing update detected" appears in < 1 second
- [ ] JWT refresh succeeds
- [ ] On next navigation, middleware redirects to `/upgrade`
- [ ] User loses premium access immediately

#### Test 3: Invoice Payment Failure (Status Update)

**Steps:**
1. User logged in with active subscription
2. Simulate failed payment by triggering webhook manually:
```bash
stripe trigger invoice.payment_failed
```

**Expected Console Output:**
```
üîÑ Billing update detected, refreshing JWT... { old: 3, new: 4, status: 'past_due' }
‚úÖ JWT refreshed with new billing data
```

**Verification:**
- [ ] "Billing update detected" appears
- [ ] JWT refresh succeeds
- [ ] `subscription_status` updated to `past_due` in JWT
- [ ] Middleware handles `past_due` status appropriately (see `middleware.ts:196-203`)

#### Test 4: Multi-Tab Sync

**Steps:**
1. Open 3 browser tabs with same authenticated user
2. All tabs on different pages (dashboard, calculators, settings)
3. Trigger subscription change webhook

**Verification:**
- [ ] All 3 tabs receive Realtime notification (check each console)
- [ ] All 3 tabs refresh JWT simultaneously
- [ ] All 3 tabs show consistent state after refresh

#### Test 5: Webhook Delayed > 16 Seconds

**Steps:**
1. Complete checkout
2. Manually delay webhook processing (pause Stripe CLI)
3. Wait for `/billing/success` polling to timeout (16 seconds)
4. Resume webhook processing

**Verification:**
- [ ] Polling times out, redirects to dashboard
- [ ] Middleware redirects to `/upgrade` (old JWT)
- [ ] Webhook eventually arrives
- [ ] Realtime notification triggers JWT refresh
- [ ] User can navigate to dashboard after refresh

#### Test 6: Non-Billing Profile Update (Should NOT Trigger Refresh)

**Steps:**
1. User logged in
2. Update user's handicap index via TRPC
3. Watch console

**Verification:**
- [ ] Realtime notification received
- [ ] `billing_version` unchanged (old === new)
- [ ] No JWT refresh triggered
- [ ] Console shows no "Billing update detected" message

### Success Criteria:

#### Automated Verification:
- [ ] All manual tests pass
- [ ] No console errors during testing
- [ ] No memory leaks (check Chrome DevTools Memory profiler)

#### Manual Verification:
- [ ] JWT refresh latency < 1 second (measured from webhook log to console log)
- [ ] Realtime subscription stays connected during long sessions (> 1 hour)
- [ ] Automatic reconnection works after network interruption (disable/enable WiFi)

---

## Testing Strategy

### Unit Tests

**Not Required** - This is integration-level functionality (Supabase Realtime + Auth)

### Integration Tests

**Future Enhancement** (not in this ticket):
```typescript
// Example test (for reference, not implemented now)
test('should refresh JWT after webhook updates billing', async () => {
  // 1. Login as test user
  const user = await loginTestUser();

  // 2. Simulate webhook updating profile
  await db.update(profile).set({
    planSelected: 'premium',
    billingVersion: sql`billing_version + 1`,
  }).where(eq(profile.id, user.id));

  // 3. Wait for Realtime notification
  await waitFor(() => {
    expect(mockRouter.refresh).toHaveBeenCalled();
  });

  // 4. Verify JWT has new billing data
  const { data: { session } } = await supabase.auth.getSession();
  expect(session?.user.app_metadata.billing.plan).toBe('premium');
});
```

### Manual Testing

See Phase 3 for comprehensive manual test suite.

## Performance Considerations

### Realtime Connection:
- **Single WebSocket per client** - Not per-table or per-subscription
- **Minimal bandwidth** - Only transmits on actual changes (not heartbeats)
- **Battery friendly** - No polling intervals, just passive WebSocket listener

### JWT Refresh:
- **Lightweight operation** - ~100ms typical latency
- **Only on changes** - Not on every profile update, only `billing_version` changes
- **Automatic throttling** - React `useEffect` cleanup prevents duplicate refreshes

### Middleware Impact:
- **No change** - Still JWT-only authorization (< 10ms)
- **No database queries** - All billing info in JWT claims
- **Scales with Supabase** - Realtime infrastructure handles load

## Migration Notes

### Rollback Plan:

If Realtime causes issues, disable by:
1. Remove `<BillingSync>` from `app/layout.tsx`
2. Revert migration: `supabase db reset` and delete migration file
3. System falls back to existing `/billing/success` polling + eventual consistency

### Backward Compatibility:

- **No breaking changes** - Existing polling still works
- **Graceful degradation** - If Realtime fails, polling catches updates on `/billing/success`
- **Optional feature** - Removing component doesn't break core functionality

### Data Migration:

**Not Required** - No schema changes to existing data, only adding table to publication

## References

- **Original Ticket:** `.claude/tickets/0016-implement-jwt-refresh-after-webhook-updates.md`
- **Webhook Handler:** `app/api/stripe/webhook/route.ts` (lines 341, 463, 512, 568, 700, 812, 1046, 1098)
- **JWT Hook:** `supabase/migrations/20251025154500_fix_jwt_hook_null_handling.sql`
- **Middleware:** `utils/supabase/middleware.ts:60-84`
- **Billing Success Polling:** `app/billing/success/page.tsx:46-86`
- **Supabase Config:** `supabase/config.toml:33-34`
- **Profile Schema:** `db/schema.ts:26-89`

## Risk Assessment

**Low Risk:**
- No schema changes to critical tables
- No changes to webhook handlers (already working)
- No changes to middleware authorization logic
- New component has no side effects if disabled
- Supabase Realtime is production-ready, battle-tested

**Mitigation:**
- Keep existing `/billing/success` polling as backup
- Extensive manual testing before production deploy
- Monitor logs for Realtime connection errors
- Easy rollback (remove one component)

## Success Metrics

**After Deployment:**
- Time to premium access after purchase: < 5 seconds (vs 0-16 seconds)
- Time to revocation after cancellation: < 1 second (vs 30-60 minutes)
- Realtime connection uptime: > 99.9%
- JWT refresh success rate: > 99.5%
- No increase in middleware latency (should stay < 10ms)

**How to Measure:**
- Browser console timestamps (manual testing)
- Webhook event logs ‚Üí Realtime notification ‚Üí JWT refresh
- Production monitoring (Vercel Analytics, Sentry)
