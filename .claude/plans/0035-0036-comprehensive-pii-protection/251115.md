# Comprehensive PII Protection & Sentry Security (Tickets #0035 + #0036)

## Overview

Fix active PII leaks in Sentry and logging, then enhance with HMAC-based pseudonymization for defense-in-depth. This plan combines two related security tickets:
- **Ticket #0036**: Sentry PII Cleanup (URGENT - active leak)
- **Ticket #0035**: HMAC Enhancement (IMPORTANT - defense-in-depth)

## Current State Analysis

### Critical Issues (URGENT)

1. **Sentry Config Leaking PII** (`sentry.server.config.ts:18`)
   ```typescript
   sendDefaultPii: true,  // ‚ùå Sends IP addresses, emails, etc.
   ```

2. **Non-Recursive `redactObject()` Missing Nested Data** (`lib/logging.ts:115`)
   ```typescript
   export function redactObject<T>(obj: T): Record<string, any> {
     const redacted: Record<string, any> = { ...obj };  // ‚ùå Shallow copy
     // Only redacts top-level fields
   }
   ```

3. **Reconciliation Alerts Not Redacting** (`lib/reconciliation/stripe-reconciliation.ts:298`)
   ```typescript
   console.error("üö® CRITICAL: Billing drift", {
     critical_issues: criticalIssues,  // ‚ùå Raw userIds exposed
   });
   ```

4. **Admin Alerts Sending Raw Stripe IDs to Sentry** (`lib/admin-alerts.ts:63-65`)
   ```typescript
   stripe: {
     session_id: failure.sessionId || 'N/A',      // ‚ùå PII
     customer_id: failure.customerId || 'N/A',    // ‚ùå PII
     subscription_id: failure.subscriptionId,     // ‚ùå PII
   }
   ```

### Secondary Issues (IMPORTANT)

5. **Weak Pseudonymization** (`lib/logging.ts:19-24`)
   - Simple truncation not cryptographically secure
   - Vulnerable to brute force matching if attacker has database access
   - Only 8 hex chars = 32 bits entropy (low collision resistance)

## Desired End State

After implementation:
- ‚úÖ Sentry configured to never send PII
- ‚úÖ All nested objects/arrays properly redacted
- ‚úÖ Reconciliation alerts redact userIds before logging
- ‚úÖ Admin alerts redact all Stripe IDs before Sentry
- ‚úÖ HMAC-based pseudonymization with 48 bits entropy
- ‚úÖ Centralized Sentry utilities for PII-safe error capture
- ‚úÖ Source maps uploaded for readable stack traces

### Verification

**Automated:**
- `pnpm test` - All unit tests pass
- `pnpm build` - Type checking passes
- `pnpm lint` - No linting errors

**Manual:**
- Trigger webhook error ‚Üí Check Sentry ‚Üí Verify no raw Stripe IDs
- Check console logs ‚Üí Verify nested objects redacted
- Verify `user_` format changed from 8 chars to 12 chars (after HMAC phase)

## What We're NOT Doing

- Retroactive re-redaction of old logs (out of scope)
- Session replay in Sentry (optional feature for later)
- Custom Sentry alerting (use Sentry UI)
- Encryption of logs at rest (infrastructure concern)
- Client-side PII redaction (server-only)
- Key rotation automation (manual process acceptable)

## Implementation Approach

**Three-phase approach:**
1. **Phase 1 (URGENT)**: Fix active Sentry PII leaks + recursive redaction
2. **Phase 2 (IMPORTANT)**: Add HMAC for defense-in-depth
3. **Phase 3 (INFRASTRUCTURE)**: Source maps, performance monitoring, tests

Each phase is independently deployable and testable.

---

## Phase 1: Fix Active PII Leaks (URGENT)

### Overview

Stop actively leaking PII to Sentry and fix non-recursive redaction that's letting userIds slip through in nested objects.

### Changes Required

#### 1. Fix Sentry Configuration

**File**: `sentry.server.config.ts`

**Changes**: Disable default PII, add beforeSend filter

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://9a6fb68c482da78fb51302d8388950f1@o4510365767303168.ingest.de.sentry.io/4510365768613968",

  // Define how likely traces are sampled
  tracesSampleRate: 1,

  // Enable logs to be sent to Sentry
  enableLogs: true,

  // ‚úÖ CHANGED: Disable automatic PII sending
  sendDefaultPii: false,

  // ‚úÖ NEW: Filter out PII before sending to Sentry
  beforeSend(event) {
    // Remove user IP addresses
    if (event.user) {
      delete event.user.ip_address;
    }

    // Remove sensitive headers
    if (event.request?.headers) {
      delete event.request.headers['Authorization'];
      delete event.request.headers['Cookie'];
      delete event.request.headers['X-Forwarded-For'];
    }

    return event;
  },

  // ‚úÖ NEW: Ignore known non-critical errors
  ignoreErrors: [
    'ResizeObserver loop limit exceeded',
    'Non-Error promise rejection captured',
  ],
});
```

**File**: `sentry.edge.config.ts` (if exists)

**Changes**: Same as server config

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://9a6fb68c482da78fb51302d8388950f1@o4510365767303168.ingest.de.sentry.io/4510365768613968",
  tracesSampleRate: 1,
  sendDefaultPii: false,  // ‚úÖ CHANGED

  beforeSend(event) {
    if (event.user) delete event.user.ip_address;
    if (event.request?.headers) {
      delete event.request.headers['Authorization'];
      delete event.request.headers['Cookie'];
      delete event.request.headers['X-Forwarded-For'];
    }
    return event;
  },
});
```

#### 2. Make `redactObject()` Recursive

**File**: `lib/logging.ts`

**Changes**: Add recursive handling for nested objects and arrays

```typescript
/**
 * Recursively redact PII from nested objects and arrays
 *
 * Handles:
 * - Nested objects (any depth)
 * - Arrays of objects
 * - Arrays of primitives
 * - Mixed structures
 *
 * @param obj - Object to redact (can contain nested objects/arrays)
 * @returns Redacted copy of the object
 */
export function redactObject<T extends Record<string, any>>(
  obj: T
): Record<string, any> {
  if (obj === null || obj === undefined) return obj;

  const redacted: Record<string, any> = {};

  for (const [key, value] of Object.entries(obj)) {
    const lowerKey = key.toLowerCase();

    // Handle nested objects recursively
    if (value && typeof value === "object" && !Array.isArray(value)) {
      redacted[key] = redactObject(value);
      continue;
    }

    // Handle arrays recursively
    if (Array.isArray(value)) {
      redacted[key] = value.map((item) =>
        item && typeof item === "object" ? redactObject(item) : item
      );
      continue;
    }

    // Redact user ID fields
    if (
      lowerKey.includes("userid") ||
      lowerKey === "id" ||
      lowerKey.includes("user_id")
    ) {
      if (typeof value === "string" && isUUID(value)) {
        redacted[key] = redactUserId(value);
        continue;
      }
    }

    // Redact email fields
    if (lowerKey.includes("email")) {
      if (typeof value === "string") {
        redacted[key] = redactEmail(value);
        continue;
      }
    }

    // Redact customer ID fields
    if (lowerKey.includes("customer")) {
      if (typeof value === "string" && value.startsWith("cus_")) {
        redacted[key] = redactCustomerId(value);
        continue;
      }
    }

    // Keep other values as-is
    redacted[key] = value;
  }

  return redacted;
}
```

#### 3. Fix Reconciliation Alert to Redact Issues

**File**: `lib/reconciliation/stripe-reconciliation.ts`

**Changes**: Redact userIds in critical_issues before logging

```typescript
/**
 * Send alert for critical drift requiring manual review
 */
function sendReconciliationAlert(result: ReconciliationResult) {
  const criticalIssues = result.issues.filter(
    (i) => i.action === "manual_review"
  );

  // ‚úÖ CHANGED: Redact userIds before logging
  const redactedIssues = criticalIssues.map((issue) => ({
    ...issue,
    userId: redactUserId(issue.userId),
  }));

  console.error("üö® CRITICAL: Billing drift requires manual review", {
    total_drift: result.drift_detected,
    auto_fixed: result.auto_fixed,
    manual_review: result.manual_review,
    errors: result.errors,
    critical_issues: redactedIssues, // ‚úÖ Now redacted
  });

  // TODO: Send email to admin (separate enhancement)
  // TODO: Post to Slack/Discord (separate enhancement)
}
```

#### 4. Create Centralized Sentry Utilities

**File**: `lib/sentry-utils.ts` (NEW)

**Changes**: Create new file with PII-safe Sentry helpers

```typescript
/**
 * Sentry Utilities with PII Protection
 *
 * Centralized utilities for capturing errors and events to Sentry
 * with automatic PII redaction.
 */

import * as Sentry from "@sentry/nextjs";
import { redactUserId, redactCustomerId } from "./logging";

/**
 * Redact Stripe session ID for Sentry
 *
 * @example redactSessionId("cs_test_123...") ‚Üí "cs_[REDACTED]"
 */
export function redactSessionId(
  sessionId: string | null | undefined
): string {
  if (!sessionId) return "N/A";

  // For now, just indicate it's redacted
  // Phase 2 will add HMAC
  return "cs_[REDACTED]";
}

/**
 * Redact Stripe subscription ID for Sentry
 *
 * @example redactSubscriptionId("sub_123...") ‚Üí "sub_[REDACTED]"
 */
export function redactSubscriptionId(
  subscriptionId: string | null | undefined
): string {
  if (!subscriptionId) return "N/A";

  // For now, just indicate it's redacted
  // Phase 2 will add HMAC
  return "sub_[REDACTED]";
}

/**
 * Capture error to Sentry with standardized context and PII redaction
 *
 * This is the ONLY way errors should be sent to Sentry in the application.
 * Never use Sentry.captureException() directly.
 *
 * @param error - Error to capture
 * @param context - Contextual information (all PII will be redacted)
 */
export function captureSentryError(
  error: Error,
  context: {
    level?: "fatal" | "error" | "warning";
    userId?: string;
    sessionId?: string;
    customerId?: string;
    subscriptionId?: string;
    eventType?: string;
    eventId?: string;
    tags?: Record<string, string>;
    extra?: Record<string, any>;
  }
): void {
  Sentry.captureException(error, {
    level: context.level || "error",
    tags: {
      event_type: context.eventType || "unknown",
      ...context.tags,
    },
    contexts: {
      user_context: {
        user_id: context.userId ? redactUserId(context.userId) : "N/A",
      },
      stripe: {
        session_id: redactSessionId(context.sessionId),
        customer_id: context.customerId
          ? redactCustomerId(context.customerId)
          : "N/A",
        subscription_id: redactSubscriptionId(context.subscriptionId),
      },
      event: {
        event_id: context.eventId || "N/A",
        timestamp: new Date().toISOString(),
      },
    },
    fingerprint: [
      // Group by error type and location, NOT by event ID
      error.name,
      context.eventType || "unknown",
      error.stack?.split("\n")[1]?.trim() || "unknown-location",
    ],
    user: context.userId
      ? {
          id: redactUserId(context.userId),
        }
      : undefined,
    extra: context.extra,
  });
}
```

#### 5. Update Admin Alerts to Use Sentry Utilities

**File**: `lib/admin-alerts.ts`

**Changes**: Replace direct Sentry.captureException with captureSentryError

```typescript
import * as Sentry from "@sentry/nextjs";
import { redactUserId } from "@/lib/logging";
import { captureSentryError } from "@/lib/sentry-utils"; // ‚úÖ NEW

export interface WebhookFailureAlert {
  userId: string;
  eventId: string;
  eventType: string;
  sessionId?: string;
  customerId?: string;
  subscriptionId?: string;
  errorMessage: string;
  retryCount: number;
  timestamp: Date;
}

export function shouldAlertAdmin(retryCount: number): boolean {
  return retryCount >= 3;
}

export async function sendAdminWebhookAlert(
  failure: WebhookFailureAlert
): Promise<void> {
  // Log to console with high visibility (keep for local dev)
  console.error("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  console.error("üö® CRITICAL WEBHOOK FAILURE - ADMIN ALERT");
  console.error("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  console.error(`User: ${redactUserId(failure.userId)}`);
  console.error(`Event Type: ${failure.eventType}`);
  console.error(`Retry Count: ${failure.retryCount}`);
  console.error(`Error: ${failure.errorMessage}`);
  console.error("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

  // ‚úÖ CHANGED: Use centralized Sentry utility with PII redaction
  captureSentryError(
    new Error(
      `Webhook failed after ${failure.retryCount} retries: ${failure.errorMessage}`
    ),
    {
      level: "fatal",
      userId: failure.userId,
      sessionId: failure.sessionId,
      customerId: failure.customerId,
      subscriptionId: failure.subscriptionId,
      eventType: failure.eventType,
      eventId: failure.eventId,
      tags: {
        retry_count: failure.retryCount.toString(),
        webhook_event_id: failure.eventId,
      },
      extra: {
        remediation: {
          database_table: "webhook_events",
          reconciliation_eta: "24 hours",
        },
      },
    }
  );

  console.log("‚úÖ Critical webhook failure sent to Sentry (PII redacted)");
}
```

### Success Criteria

#### Automated Verification:

- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Unit tests pass: `pnpm test` (after adding tests in Phase 3)

#### Manual Verification:

- [ ] Check `sentry.server.config.ts` ‚Üí `sendDefaultPii: false`
- [ ] Trigger webhook error ‚Üí Check Sentry ‚Üí No raw sessionId/customerId/subscriptionId
- [ ] Trigger reconciliation drift ‚Üí Check console ‚Üí userIds redacted in nested `critical_issues` array
- [ ] Check Sentry dashboard ‚Üí User IP addresses not captured

---

## Phase 2: HMAC Enhancement for Defense-in-Depth

### Overview

Replace simple truncation with HMAC-SHA256 for cryptographically secure pseudonymization. This provides defense-in-depth if logs are compromised.

### Changes Required

#### 1. Update Core Redaction Functions to Use HMAC

**File**: `lib/logging.ts`

**Changes**: Replace truncation with HMAC

```typescript
import crypto from "crypto"; // ‚úÖ NEW

/**
 * Redact user ID using HMAC for cryptographically secure pseudonymization
 *
 * Uses HMAC-SHA256 with a secret key to create deterministic but non-reversible hashes.
 * Complies with GDPR Article 32 pseudonymization requirements.
 *
 * @param userId - UUID to redact
 * @returns Redacted user ID (e.g., "user_a1b2c3d4e5f6")
 *
 * Security: HMAC prevents rainbow table attacks and brute force matching.
 * Even with database access, attacker cannot reverse without LOG_REDACTION_SECRET.
 */
export function redactUserId(userId: string | null | undefined): string {
  if (!userId) return "user_unknown";

  // Get secret from environment (required for production)
  const secret = process.env.LOG_REDACTION_SECRET;

  if (!secret) {
    // Development fallback - log warning once
    if (process.env.NODE_ENV === "development") {
      console.warn(
        "‚ö†Ô∏è LOG_REDACTION_SECRET not set - using default (INSECURE for production)"
      );
    }
    // Use a default for dev, but this should never happen in production
    const defaultSecret = "dev-only-insecure-default-change-in-production";
    const hmac = crypto
      .createHmac("sha256", defaultSecret)
      .update(userId)
      .digest("hex")
      .slice(0, 12);
    return `user_${hmac}`;
  }

  // Production: Use environment secret
  const hmac = crypto
    .createHmac("sha256", secret)
    .update(userId)
    .digest("hex")
    .slice(0, 12); // 12 hex chars = 48 bits of entropy

  return `user_${hmac}`;
}

/**
 * Redact email using HMAC for the local part, keep domain
 *
 * @example
 * redactEmail("john.doe@example.com") ‚Üí "user_a1b2c3d4@example.com"
 */
export function redactEmail(email: string | null | undefined): string {
  if (!email) return "***@unknown";

  const atIndex = email.indexOf("@");
  if (atIndex === -1) return "***@invalid";

  const localPart = email.slice(0, atIndex);
  const domain = email.slice(atIndex + 1);

  const secret =
    process.env.LOG_REDACTION_SECRET || "dev-only-insecure-default";
  const hmac = crypto
    .createHmac("sha256", secret)
    .update(localPart)
    .digest("hex")
    .slice(0, 8);

  return `user_${hmac}@${domain}`;
}

/**
 * Redact Stripe customer ID to prevent PII correlation
 *
 * @example
 * redactCustomerId("cus_123456789") // "cus_a1b2c3d4"
 */
export function redactCustomerId(
  customerId: string | null | undefined
): string {
  if (!customerId) return "cus_unknown";

  const secret =
    process.env.LOG_REDACTION_SECRET || "dev-only-insecure-default";

  // Extract the ID part (everything after "cus_")
  const idPart = customerId.startsWith("cus_")
    ? customerId.slice(4)
    : customerId;

  const hmac = crypto
    .createHmac("sha256", secret)
    .update(idPart)
    .digest("hex")
    .slice(0, 8);

  return `cus_${hmac}`;
}

// Keep all other functions unchanged (isUUID, isEmail, autoRedact, redactObject, safeLog)
```

#### 2. Update Sentry Utilities to Use HMAC

**File**: `lib/sentry-utils.ts`

**Changes**: Replace placeholder redaction with HMAC

```typescript
import * as Sentry from "@sentry/nextjs";
import { redactUserId, redactCustomerId } from "./logging";
import crypto from "crypto"; // ‚úÖ NEW

/**
 * Redact Stripe session ID for Sentry using HMAC
 *
 * @example redactSessionId("cs_test_123...") ‚Üí "cs_a1b2c3d4"
 */
export function redactSessionId(
  sessionId: string | null | undefined
): string {
  if (!sessionId) return "N/A";

  const secret =
    process.env.LOG_REDACTION_SECRET || "dev-only-insecure-default";

  // Extract ID part (everything after "cs_" or "cs_test_")
  const idPart = sessionId.replace(/^cs_(test_)?/, "");

  const hmac = crypto
    .createHmac("sha256", secret)
    .update(idPart)
    .digest("hex")
    .slice(0, 8);

  return `cs_${hmac}`;
}

/**
 * Redact Stripe subscription ID for Sentry using HMAC
 *
 * @example redactSubscriptionId("sub_123...") ‚Üí "sub_a1b2c3d4"
 */
export function redactSubscriptionId(
  subscriptionId: string | null | undefined
): string {
  if (!subscriptionId) return "N/A";

  const secret =
    process.env.LOG_REDACTION_SECRET || "dev-only-insecure-default";

  const idPart = subscriptionId.startsWith("sub_")
    ? subscriptionId.slice(4)
    : subscriptionId;

  const hmac = crypto
    .createHmac("sha256", secret)
    .update(idPart)
    .digest("hex")
    .slice(0, 8);

  return `sub_${hmac}`;
}

// captureSentryError() remains unchanged - already uses these functions
```

#### 3. Create Environment Variable Documentation

**File**: `.env.example` (CREATE if doesn't exist)

**Changes**: Document required environment variables

```bash
# ============================================
# Supabase Configuration
# ============================================
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# ============================================
# Stripe Configuration
# ============================================
STRIPE_SECRET_KEY=sk_test_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# ============================================
# PII Redaction Secret (REQUIRED for production)
# ============================================
# Generate with: openssl rand -base64 32
# NEVER commit the real secret to git
# Different secret per environment (dev, staging, prod)
LOG_REDACTION_SECRET=your-secret-key-here

# ============================================
# Sentry Configuration
# ============================================
SENTRY_DSN=https://9a6fb68c482da78fb51302d8388950f1@o4510365767303168.ingest.de.sentry.io/4510365768613968
SENTRY_AUTH_TOKEN=your-sentry-auth-token
SENTRY_ORG=your-org-name
SENTRY_PROJECT=your-project-name
```

#### 4. Create Secret Generation Script

**File**: `scripts/generate-redaction-secret.sh` (NEW)

**Changes**: Create helper script for generating secrets

```bash
#!/bin/bash
# Generate a secure random secret for LOG_REDACTION_SECRET

echo ""
echo "üîê Generating LOG_REDACTION_SECRET..."
echo ""

SECRET=$(openssl rand -base64 32)

echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Add this to your .env.local file:"
echo ""
echo "LOG_REDACTION_SECRET=${SECRET}"
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
echo "‚ö†Ô∏è  NEVER commit this secret to git!"
echo "‚ö†Ô∏è  Use different secrets for dev, staging, and production"
echo ""
```

Make executable:
```bash
chmod +x scripts/generate-redaction-secret.sh
```

### Success Criteria

#### Automated Verification:

- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Unit tests pass: `pnpm test`

#### Manual Verification:

- [ ] Run `./scripts/generate-redaction-secret.sh` ‚Üí Secret generated
- [ ] Add secret to `.env.local`
- [ ] Trigger webhook error ‚Üí Check logs ‚Üí Format is `user_a1b2c3d4e5f6` (12 chars, not 8)
- [ ] Check Sentry ‚Üí sessionId shows as `cs_a1b2c3d4` (8 chars)
- [ ] Verify redaction is deterministic (same input ‚Üí same output)

---

## Phase 3: Infrastructure & Testing

### Overview

Add comprehensive testing, source maps for Sentry, and performance monitoring.

### Changes Required

#### 1. Unit Tests for Redaction Functions

**File**: `lib/logging.test.ts` (NEW)

**Changes**: Create comprehensive test suite

```typescript
import {
  redactUserId,
  redactEmail,
  redactCustomerId,
  redactObject,
} from "./logging";

describe("HMAC-based PII Redaction", () => {
  // Set test secret
  beforeAll(() => {
    process.env.LOG_REDACTION_SECRET = "test-secret-key";
  });

  describe("redactUserId", () => {
    test("should redact user ID with HMAC", () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";
      const redacted = redactUserId(userId);

      expect(redacted).toMatch(/^user_[a-f0-9]{12}$/);
      expect(redacted).not.toContain(userId);
      expect(redacted.length).toBe(17); // "user_" + 12 hex chars
    });

    test("should be deterministic", () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";
      const redacted1 = redactUserId(userId);
      const redacted2 = redactUserId(userId);

      expect(redacted1).toBe(redacted2);
    });

    test("should produce different outputs for different inputs", () => {
      const userId1 = "550e8400-e29b-41d4-a716-446655440000";
      const userId2 = "660e8400-e29b-41d4-a716-446655440001";

      const redacted1 = redactUserId(userId1);
      const redacted2 = redactUserId(userId2);

      expect(redacted1).not.toBe(redacted2);
    });

    test("should handle null/undefined", () => {
      expect(redactUserId(null)).toBe("user_unknown");
      expect(redactUserId(undefined)).toBe("user_unknown");
    });

    test("should warn if secret not set", () => {
      delete process.env.LOG_REDACTION_SECRET;
      const consoleWarn = jest.spyOn(console, "warn");

      redactUserId("550e8400-e29b-41d4-a716-446655440000");

      expect(consoleWarn).toHaveBeenCalledWith(
        expect.stringContaining("LOG_REDACTION_SECRET not set")
      );

      // Restore
      process.env.LOG_REDACTION_SECRET = "test-secret-key";
    });
  });

  describe("redactEmail", () => {
    test("should redact email local part, keep domain", () => {
      const email = "john.doe@example.com";
      const redacted = redactEmail(email);

      expect(redacted).toMatch(/^user_[a-f0-9]{8}@example\.com$/);
      expect(redacted).toContain("@example.com");
      expect(redacted).not.toContain("john.doe");
    });

    test("should handle invalid emails", () => {
      expect(redactEmail("invalid")).toBe("***@invalid");
      expect(redactEmail(null)).toBe("***@unknown");
    });
  });

  describe("redactCustomerId", () => {
    test("should redact Stripe customer ID", () => {
      const customerId = "cus_123456789abcdef";
      const redacted = redactCustomerId(customerId);

      expect(redacted).toMatch(/^cus_[a-f0-9]{8}$/);
      expect(redacted).not.toContain("123456789");
    });

    test("should handle null/undefined", () => {
      expect(redactCustomerId(null)).toBe("cus_unknown");
      expect(redactCustomerId(undefined)).toBe("cus_unknown");
    });
  });

  describe("redactObject - Recursive Redaction", () => {
    test("should handle nested objects", () => {
      const obj = {
        user: {
          id: "550e8400-e29b-41d4-a716-446655440000",
          email: "test@example.com",
        },
        metadata: {
          userId: "550e8400-e29b-41d4-a716-446655440000",
        },
      };

      const redacted = redactObject(obj);

      expect(redacted.user.id).toMatch(/^user_[a-f0-9]{12}$/);
      expect(redacted.user.email).toMatch(/^user_[a-f0-9]{8}@example\.com$/);
      expect(redacted.metadata.userId).toMatch(/^user_[a-f0-9]{12}$/);
    });

    test("should handle arrays of objects", () => {
      const obj = {
        issues: [
          { userId: "550e8400-e29b-41d4-a716-446655440000" },
          { userId: "660e8400-e29b-41d4-a716-446655440001" },
        ],
      };

      const redacted = redactObject(obj);

      expect(redacted.issues[0].userId).toMatch(/^user_[a-f0-9]{12}$/);
      expect(redacted.issues[1].userId).toMatch(/^user_[a-f0-9]{12}$/);
    });

    test("should handle deeply nested structures", () => {
      const obj = {
        level1: {
          level2: {
            level3: {
              userId: "550e8400-e29b-41d4-a716-446655440000",
            },
          },
        },
      };

      const redacted = redactObject(obj);

      expect(redacted.level1.level2.level3.userId).toMatch(
        /^user_[a-f0-9]{12}$/
      );
    });

    test("should handle mixed arrays", () => {
      const obj = {
        data: [
          { id: "550e8400-e29b-41d4-a716-446655440000" },
          "string value",
          123,
          null,
        ],
      };

      const redacted = redactObject(obj);

      expect(redacted.data[0].id).toMatch(/^user_[a-f0-9]{12}$/);
      expect(redacted.data[1]).toBe("string value");
      expect(redacted.data[2]).toBe(123);
      expect(redacted.data[3]).toBe(null);
    });

    test("should handle null/undefined", () => {
      expect(redactObject(null as any)).toBe(null);
      expect(redactObject(undefined as any)).toBe(undefined);
    });
  });
});
```

#### 2. Unit Tests for Sentry Utilities

**File**: `lib/sentry-utils.test.ts` (NEW)

**Changes**: Create test suite for Sentry helpers

```typescript
import {
  captureSentryError,
  redactSessionId,
  redactSubscriptionId,
} from "./sentry-utils";
import * as Sentry from "@sentry/nextjs";

jest.mock("@sentry/nextjs");

describe("Sentry PII Redaction", () => {
  beforeAll(() => {
    process.env.LOG_REDACTION_SECRET = "test-secret-key";
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("should redact session ID", () => {
    const sessionId = "cs_test_a1b2c3d4e5f6g7h8i9j0";
    const redacted = redactSessionId(sessionId);

    expect(redacted).toMatch(/^cs_[a-f0-9]{8}$/);
    expect(redacted).not.toContain("test_a1b2c3d4");
  });

  test("should redact subscription ID", () => {
    const subscriptionId = "sub_1234567890abcdef";
    const redacted = redactSubscriptionId(subscriptionId);

    expect(redacted).toMatch(/^sub_[a-f0-9]{8}$/);
    expect(redacted).not.toContain("1234567890");
  });

  test("should capture error with redacted context", () => {
    const error = new Error("Test error");

    captureSentryError(error, {
      level: "error",
      userId: "550e8400-e29b-41d4-a716-446655440000",
      sessionId: "cs_test_123",
      customerId: "cus_123456789",
      subscriptionId: "sub_123456789",
      eventType: "checkout.session.completed",
    });

    expect(Sentry.captureException).toHaveBeenCalledWith(
      error,
      expect.objectContaining({
        level: "error",
        contexts: expect.objectContaining({
          user_context: expect.objectContaining({
            user_id: expect.stringMatching(/^user_[a-f0-9]{12}$/),
          }),
          stripe: expect.objectContaining({
            session_id: expect.stringMatching(/^cs_[a-f0-9]{8}$/),
            customer_id: expect.stringMatching(/^cus_[a-f0-9]{8}$/),
            subscription_id: expect.stringMatching(/^sub_[a-f0-9]{8}$/),
          }),
        }),
      })
    );
  });

  test("should use proper fingerprinting for error grouping", () => {
    const error = new Error("Test error");
    error.stack = "Error: Test error\n    at testFunction (file.ts:10:5)";

    captureSentryError(error, {
      eventType: "webhook.error",
    });

    expect(Sentry.captureException).toHaveBeenCalledWith(
      error,
      expect.objectContaining({
        fingerprint: expect.arrayContaining(["Error", "webhook.error"]),
      })
    );
  });
});
```

#### 3. Add Source Maps Configuration (Optional)

**File**: `next.config.mjs`

**Changes**: Configure Sentry webpack plugin (if not already configured)

```javascript
import { withSentryConfig } from "@sentry/nextjs";

const nextConfig = {
  // Existing config...
};

export default withSentryConfig(
  nextConfig,
  {
    // Sentry webpack plugin options
    silent: true, // Suppress logs during build

    // Upload source maps to Sentry
    widenClientFileUpload: true,
    hideSourceMaps: true, // Don't serve source maps to browsers
    disableLogger: true,

    // Automatic instrumentation
    automaticVercelMonitors: true,
  },
  {
    // Sentry configuration options
    transpileClientSDK: true,
  }
);
```

#### 4. Update README with Security Documentation

**File**: `README.md`

**Changes**: Add section on PII protection

```markdown
## Security & PII Protection

### Environment Variables

This application requires the following environment variables for proper PII protection:

```bash
# Generate with: ./scripts/generate-redaction-secret.sh
LOG_REDACTION_SECRET=your-secret-key-here
```

**IMPORTANT:**
- Use different secrets for dev, staging, and production
- Never commit secrets to git
- Rotate annually or on suspected compromise

### PII Redaction

All user IDs, emails, and Stripe IDs are automatically redacted in logs using HMAC-SHA256:

```typescript
import { redactUserId, redactEmail } from "@/lib/logging";

console.log("User action", {
  userId: redactUserId(userId), // user_a1b2c3d4e5f6
  email: redactEmail(email), // user_12345678@example.com
});
```

### Sentry Error Capture

Use the centralized Sentry utility to ensure PII is never leaked:

```typescript
import { captureSentryError } from "@/lib/sentry-utils";

try {
  // ... code
} catch (error) {
  captureSentryError(error as Error, {
    level: "error",
    userId: userId, // Automatically redacted
    sessionId: sessionId, // Automatically redacted
    eventType: "checkout.error",
  });
}
```

**Never use `Sentry.captureException()` directly** - always use `captureSentryError()`.
```

### Success Criteria

#### Automated Verification:

- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Test coverage > 80% for logging.ts and sentry-utils.ts

#### Manual Verification:

- [ ] Trigger error in dev ‚Üí Check Sentry ‚Üí Stack trace shows TypeScript line numbers (if source maps enabled)
- [ ] Run tests ‚Üí All redaction tests pass
- [ ] Check README ‚Üí PII protection section exists

---

## Testing Strategy

### Unit Tests

**Redaction Functions:**
- Test HMAC determinism (same input ‚Üí same output)
- Test entropy (different inputs ‚Üí different outputs)
- Test null/undefined handling
- Test secret warning when not set
- Test recursive object redaction
- Test array redaction

**Sentry Utilities:**
- Test PII redaction in all contexts
- Test error fingerprinting
- Test level assignment
- Test context structure

### Integration Tests

**Webhook Flow:**
```bash
# 1. Generate secret
./scripts/generate-redaction-secret.sh

# 2. Add to .env.local
echo "LOG_REDACTION_SECRET=<generated-secret>" >> .env.local

# 3. Start dev server
pnpm dev

# 4. Trigger a webhook (use Stripe CLI)
stripe trigger checkout.session.completed

# 5. Check logs for redacted format
# Should see: "user_a1b2c3d4e5f6" (12 chars)
# NOT: "user_550e8400" (8 chars)
```

**Reconciliation Flow:**
```bash
# 1. Run reconciliation cron
curl http://localhost:3000/api/cron/reconcile-stripe

# 2. Check console output
# critical_issues array should have redacted userIds
```

**Sentry Capture:**
```bash
# 1. Trigger an intentional error
# 2. Check Sentry dashboard
# 3. Verify:
#    - No raw Stripe IDs (sessionId, customerId, subscriptionId)
#    - User IDs in format: user_a1b2c3d4e5f6
#    - No IP addresses captured
#    - Errors properly grouped by fingerprint
```

### Manual Testing Checklist

- [ ] Generate `LOG_REDACTION_SECRET` using script
- [ ] Add secret to `.env.local`
- [ ] Start dev server
- [ ] Trigger webhook error (Stripe CLI)
- [ ] Check console logs ‚Üí Verify `user_XXXXXXXXXXXX` format (12 chars)
- [ ] Check Sentry ‚Üí Verify no raw Stripe IDs
- [ ] Check Sentry ‚Üí Verify userIds redacted
- [ ] Trigger reconciliation drift ‚Üí Verify nested `critical_issues` redacted
- [ ] Verify logs show no warnings about missing secret
- [ ] Deploy to staging ‚Üí Add secret to Vercel env vars
- [ ] Test in staging ‚Üí Same verifications

## Performance Considerations

### HMAC Impact

**Before (Truncation):**
- String slicing: ~0.001ms per call
- No crypto operations

**After (HMAC):**
- HMAC-SHA256: ~0.01-0.05ms per call
- 10-50x slower but still negligible

**Impact Analysis:**
- Webhook processing: ~5-10 redactions per webhook = +0.05-0.5ms (negligible)
- Reconciliation: ~100-1000 redactions = +1-50ms (acceptable)
- Console logging: Minimal impact (only on error paths)

**Conclusion:** Performance impact is negligible for this use case.

### Sentry Overhead

**Before (`sendDefaultPii: true`):**
- Larger payload (IPs, headers, cookies)
- More data sent to Sentry

**After (`sendDefaultPii: false` + `beforeSend`):**
- Smaller payload (filtered data)
- Less bandwidth usage
- Faster Sentry uploads

**Conclusion:** Likely a net performance improvement.

## Migration Notes

### Breaking Changes

**Log Format Change:**
- Old format: `user_550e8400` (8 chars)
- New format: `user_a1b2c3d4e5f6` (12 chars)

**Impact:**
- Existing log queries with old format will stop working
- Correlation across deployment boundary is broken (by design)
- This is acceptable - logs are ephemeral

**Mitigation:**
- Document in deployment notes
- Update any log aggregation queries
- Consider keeping both formats during transition (not recommended)

### Deployment Strategy

**Recommended Approach:**
1. Deploy Phase 1 first (fixes active leaks)
2. Verify Sentry no longer captures PII
3. Deploy Phase 2 (HMAC) separately
4. Generate secrets for each environment
5. Deploy Phase 3 (tests + source maps) last

**Rollback Plan:**
- Phase 1: Can rollback safely (just changes config)
- Phase 2: Can rollback but logs will be in new format (consider keeping for 1 week before rollback decision)
- Phase 3: Can rollback safely (just tests)

## References

- Original ticket: `.claude/tickets/0035-enhance-pii-redaction-with-hmac.md`
- Related ticket: `.claude/tickets/0036-sentry-pii-cleanup-and-integration.md`
- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
- [GDPR Article 32](https://gdpr-info.eu/art-32-gdpr/) - Security of Processing
- [Sentry PII Guidelines](https://docs.sentry.io/platforms/javascript/data-management/sensitive-data/)
- [NIST SP 800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html) - Digital Identity Guidelines

## Labels

- `priority: urgent` (Phase 1)
- `priority: important` (Phase 2)
- `type: security`
- `component: logging`
- `component: monitoring`
- `gdpr-compliance`
- `pii-protection`
- `cryptography`
