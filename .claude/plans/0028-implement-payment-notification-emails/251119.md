# Payment Notification Emails - Implementation Plan

**Date**: 2025-11-19
**Ticket**: `.claude/tickets/0028-implement-payment-notification-emails.md`
**Revised Scope**: Phase-based approach starting with critical gaps only

---

## Overview

Implement email notifications for payment events to provide users with transparency about their billing status. This plan uses a **phased approach** to address the most critical gaps first, then expand based on validation.

**Key Context**:
- Stripe's built-in emails are now enabled (invoice failures, refunds, receipts)
- Resend email service is already integrated (used in Supabase Edge Functions)
- React Email templates already exist (auth emails can be used as reference)
- Webhook handlers run in Next.js API routes (not Edge Functions)

---

## Current State Analysis

### What Exists:
- ‚úÖ Stripe webhook handlers process all payment events (`app/api/stripe/webhook/route.ts`)
- ‚úÖ Comprehensive webhook logging and error handling
- ‚úÖ Resend integrated in Supabase Edge Functions for auth emails
- ‚úÖ React Email templates for verification and password reset
- ‚úÖ Post-checkout UI polling for activation status
- ‚úÖ BillingSync component for real-time updates

### What Stripe Now Handles (After Dashboard Configuration):
- ‚úÖ Subscription payment failures (`invoice.payment_failed`)
- ‚úÖ Refund notifications (`charge.refunded`)
- ‚úÖ Successful payment receipts
- ‚úÖ Subscription cancellation confirmations

### Critical Gaps Remaining:
- ‚ùå One-time payment failures (lifetime plan) - NO Stripe email
- ‚ùå Subscription change confirmations (upgrades/downgrades) - NO Stripe email
- ‚ùå Welcome/onboarding emails - NO Stripe email

---

## Desired End State

Users receive email notifications for:
1. **Payment failures** - Know why payment didn't work and how to fix it
2. **Subscription changes** - Confirm plan upgrades/downgrades with details
3. **Welcome messages** - Onboarding guidance after first purchase

### Success Verification:

**Automated Verification:**
- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Email templates render correctly: `pnpm email`

**Manual Verification:**
- [ ] Test email delivery in Resend test mode
- [ ] Trigger test webhooks with Stripe CLI
- [ ] Verify emails appear in inbox (not spam)
- [ ] Confirm webhook succeeds even if email fails
- [ ] Check Resend Dashboard for delivery status
- [ ] Links in emails work correctly (portal, billing page)
- [ ] Plain text fallback renders properly
- [ ] Mobile email rendering is acceptable

---

## What We're NOT Doing

To prevent scope creep:

- ‚ùå Marketing emails or newsletters
- ‚ùå Email preference management UI
- ‚ùå Email open/click tracking analytics
- ‚ùå Batch email sending or email queues
- ‚ùå Email template builder UI
- ‚ùå Re-implementing emails Stripe already sends (invoice failures, refunds)
- ‚ùå Admin dispute alerts (separate ticket, not user-facing transparency)
- ‚ùå SMS notifications (future enhancement)
- ‚ùå In-app notification center (separate feature)

---

## Implementation Approach

**Strategy**: Phased rollout starting with the most critical user transparency gap.

**Why Phased**:
1. Validate email infrastructure works before building all types
2. Measure impact (support ticket reduction) before investing more
3. Avoid over-engineering if Stripe emails + UI feedback are sufficient
4. Allow iteration on email copy/design based on real user feedback

**Technical Approach**:
- Create centralized email service in Next.js (`lib/email-service.ts`)
- Build React Email templates in new `emails/` directory
- Integrate with existing webhook handlers (non-breaking)
- Follow error handling patterns from existing webhook code
- Use environment variables for configuration

---

## Phase 1: One-Time Payment Failure Notification

**Goal**: Notify users when lifetime plan purchase fails

**Priority**: üî¥ **CRITICAL** (Stripe doesn't send email for this)

**Estimated Effort**: 4-6 hours

### Overview

When a user attempts to purchase the lifetime plan but payment fails, they need to know:
- What happened (payment declined)
- Why it happened (card declined, insufficient funds, etc.)
- How to fix it (update payment method, try different card)
- Where to get help (support contact)

Currently, users only see an error if they're still on the Stripe Checkout page. If they close the browser before seeing the error, they're left wondering why they don't have access.

### Changes Required

#### 1. Environment Configuration

**File**: `.env.example`

**Changes**: Add Resend configuration documentation

```bash
# ============================================
# Email Configuration (Resend)
# ============================================
RESEND_API_KEY=re_...
RESEND_FROM_EMAIL="Handicappin' <sebastiansole@handicappin.com>"
```

**Verification**:
- Ensure `RESEND_API_KEY` is set in `.env.local`
- Verify domain `handicappin.com` is configured in Resend Dashboard
- Check SPF/DKIM DNS records are published

---

#### 2. Email Service Utility

**File**: `lib/email-service.ts` (new file)

**Changes**: Create centralized email service for billing notifications

```typescript
import { Resend } from 'resend';
import { render } from '@react-email/components';
import PaymentFailedEmail from '@/emails/payment-failed';
import { logWebhookInfo, logWebhookError } from './webhook-logger';

const resend = new Resend(process.env.RESEND_API_KEY);

const FROM_EMAIL = process.env.RESEND_FROM_EMAIL || "Handicappin' <sebastiansole@handicappin.com>";

interface SendEmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

/**
 * Send payment failed notification to user
 * Used when one-time payment (lifetime plan) fails
 */
export async function sendPaymentFailedEmail({
  to,
  amount,
  currency,
  reason,
  paymentIntentId,
  portalUrl,
}: {
  to: string;
  amount: number;
  currency: string;
  reason?: string;
  paymentIntentId: string;
  portalUrl: string;
}): Promise<SendEmailResult> {
  try {
    logWebhookInfo(`Sending payment failed email to ${to}`);

    const emailHtml = await render(
      PaymentFailedEmail({
        amount,
        currency,
        reason,
        portalUrl,
        supportEmail: 'support@handicappin.com',
      })
    );

    const result = await resend.emails.send({
      from: FROM_EMAIL,
      to,
      subject: 'Payment Failed - Action Required',
      html: emailHtml,
    });

    logWebhookInfo(`Payment failed email sent successfully to ${to}`, {
      messageId: result.data?.id,
      paymentIntentId,
    });

    return {
      success: true,
      messageId: result.data?.id,
    };
  } catch (error) {
    logWebhookError('Failed to send payment failed email', error, {
      recipient: to,
      paymentIntentId,
    });

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Test email sending (for development)
 */
export async function sendTestEmail(to: string): Promise<SendEmailResult> {
  try {
    const result = await resend.emails.send({
      from: FROM_EMAIL,
      to,
      subject: 'Test Email from Handicappin\'',
      html: '<p>This is a test email. If you received this, email service is working!</p>',
    });

    return {
      success: true,
      messageId: result.data?.id,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

**Notes**:
- Uses existing `logWebhookInfo` and `logWebhookError` for consistency
- Returns result object (doesn't throw) to prevent breaking webhooks
- Includes test function for development verification

---

#### 3. Email Template

**File**: `emails/payment-failed.tsx` (new file)

**Changes**: Create React Email template for payment failures

```typescript
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Img,
  Link,
  Preview,
  Section,
  Text,
  Tailwind,
} from '@react-email/components';

interface PaymentFailedEmailProps {
  amount: number;
  currency: string;
  reason?: string;
  portalUrl: string;
  supportEmail: string;
}

export default function PaymentFailedEmail({
  amount = 19900,
  currency = 'usd',
  reason = 'Your card was declined',
  portalUrl = 'https://billing.stripe.com/p/login/test',
  supportEmail = 'support@handicappin.com',
}: PaymentFailedEmailProps) {
  const formattedAmount = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency.toUpperCase(),
  }).format(amount / 100);

  return (
    <Html>
      <Head />
      <Preview>Your payment for Handicappin' Lifetime could not be processed</Preview>
      <Tailwind>
        <Body className="bg-gray-50 font-sans">
          <Container className="mx-auto py-8 px-4 max-w-xl">
            <Section className="bg-white rounded-lg shadow-sm p-8">
              {/* Header */}
              <Heading className="text-2xl font-bold text-gray-900 mb-2">
                Payment Failed
              </Heading>
              <Text className="text-gray-600 mb-6">
                We couldn't process your payment for Handicappin' Lifetime
              </Text>

              {/* Amount Box */}
              <Section className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
                <Text className="text-sm text-gray-600 mb-1">Amount Attempted</Text>
                <Text className="text-2xl font-bold text-gray-900 mb-2">
                  {formattedAmount}
                </Text>
                <Text className="text-sm text-red-600">
                  {reason || 'Payment could not be processed'}
                </Text>
              </Section>

              {/* What Happened */}
              <Section className="mb-6">
                <Heading className="text-lg font-semibold text-gray-900 mb-2">
                  What happened?
                </Heading>
                <Text className="text-gray-600 mb-3">
                  Your payment for Handicappin' Lifetime was declined by your bank.
                  This can happen for several reasons:
                </Text>
                <ul className="text-gray-600 space-y-1 mb-0">
                  <li>‚Ä¢ Insufficient funds</li>
                  <li>‚Ä¢ Card expired or incorrect details</li>
                  <li>‚Ä¢ Bank security holds</li>
                  <li>‚Ä¢ International transaction restrictions</li>
                </ul>
              </Section>

              {/* Action Button */}
              <Section className="mb-6">
                <Heading className="text-lg font-semibold text-gray-900 mb-2">
                  How to fix it
                </Heading>
                <Text className="text-gray-600 mb-4">
                  You can update your payment method or try a different card. Click
                  the button below to continue:
                </Text>
                <Button
                  href={portalUrl}
                  className="bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg inline-block"
                >
                  Update Payment Method
                </Button>
              </Section>

              {/* Support Section */}
              <Section className="border-t border-gray-200 pt-6">
                <Text className="text-sm text-gray-600 mb-2">
                  <strong>Need help?</strong>
                </Text>
                <Text className="text-sm text-gray-600">
                  If you continue to experience issues, please contact us at{' '}
                  <Link href={`mailto:${supportEmail}`} className="text-blue-600 underline">
                    {supportEmail}
                  </Link>
                  . We're here to help!
                </Text>
              </Section>

              {/* Footer */}
              <Section className="mt-8 pt-6 border-t border-gray-200">
                <Text className="text-xs text-gray-500 text-center mb-2">
                  This is a transactional email about your Handicappin' account.
                </Text>
                <Text className="text-xs text-gray-500 text-center">
                  ¬© 2025 Handicappin'. All rights reserved.
                </Text>
              </Section>
            </Section>
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
}
```

**Notes**:
- Uses Tailwind classes (consistent with existing auth emails)
- Mobile-responsive design
- Clear call-to-action (Update Payment Method)
- Helpful context (why payment might fail)
- Support contact included
- Preview text for email clients

---

#### 4. Webhook Handler Integration

**File**: `app/api/stripe/webhook/route.ts`

**Changes**: Add email notification to `handlePaymentIntentFailed` function

**Location**: Lines 733-779

**Current Code**:
```typescript
async function handlePaymentIntentFailed(paymentIntent: any) {
  const paymentIntentId = paymentIntent.id;

  logPaymentEvent(`Payment intent failed: ${paymentIntentId}`);

  try {
    // Find pending lifetime purchase
    const pendingResults = await db
      .select()
      .from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, paymentIntentId))
      .limit(1);

    if (pendingResults.length === 0) {
      logWebhookInfo(
        `No pending lifetime purchase found for failed payment intent ${paymentIntentId}`
      );
      return;
    }

    const purchase = pendingResults[0];

    // Mark purchase as failed
    try {
      await db
        .update(pendingLifetimePurchases)
        .set({
          status: "failed",
          updatedAt: new Date(),
        })
        .where(eq(pendingLifetimePurchases.id, purchase.id));

      logWebhookWarning(
        `Payment failed for user ${purchase.userId} - marked pending purchase ${purchase.id} as failed`
      );
    } catch (dbError) {
      logWebhookError(`Error marking pending purchase as failed`, dbError);
      throw dbError;
    }

    // TODO: Send email notification to user (separate ticket)
    // TODO: Consider cleanup job for old failed purchases (separate ticket)
  } catch (error) {
    logWebhookError("Error processing payment intent failed", error);
    throw error;
  }
}
```

**Updated Code** (replace TODO with implementation):

```typescript
import { sendPaymentFailedEmail } from "@/lib/email-service";
import { stripe } from "@/lib/stripe";

async function handlePaymentIntentFailed(paymentIntent: any) {
  const paymentIntentId = paymentIntent.id;

  logPaymentEvent(`Payment intent failed: ${paymentIntentId}`);

  try {
    // Find pending lifetime purchase
    const pendingResults = await db
      .select()
      .from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, paymentIntentId))
      .limit(1);

    if (pendingResults.length === 0) {
      logWebhookInfo(
        `No pending lifetime purchase found for failed payment intent ${paymentIntentId}`
      );
      return;
    }

    const purchase = pendingResults[0];

    // Mark purchase as failed
    try {
      await db
        .update(pendingLifetimePurchases)
        .set({
          status: "failed",
          updatedAt: new Date(),
        })
        .where(eq(pendingLifetimePurchases.id, purchase.id));

      logWebhookWarning(
        `Payment failed for user ${purchase.userId} - marked pending purchase ${purchase.id} as failed`
      );
    } catch (dbError) {
      logWebhookError(`Error marking pending purchase as failed`, dbError);
      throw dbError;
    }

    // ‚úÖ NEW: Send email notification to user
    try {
      // Get user email from profile
      const userProfile = await db
        .select()
        .from(profile)
        .where(eq(profile.id, purchase.userId))
        .limit(1);

      if (userProfile.length === 0) {
        logWebhookWarning(
          `No profile found for user ${purchase.userId} - skipping email`
        );
      } else {
        const userEmail = userProfile[0].email;

        if (!userEmail) {
          logWebhookWarning(
            `No email found for user ${purchase.userId} - skipping email`
          );
        } else {
          // Get Stripe customer for portal URL
          const customerRecord = await db
            .select()
            .from(stripeCustomers)
            .where(eq(stripeCustomers.userId, purchase.userId))
            .limit(1);

          let portalUrl = `${process.env.NEXT_PUBLIC_APP_URL}/billing`;

          if (customerRecord.length > 0) {
            try {
              const portalSession = await stripe.billingPortal.sessions.create({
                customer: customerRecord[0].stripeCustomerId,
                return_url: `${process.env.NEXT_PUBLIC_APP_URL}/billing`,
              });
              portalUrl = portalSession.url;
            } catch (portalError) {
              logWebhookError(
                "Failed to create portal session for email",
                portalError
              );
              // Continue with fallback URL
            }
          }

          // Extract payment failure reason
          const failureMessage =
            paymentIntent.last_payment_error?.message ||
            "Your payment could not be processed";

          // Send email (non-blocking)
          const emailResult = await sendPaymentFailedEmail({
            to: userEmail,
            amount: paymentIntent.amount,
            currency: paymentIntent.currency,
            reason: failureMessage,
            paymentIntentId: paymentIntentId,
            portalUrl,
          });

          if (!emailResult.success) {
            // Log but don't throw - email failure shouldn't break webhook
            logWebhookWarning(
              `Email notification failed for user ${purchase.userId}, but webhook processing continues`,
              {
                error: emailResult.error,
              }
            );
          }
        }
      }
    } catch (emailError) {
      // Log but don't throw - email failure shouldn't break webhook processing
      logWebhookError(
        "Error sending payment failed email (webhook processing continues)",
        emailError,
        {
          userId: purchase.userId,
          paymentIntentId,
        }
      );
    }

    // TODO: Consider cleanup job for old failed purchases (separate ticket)
  } catch (error) {
    logWebhookError("Error processing payment intent failed", error);
    throw error;
  }
}
```

**Notes**:
- Email sending wrapped in try-catch (doesn't break webhook)
- Gets user email from profile table
- Creates Stripe portal URL for "Update Payment Method" link
- Extracts failure reason from `paymentIntent.last_payment_error`
- Logs email delivery status but continues webhook processing
- Follows existing error handling patterns

---

### Success Criteria

#### Automated Verification:

- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Email template renders: `pnpm email` (view payment-failed template)

#### Manual Verification:

- [ ] Test email sends successfully in development:
  - Import `sendTestEmail` from `lib/email-service.ts`
  - Call with your email address
  - Verify receipt in inbox (not spam)

- [ ] Trigger payment failure with Stripe CLI:
  ```bash
  stripe trigger payment_intent.payment_failed
  ```
  - Verify email is sent
  - Check Resend Dashboard for delivery confirmation
  - Verify email content is correct

- [ ] Test error handling:
  - Temporarily break Resend API key
  - Trigger payment failure
  - Verify webhook succeeds despite email failure
  - Check logs for appropriate error message

- [ ] Verify email rendering:
  - Test in Gmail, Outlook, Apple Mail
  - Check mobile rendering (iOS, Android)
  - Verify all links work (portal URL, support email)
  - Check plain text fallback

---

## Phase 2: Subscription Change Confirmations

**Goal**: Notify users when they upgrade, downgrade, or cancel subscriptions

**Priority**: üü° **MEDIUM** (UX improvement, not critical)

**Estimated Effort**: 6-8 hours

**Defer Until**: Phase 1 validated (2-4 weeks of monitoring)

### Overview

When users change their subscription plan, they currently only see a browser `alert()` popup. This provides no paper trail and can be easily dismissed/forgotten.

Emails should confirm:
- What changed (Premium ‚Üí Unlimited, etc.)
- When it takes effect (immediate vs. end of period)
- Cost impact (prorated charge, refund, etc.)
- What features they gain/lose

### Changes Required

#### 1. Email Templates

**Files**:
- `emails/subscription-upgraded.tsx` (new)
- `emails/subscription-downgraded.tsx` (new)
- `emails/subscription-cancelled.tsx` (new)

**Content**:
- **Upgraded**: "Your plan is now [plan]! Changes are effective immediately."
- **Downgraded**: "Your plan will change to [plan] on [date]. Your access continues until then."
- **Cancelled**: "Your subscription will end on [date]. You can reactivate anytime."

---

#### 2. Email Service Functions

**File**: `lib/email-service.ts`

**Changes**: Add functions for subscription change emails

```typescript
export async function sendSubscriptionUpgradedEmail({
  to,
  oldPlan,
  newPlan,
  proratedCharge,
  currency,
  effectiveDate,
  billingUrl,
}: {
  to: string;
  oldPlan: string;
  newPlan: string;
  proratedCharge: number;
  currency: string;
  effectiveDate: Date;
  billingUrl: string;
}): Promise<SendEmailResult> {
  // Implementation similar to sendPaymentFailedEmail
}

export async function sendSubscriptionDowngradedEmail({
  to,
  oldPlan,
  newPlan,
  effectiveDate,
  billingUrl,
}: {
  to: string;
  oldPlan: string;
  newPlan: string;
  effectiveDate: Date;
  billingUrl: string;
}): Promise<SendEmailResult> {
  // Implementation similar to sendPaymentFailedEmail
}

export async function sendSubscriptionCancelledEmail({
  to,
  plan,
  endDate,
  billingUrl,
}: {
  to: string;
  plan: string;
  endDate: Date;
  billingUrl: string;
}): Promise<SendEmailResult> {
  // Implementation similar to sendPaymentFailedEmail
}
```

---

#### 3. Integration Points

**File**: `app/api/stripe/subscription/route.ts`

**Changes**: Send email after successful subscription update

**Location**: Lines 80-173 (PUT handler)

**Current Flow**:
1. User calls PUT /api/stripe/subscription
2. Backend calls `updateSubscription()` from `lib/stripe.ts`
3. Returns success message
4. Frontend shows `alert()` with message

**Updated Flow**:
1. User calls PUT /api/stripe/subscription
2. Backend calls `updateSubscription()`
3. **NEW**: Send confirmation email based on change type
4. Return success message
5. Frontend shows `alert()` with message

**Implementation**:
```typescript
// In PUT handler (line 113-173)
const result = await updateSubscription({ userId: session.user.id, newPlan });

// ‚úÖ NEW: Send confirmation email
try {
  const userEmail = session.user.email;

  if (result.changeType === 'upgrade') {
    await sendSubscriptionUpgradedEmail({
      to: userEmail,
      oldPlan: currentPlan,
      newPlan,
      // ... other params
    });
  } else if (result.changeType === 'downgrade') {
    await sendSubscriptionDowngradedEmail({
      to: userEmail,
      oldPlan: currentPlan,
      newPlan,
      // ... other params
    });
  } else if (result.changeType === 'cancel') {
    await sendSubscriptionCancelledEmail({
      to: userEmail,
      plan: currentPlan,
      // ... other params
    });
  }
} catch (emailError) {
  // Log but don't fail the API request
  console.error('Failed to send subscription change email:', emailError);
}
```

---

### Success Criteria

#### Automated Verification:

- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Email templates render: `pnpm email`

#### Manual Verification:

- [ ] Test upgrade flow:
  - Upgrade from Premium to Unlimited
  - Verify email received with correct details
  - Check prorated charge is shown

- [ ] Test downgrade flow:
  - Downgrade from Unlimited to Premium
  - Verify email shows "changes on [date]"
  - Confirm no immediate access loss

- [ ] Test cancellation flow:
  - Cancel subscription (downgrade to free)
  - Verify email confirms end date
  - Check "reactivate" messaging

- [ ] Verify email rendering across email clients

---

## Phase 3: Welcome/Onboarding Emails

**Goal**: Send welcome email after first successful subscription purchase

**Priority**: üü° **MEDIUM** (nice-to-have, engagement boost)

**Estimated Effort**: 3-4 hours

**Defer Until**: Phase 1 & 2 validated (4-8 weeks)

### Overview

After a user completes their first subscription purchase, send a welcome email with:
- Thank you message
- Overview of premium features
- Getting started guide
- Link to dashboard

**Note**: This is separate from Stripe's payment receipt. Stripe confirms the transaction; this email welcomes them to the product.

### Changes Required

#### 1. Email Template

**File**: `emails/welcome.tsx` (new)

**Content**:
- Headline: "Welcome to Handicappin' [Plan]!"
- Feature highlights (what they can now do)
- "Get Started" button ‚Üí dashboard
- Support contact info

---

#### 2. Email Service Function

**File**: `lib/email-service.ts`

**Changes**: Add welcome email function

```typescript
export async function sendWelcomeEmail({
  to,
  plan,
  dashboardUrl,
}: {
  to: string;
  plan: string;
  dashboardUrl: string;
}): Promise<SendEmailResult> {
  // Implementation similar to sendPaymentFailedEmail
}
```

---

#### 3. Integration Point

**File**: `app/api/stripe/webhook/route.ts`

**Changes**: Send welcome email on first successful subscription

**Location**: Lines 313-447 (`handleCheckoutCompleted` function)

**Logic**:
- Check if this is user's first paid plan (was on free before)
- If yes, send welcome email
- If no (plan change), skip

**Implementation**:
```typescript
// After granting access (line 438)
// Check if this was their first paid plan
const wasOnFreePlan = /* check if planSelected was 'free' before */;

if (wasOnFreePlan && session.mode === 'subscription') {
  try {
    await sendWelcomeEmail({
      to: /* get user email */,
      plan,
      dashboardUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/${userId}`,
    });
  } catch (emailError) {
    // Log but don't fail webhook
    logWebhookError('Failed to send welcome email', emailError);
  }
}
```

---

### Success Criteria

#### Automated Verification:

- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Email template renders: `pnpm email`

#### Manual Verification:

- [ ] Test first-time subscription:
  - Sign up as new user (free plan)
  - Purchase Premium or Unlimited
  - Verify welcome email received

- [ ] Test plan upgrade (should NOT send welcome):
  - Upgrade from Premium to Unlimited
  - Verify NO welcome email (only change confirmation)

- [ ] Verify email content and rendering
- [ ] Test dashboard link works correctly

---

## Performance Considerations

### Email Sending Latency:
- Resend API typically responds in <500ms
- Email sending is non-blocking (doesn't delay webhook processing)
- Webhook timeout: 5 seconds (Stripe default)
- Email failure doesn't break webhook (logged only)

### Rate Limits:
- **Resend Free Tier**: 100 emails/day, 3,000 emails/month
- **Stripe Webhooks**: No rate limit on receiving
- **Expected Volume**:
  - Payment failures: ~2-5/month (3% of ~100 purchases)
  - Subscription changes: ~10-20/month
  - Welcome emails: ~50-100/month (new users)
  - **Total**: ~60-125 emails/month (well within free tier)

### Deliverability:
- Requires SPF/DKIM/DMARC configured for `handicappin.com`
- Monitor Resend Dashboard for bounce/complaint rates
- Keep bounce rate <2% to maintain sender reputation

---

## Migration Notes

**Not Applicable**: This is a new feature, no existing data to migrate.

**Backwards Compatibility**:
- All changes are additive (new files, new functions)
- Webhook handlers remain backwards compatible
- Email sending is optional (graceful degradation if Resend fails)

---

## Testing Strategy

### Unit Tests

**File**: `lib/email-service.test.ts` (new)

**Tests**:
- [ ] Email service initializes correctly
- [ ] `sendPaymentFailedEmail` formats amount correctly
- [ ] Error handling returns failure result (doesn't throw)
- [ ] Missing email address handled gracefully

**File**: `emails/payment-failed.test.tsx` (new)

**Tests**:
- [ ] Template renders without errors
- [ ] Amount formatting is correct for different currencies
- [ ] Portal URL is included in button
- [ ] Support email link is correct

---

### Integration Tests

**File**: `app/api/stripe/webhook/route.test.ts` (update existing)

**Tests**:
- [ ] `payment_intent.payment_failed` webhook sends email
- [ ] Email failure doesn't break webhook processing
- [ ] Missing user email handled gracefully
- [ ] Portal URL generation works

---

### Manual Testing Steps

#### 1. Email Template Development

```bash
# Start email dev server
pnpm email

# Navigate to http://localhost:3000
# View payment-failed template
# Test with different props (amount, currency, reason)
# Verify mobile rendering in preview
```

#### 2. Test Email Sending (Development)

```typescript
// Create test route: app/api/test-email/route.ts
import { sendTestEmail } from '@/lib/email-service';

export async function GET() {
  const result = await sendTestEmail('your-email@example.com');
  return Response.json(result);
}

// Visit: http://localhost:3000/api/test-email
// Check your inbox for test email
```

#### 3. Trigger Stripe Webhook (Test Mode)

```bash
# Install Stripe CLI: https://stripe.com/docs/stripe-cli
# Login
stripe login

# Forward webhooks to localhost
stripe listen --forward-to localhost:3000/api/stripe/webhook

# In another terminal, trigger payment failure
stripe trigger payment_intent.payment_failed

# Check:
# - Terminal output for webhook received
# - Application logs for email sent
# - Resend Dashboard for delivery confirmation
# - Your inbox for email
```

#### 4. Test Error Handling

```bash
# Temporarily set invalid Resend API key in .env.local
RESEND_API_KEY=invalid_key

# Trigger payment failure webhook again
stripe trigger payment_intent.payment_failed

# Verify:
# - Webhook still returns 200 (success)
# - Error logged but not thrown
# - Database updated correctly (purchase marked failed)
```

#### 5. Test Email Deliverability

- Send test email to multiple providers:
  - Gmail
  - Outlook
  - Apple Mail
  - Yahoo Mail

- Check spam folders
- Verify SPF/DKIM headers (view email source)
- Confirm branding displays correctly

---

## Monitoring & Metrics

### Key Metrics to Track

**Email Delivery**:
- Total emails sent (Resend Dashboard)
- Delivery rate (% successfully delivered)
- Bounce rate (hard bounces + soft bounces)
- Complaint rate (spam reports)

**User Impact**:
- Support tickets: "Why don't I have access?" (before/after Phase 1)
- Support tickets: "What plan am I on?" (before/after Phase 2)
- Email open rate (Resend Dashboard)
- Email click-through rate (portal URL, support links)

**Technical Health**:
- Email send failures (application logs)
- Webhook processing time (should remain <2s)
- Resend API errors (monitor Sentry)

### Alerts to Set Up

1. **Email Delivery Failure Rate > 5%**
   - Check Resend Dashboard
   - Investigate bounce reasons
   - Verify DNS configuration

2. **Resend API Errors in Sentry**
   - API key expired
   - Rate limit exceeded
   - Domain verification issues

3. **Support Ticket Spike**
   - If tickets increase after launch, investigate email content
   - Users may be confused by messaging

---

## Rollback Plan

If email notifications cause issues:

### Immediate Rollback (10 minutes):

1. **Disable email sending without deploying**:
   - Set environment variable: `DISABLE_PAYMENT_EMAILS=true`
   - Update `lib/email-service.ts` to check this flag
   - Emails stop, webhooks continue working

2. **Revert webhook handler changes**:
   ```bash
   git revert <commit-hash-of-email-integration>
   git push
   ```

### Data Cleanup (if needed):

- No database changes in Phase 1
- No data cleanup required
- Emails are stateless (no stored state)

---

## Success Criteria Summary

**Phase 1 is successful if**:
1. ‚úÖ Emails sent for all payment failures
2. ‚úÖ Webhook processing unaffected (<2s avg)
3. ‚úÖ Support tickets about "no access" reduce by >50%
4. ‚úÖ Email delivery rate >95%
5. ‚úÖ No increase in Stripe webhook errors

**Phase 2 is successful if**:
1. ‚úÖ All plan changes generate confirmation emails
2. ‚úÖ Support tickets about plan confusion reduce by >80%
3. ‚úÖ User feedback is positive (NPS surveys, support interactions)

**Phase 3 is successful if**:
1. ‚úÖ All new subscribers receive welcome email
2. ‚úÖ Feature adoption increases by >15%
3. ‚úÖ Email engagement rate >30% (opens)

---

## References

- **Original Ticket**: `.claude/tickets/0028-implement-payment-notification-emails.md`
- **Critical Analysis**: `.claude/plans/0028-implement-payment-notification-emails/critical-analysis.md`
- **Gap Analysis**: `.claude/plans/0028-implement-payment-notification-emails/transparency-gap-analysis.md`
- **Webhook Handler**: `app/api/stripe/webhook/route.ts:733` (handlePaymentIntentFailed)
- **Existing Email Templates**:
  - `supabase/functions/send-verification-email/email.tsx`
  - `supabase/functions/reset-password/email.tsx`
- **Stripe Docs**: [Payment status updates](https://docs.stripe.com/payments/payment-intents/verifying-status)
- **Resend Docs**: [Send emails](https://resend.com/docs/send-with-nodejs)

---

## Next Steps

1. **Review this plan** - Confirm phased approach is acceptable
2. **Verify Prerequisites**:
   - Resend domain verified in Resend Dashboard
   - SPF/DKIM DNS records published
   - `RESEND_API_KEY` available
3. **Implement Phase 1** (4-6 hours):
   - Set up email service
   - Create payment failed template
   - Integrate with webhook
   - Test thoroughly
4. **Monitor for 2-4 weeks**:
   - Track support ticket volume
   - Check email delivery metrics
   - Gather user feedback
5. **Decide on Phase 2**:
   - If Phase 1 reduces support tickets ‚Üí Proceed
   - If no change ‚Üí Investigate why before expanding

---

**Ready to begin implementation? Let me know if you'd like me to start with Phase 1, or if you have questions about any part of this plan.**
