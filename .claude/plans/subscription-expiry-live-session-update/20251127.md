# Live Session Update on Subscription Expiry - Implementation Plan

## Overview

Fix the issue where users with expired subscriptions continue to have access to premium pages (like `/dashboard`) until they manually navigate or refresh. Currently, when a subscription expires:
- ‚úÖ Database updates correctly
- ‚úÖ Webhook increments `billing_version`
- ‚úÖ BillingSync component refreshes JWT
- ‚ùå **User stays on page with access until manual navigation**

The root cause is that middleware only runs on route changes, and `router.refresh()` doesn't trigger middleware re-execution.

## Current State Analysis

### What Works:
- Stripe webhook updates database when subscription expires (middleware.ts:1367-1417)
- `billing_version` increments, triggering Realtime event
- BillingSync component (billing-sync.tsx:46-111) detects change
- JWT gets refreshed with new billing claims
- Middleware properly blocks access on next navigation (middleware.ts:246-250)

### What Doesn't Work:
- User already on `/dashboard` when subscription expires stays there
- `router.refresh()` only refreshes Server Components, not middleware
- No active session invalidation

### Key Discoveries:
- BillingSync is disabled in local dev (billing-sync.tsx:37-42) due to Realtime unavailability
- BillingSync is mounted in root layout (layout.tsx:36)
- Middleware uses JWT-only checks for performance (middleware.ts:221)
- Premium paths defined in constants.ts:20-22: `["/dashboard", "/calculators"]`

## Desired End State

When a subscription expires (via Stripe test clock or real expiration):
1. Database updates within seconds (webhook processing)
2. User's active session detects the change immediately
3. User is **automatically redirected** from premium pages to `/upgrade`
4. No manual refresh or navigation required

### Verification:
- Start on `/dashboard` with active subscription
- Cancel subscription and advance test clock past `current_period_end`
- Within 5-10 seconds, user is redirected to `/upgrade`
- User sees toast notification explaining why
- Attempting to navigate back to `/dashboard` redirects to `/upgrade`

## What We're NOT Doing

- Not implementing WebSocket-based real-time access checks (over-engineered)
- Not adding database queries to middleware (performance impact)
- Not using polling mechanisms (inefficient)
- Not removing the existing BillingSync component (it works for other scenarios)
- Not changing webhook handlers (they work correctly)

## Implementation Approach

Use a **multi-layered approach**:

1. **Enhanced BillingSync** - Detect access revocation and redirect immediately
2. **Access validation hook** - Client-side hook to check current page access after JWT refresh
3. **Server Component backstop** - Add database checks to premium pages as final safety net

This balances real-time UX with performance and reliability.

---

## Phase 1: Enhanced BillingSync with Active Redirect

### Overview
Modify BillingSync to actively check if the user's access was revoked after JWT refresh, and redirect them immediately if they're on a premium page they no longer have access to.

### Changes Required:

#### 1. Create Access Validation Utility

**File**: `utils/billing/validate-access.ts`
**Changes**: Create new file

```typescript
import { BillingClaims } from "@/utils/supabase/jwt";
import { PREMIUM_PATHS } from "@/utils/billing/constants";

const EXPIRY_LEEWAY_SECONDS = 120; // Match middleware

export interface AccessValidationResult {
  hasPremiumAccess: boolean;
  reason?: string; // Why access was denied
}

/**
 * Validates if user has premium access based on JWT billing claims
 * This mirrors the middleware logic (middleware.ts:177-215)
 */
export function validatePremiumAccess(
  billing: BillingClaims | null
): AccessValidationResult {
  if (!billing) {
    return { hasPremiumAccess: false, reason: "no_billing_claims" };
  }

  const { plan, status, current_period_end, cancel_at_period_end } = billing;

  // Check status-based denials
  if (status === "past_due" || status === "incomplete" || status === "paused") {
    return { hasPremiumAccess: false, reason: `status_${status}` };
  }

  // Check canceled status with grace period
  if (status === "canceled") {
    if (cancel_at_period_end && current_period_end) {
      const nowSeconds = Date.now() / 1000;
      const isExpired = nowSeconds > current_period_end + EXPIRY_LEEWAY_SECONDS;

      if (isExpired) {
        return { hasPremiumAccess: false, reason: "subscription_expired" };
      }
    } else {
      return { hasPremiumAccess: false, reason: "subscription_canceled" };
    }
  }

  // Check expiry
  if (current_period_end && Date.now() / 1000 > current_period_end + EXPIRY_LEEWAY_SECONDS) {
    return { hasPremiumAccess: false, reason: "subscription_expired" };
  }

  // Check plan type
  const hasPremiumAccess = plan === "premium" || plan === "unlimited" || plan === "lifetime";

  if (!hasPremiumAccess) {
    return { hasPremiumAccess: false, reason: "insufficient_plan" };
  }

  return { hasPremiumAccess: true };
}

/**
 * Check if the given pathname is a premium route
 */
export function isPremiumRoute(pathname: string): boolean {
  return PREMIUM_PATHS.some((path) => pathname.startsWith(path));
}
```

#### 2. Enhance BillingSync Component

**File**: `components/billing-sync.tsx`
**Changes**: Add access validation and redirect logic after JWT refresh

```typescript
// Add imports
import { getBillingFromJWT } from "@/utils/supabase/jwt";
import { validatePremiumAccess, isPremiumRoute } from "@/utils/billing/validate-access";
import { usePathname } from "next/navigation";
import { useToast } from "@/hooks/use-toast";

// Inside the component, after router declaration:
const pathname = usePathname();
const { toast } = useToast();

// Replace the JWT refresh logic (lines 77-94) with:
try {
  // Force JWT refresh to get new billing claims
  const { data, error } = await supabase.auth.refreshSession();

  if (error) {
    console.error("‚ùå JWT refresh failed:", error);
    return;
  }

  if (data.session) {
    console.log("‚úÖ JWT refreshed with new billing data");

    // Extract new billing claims
    const newBilling = getBillingFromJWT(data.session);
    const accessCheck = validatePremiumAccess(newBilling);

    console.log("üîê Access validation result:", accessCheck);

    // Check if user lost access while on a premium page
    const currentlyOnPremiumPage = isPremiumRoute(pathname);

    if (currentlyOnPremiumPage && !accessCheck.hasPremiumAccess) {
      console.warn("‚ö†Ô∏è Access revoked while on premium page - redirecting to /upgrade");

      // Show user-friendly notification
      toast({
        title: "Subscription Expired",
        description: "Your premium access has ended. Please upgrade to continue.",
        variant: "destructive",
      });

      // Redirect to upgrade page
      router.push("/upgrade");
      return; // Don't call router.refresh() - we're navigating away
    }

    // Refresh server components to reflect new JWT claims
    router.refresh();
  }
} catch (err) {
  console.error("‚ùå Error during JWT refresh:", err);
}
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] Start authenticated session with active premium subscription
- [ ] Navigate to `/dashboard`
- [ ] Using Stripe test clock, advance time past `current_period_end`
- [ ] Within 10 seconds, user is redirected to `/upgrade`
- [ ] User sees toast notification about subscription expiration
- [ ] Attempting to navigate back to `/dashboard` redirects to `/upgrade` (middleware)
- [ ] Console shows: `‚ö†Ô∏è Access revoked while on premium page - redirecting to /upgrade`

---

## Phase 2: Periodic Access Re-validation Hook

### Overview
Create a React hook that periodically re-validates access on premium pages as a backstop. This handles edge cases where Realtime events might be missed (network issues, Supabase outages, etc.).

### Changes Required:

#### 1. Create Periodic Access Check Hook

**File**: `hooks/use-premium-access-guard.ts`
**Changes**: Create new file

```typescript
"use client";

import { useEffect, useRef } from "react";
import { useRouter, usePathname } from "next/navigation";
import { createClientComponentClient } from "@/utils/supabase/client";
import { getBillingFromJWT } from "@/utils/supabase/jwt";
import { validatePremiumAccess, isPremiumRoute } from "@/utils/billing/validate-access";
import { useToast } from "@/hooks/use-toast";

const REVALIDATION_INTERVAL_MS = 60000; // 1 minute

/**
 * Hook that periodically checks if the user still has premium access
 * Only runs when on a premium page
 * Redirects to /upgrade if access is lost
 */
export function usePremiumAccessGuard() {
  const router = useRouter();
  const pathname = usePathname();
  const supabase = createClientComponentClient();
  const { toast } = useToast();
  const lastCheckRef = useRef<number>(0);

  useEffect(() => {
    // Only run on premium pages
    if (!isPremiumRoute(pathname)) {
      return;
    }

    console.log("üîê Premium access guard active on", pathname);

    const checkAccess = async () => {
      try {
        // Get current session (uses cached session, doesn't hit server)
        const { data: { session } } = await supabase.auth.getSession();

        if (!session) {
          console.warn("‚ö†Ô∏è No session found - redirecting to login");
          router.push("/login");
          return;
        }

        // Validate access using JWT claims
        const billing = getBillingFromJWT(session);
        const accessCheck = validatePremiumAccess(billing);

        if (!accessCheck.hasPremiumAccess) {
          console.warn("‚ö†Ô∏è Premium access check failed:", accessCheck.reason);

          toast({
            title: "Access Denied",
            description: "Your premium access has expired. Redirecting...",
            variant: "destructive",
          });

          router.push("/upgrade");
        } else {
          console.log("‚úÖ Premium access confirmed");
        }
      } catch (error) {
        console.error("‚ùå Error checking premium access:", error);
      }

      lastCheckRef.current = Date.now();
    };

    // Initial check
    checkAccess();

    // Periodic re-validation
    const interval = setInterval(checkAccess, REVALIDATION_INTERVAL_MS);

    return () => {
      clearInterval(interval);
      console.log("üîê Premium access guard disabled");
    };
  }, [pathname, router, supabase, toast]);
}
```

#### 2. Add Hook to Premium Pages

**File**: `app/dashboard/[id]/page.tsx`
**Changes**: Add hook at the top of the component

```typescript
// Add import
import { usePremiumAccessGuard } from "@/hooks/use-premium-access-guard";

// Inside the Dashboard component (client component wrapper):
export function DashboardClient({ /* props */ }) {
  usePremiumAccessGuard(); // Add this line

  // ... rest of component
}
```

**File**: `app/calculators/page.tsx` (if exists)
**Changes**: Same as above

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] User on `/dashboard` with active subscription
- [ ] Console shows: `üîê Premium access guard active on /dashboard`
- [ ] Every 60 seconds, console shows: `‚úÖ Premium access confirmed`
- [ ] Manually expire subscription in database (UPDATE profile SET subscription_status='canceled', current_period_end=0)
- [ ] Within 60 seconds, user is redirected to `/upgrade`
- [ ] User sees toast notification
- [ ] Hook stops running after redirect (console shows: `üîê Premium access guard disabled`)

---

## Phase 3: Server Component Access Backstop

### Overview
Add database-level access checks to premium page Server Components as a final safety net. This catches any case where client-side checks fail.

### Changes Required:

#### 1. Create Server-Side Access Check Utility

**File**: `utils/billing/server-access-check.ts`
**Changes**: Create new file

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import { getComprehensiveUserAccess } from "@/utils/billing/access-control";

/**
 * Server-side premium access check for page-level protection
 * Redirects to /upgrade if access is denied
 *
 * Use this in Server Components as a backstop to middleware
 */
export async function requirePremiumAccess(userId: string): Promise<void> {
  const access = await getComprehensiveUserAccess(userId);

  if (!access.hasPremiumAccess) {
    console.warn(`‚ö†Ô∏è Server-side access check failed for user ${userId} - redirecting to /upgrade`);
    redirect("/upgrade");
  }

  console.log(`‚úÖ Server-side access check passed for user ${userId}`);
}

/**
 * Get current user or redirect to login
 */
export async function requireAuth() {
  const supabase = await createServerComponentClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  return user;
}
```

#### 2. Add Server-Side Check to Dashboard Page

**File**: `app/dashboard/[id]/page.tsx`
**Changes**: Add access check at the top of the page component

```typescript
// Add imports
import { requireAuth, requirePremiumAccess } from "@/utils/billing/server-access-check";

// At the start of the page component (Server Component):
export default async function DashboardPage({ params }: { params: { id: string } }) {
  // Require authentication
  const user = await requireAuth();

  // Require premium access (backstop to middleware)
  await requirePremiumAccess(user.id);

  // ... rest of existing code
}
```

#### 3. Add Server-Side Check to Calculators Page (if exists)

**File**: `app/calculators/page.tsx`
**Changes**: Same as above

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] User with active subscription can access `/dashboard`
- [ ] Console shows: `‚úÖ Server-side access check passed for user ${userId}`
- [ ] User with expired subscription is redirected to `/upgrade` before page renders
- [ ] Console shows: `‚ö†Ô∏è Server-side access check failed for user ${userId} - redirecting to /upgrade`
- [ ] Direct navigation to `/dashboard` (bypassing middleware somehow) still results in redirect
- [ ] No flash of premium content before redirect

---

## Phase 4: Enable BillingSync in Local Development (Optional)

### Overview
Enable BillingSync in local development to allow testing of real-time session updates. Requires Supabase Realtime to be available locally.

### Changes Required:

#### 1. Update BillingSync Local Dev Check

**File**: `components/billing-sync.tsx`
**Changes**: Add environment variable override

```typescript
// Replace lines 36-42 with:
const isLocalDev = process.env.NEXT_PUBLIC_SUPABASE_URL?.includes('127.0.0.1');
const forceEnableBillingSync = process.env.NEXT_PUBLIC_ENABLE_BILLING_SYNC === 'true';

if (isLocalDev && !forceEnableBillingSync) {
  console.log(`üîÑ BillingSync: Skipped in local dev (set NEXT_PUBLIC_ENABLE_BILLING_SYNC=true to enable)`);
  return;
}
```

#### 2. Update Environment Variables

**File**: `.env.local` or `.env.development`
**Changes**: Add flag to enable BillingSync

```bash
# Enable BillingSync in local development (requires Supabase Realtime)
NEXT_PUBLIC_ENABLE_BILLING_SYNC=true
```

#### 3. Document Requirements

**File**: `README.md` (or developer docs)
**Changes**: Add section on local development setup

```markdown
## Testing Subscription Expiry Locally

To test real-time subscription expiry updates in local development:

1. Ensure Supabase Realtime is enabled in `supabase/config.toml`
2. Set `NEXT_PUBLIC_ENABLE_BILLING_SYNC=true` in `.env.local`
3. Restart the dev server
4. Use Stripe test clock to advance time past subscription end
5. Observe automatic redirect to `/upgrade` within 10 seconds

Note: Without this flag, BillingSync is disabled locally and you must manually refresh to see changes.
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] With `NEXT_PUBLIC_ENABLE_BILLING_SYNC=true`, BillingSync runs locally
- [ ] Console shows: `üîÑ BillingSync mounted for user ${userId}`
- [ ] Without the flag, BillingSync is skipped
- [ ] Console shows: `üîÑ BillingSync: Skipped in local dev (set NEXT_PUBLIC_ENABLE_BILLING_SYNC=true to enable)`

---

## Testing Strategy

### Unit Tests:
- Test `validatePremiumAccess()` with various billing claim states
  - Active subscription ‚Üí `hasPremiumAccess: true`
  - Expired subscription ‚Üí `hasPremiumAccess: false, reason: "subscription_expired"`
  - Canceled with grace period ‚Üí `hasPremiumAccess: true`
  - Canceled past grace period ‚Üí `hasPremiumAccess: false`
  - Past due status ‚Üí `hasPremiumAccess: false`
- Test `isPremiumRoute()` with various pathnames
  - `/dashboard` ‚Üí true
  - `/dashboard/123` ‚Üí true
  - `/calculators` ‚Üí true
  - `/profile` ‚Üí false
  - `/upgrade` ‚Üí false

### Integration Tests:
- Test webhook ‚Üí Realtime ‚Üí BillingSync ‚Üí Redirect flow
  1. Create active subscription
  2. Navigate to `/dashboard`
  3. Trigger `customer.subscription.deleted` webhook
  4. Verify database updates
  5. Verify BillingSync detects change
  6. Verify redirect to `/upgrade`
  7. Verify toast notification appears

### Manual Testing Steps:

#### Test 1: Real-time Redirect on Subscription Expiry
1. Create user with active premium subscription
2. Login and navigate to `/dashboard`
3. Open browser console to monitor logs
4. Using Stripe test clock, cancel subscription and advance past `current_period_end`
5. Verify:
   - Within 10 seconds, automatic redirect to `/upgrade`
   - Toast notification appears: "Subscription Expired"
   - Console shows: `üîÑ Billing update detected, refreshing JWT...`
   - Console shows: `‚ö†Ô∏è Access revoked while on premium page - redirecting to /upgrade`
6. Attempt to navigate back to `/dashboard`
7. Verify middleware redirects to `/upgrade` immediately

#### Test 2: Periodic Access Guard
1. Create user with active premium subscription
2. Login and navigate to `/dashboard`
3. Wait for console log: `üîê Premium access guard active on /dashboard`
4. Wait 60 seconds, verify console log: `‚úÖ Premium access confirmed`
5. Manually update database: `UPDATE profile SET subscription_status='canceled', current_period_end=0 WHERE id='${userId}'`
6. Do NOT increment `billing_version` (simulates Realtime failure)
7. Within 60 seconds, verify redirect to `/upgrade`
8. Verify toast notification appears

#### Test 3: Server Component Backstop
1. Create user with expired subscription
2. Manually navigate to `/dashboard/123` (typing URL)
3. Verify immediate redirect to `/upgrade` with no flash of content
4. Check server logs for: `‚ö†Ô∏è Server-side access check failed for user ${userId}`
5. Create user with active subscription
6. Navigate to `/dashboard/123`
7. Check server logs for: `‚úÖ Server-side access check passed for user ${userId}`

#### Test 4: Edge Case - Network Offline
1. User on `/dashboard` with active subscription
2. Disconnect network (dev tools ‚Üí Network ‚Üí Offline)
3. Subscription expires (advance test clock)
4. Verify BillingSync fails gracefully (console error logged)
5. Reconnect network
6. Within 10 seconds, verify redirect to `/upgrade`

#### Test 5: Edge Case - Supabase Realtime Outage
1. User on `/dashboard` with active subscription
2. Simulate Realtime outage (stop local Supabase or block Realtime endpoint)
3. Subscription expires
4. Verify periodic access guard catches it within 60 seconds
5. Verify redirect to `/upgrade`

## Performance Considerations

### Impact Assessment:
- **BillingSync**: Minimal overhead (only runs when Realtime event fires)
- **Periodic Access Guard**: ~1 getSession() call per minute per premium page
  - Uses cached session (no network request)
  - JWT decoding is fast (<1ms)
  - No database queries
- **Server Component Check**: +1 database query per premium page load
  - Only runs on initial page load
  - Uses existing `getComprehensiveUserAccess()` function
  - Acceptable tradeoff for security

### Optimization:
- Periodic guard interval is configurable (default 60s)
- Could increase to 120s if needed
- Could disable entirely if Realtime is reliable enough

## Migration Notes

### Backwards Compatibility:
- All changes are additive (no breaking changes)
- Existing webhook handlers unchanged
- Existing middleware logic unchanged
- BillingSync enhanced but still backwards compatible

### Deployment Strategy:
1. Deploy Phase 1 (Enhanced BillingSync) first
2. Monitor for 24 hours
3. Deploy Phase 2 (Periodic Guard) as safety net
4. Deploy Phase 3 (Server Backstop) last
5. Phase 4 (Local Dev) is optional per developer

### Rollback Plan:
- If issues occur, revert `billing-sync.tsx` to remove redirect logic
- Periodic guard can be disabled by removing hook calls
- Server backstop can be removed from page components
- No database migrations required (all logic changes)

## References

- Original issue: Subscription cancellation access control
- Related files:
  - `/Users/sebastiansole/local/handicappin/components/billing-sync.tsx` - Realtime sync component
  - `/Users/sebastiansole/local/handicappin/utils/supabase/middleware.ts` - Access control middleware
  - `/Users/sebastiansole/local/handicappin/app/api/stripe/webhook/route.ts` - Webhook handlers
  - `/Users/sebastiansole/local/handicappin/utils/billing/constants.ts` - Premium paths definition
  - `/Users/sebastiansole/local/handicappin/utils/billing/access-control.ts` - Database access checks
- Middleware JWT logic: middleware.ts:177-215
- Premium path check: middleware.ts:242-250
- Webhook subscription deletion: webhook/route.ts:1367-1417
