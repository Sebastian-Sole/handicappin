# Live Session Update on Subscription Expiry - Implementation Plan (v2)

## Overview

Fix the critical issue where users retain premium access even after subscription expiry, regardless of page navigation or hard refresh. The root cause is that **client-side JWT refresh doesn't update server-side cookies**, so middleware continues to see stale billing claims.

## Root Cause Analysis

### The Problem Flow:

1. ‚úÖ User has active subscription with JWT containing `plan: "premium"`, `status: "active"`
2. ‚úÖ Subscription expires ‚Üí Stripe webhook updates database
3. ‚úÖ `billing_version` increments ‚Üí Supabase Realtime fires event
4. ‚úÖ BillingSync (client-side) calls `supabase.auth.refreshSession()`
5. ‚úÖ New JWT is issued with `plan: "free"`, `status: "canceled"`
6. ‚ùå **BUT** - Client-side refresh doesn't update HTTP-only cookies
7. ‚ùå Middleware still reads **old JWT** from cookies on next request
8. ‚ùå User continues to have access to `/dashboard` indefinitely

### Why This Happens:

- **BillingSync is client-side** (components/billing-sync.tsx)
- **Cookies are HTTP-only** (set by server, not accessible to JavaScript)
- **`router.refresh()` doesn't trigger cookie update** - it only refreshes Server Components
- **Supabase SSR cookie management requires server action** to update cookies

### Key Discovery:

Supabase SSR docs state: "After refreshing the session client-side, you must make a request to the server to update the cookies." This is the missing piece!

## Current State Analysis

### What Works:
- Webhook handler updates database correctly (webhook/route.ts:1367-1417)
- `billing_version` increments properly
- BillingSync detects changes via Realtime (billing-sync.tsx:46-111)
- JWT custom claims hook runs on token refresh (config.toml:142-144)
- Middleware logic for access control is correct (middleware.ts:142-250)

### What Doesn't Work:
- Client-side `refreshSession()` doesn't update server cookies
- Middleware reads stale JWT from cookies
- No mechanism to force server-side cookie update
- User retains access until they manually log out or JWT expires (1 hour)

### Key Files:
- `components/billing-sync.tsx` - Client-side Realtime listener
- `utils/supabase/middleware.ts` - Server-side access control (reads cookies)
- `app/api/stripe/webhook/route.ts` - Updates database
- `supabase/migrations/*_fix_jwt_hook_null_handling.sql` - Custom claims hook

## Desired End State

When a subscription expires:
1. Database updates within seconds (webhook)
2. BillingSync detects change via Realtime
3. **Server-side API route is called** to refresh cookies
4. User is immediately redirected to `/upgrade` (if on premium page)
5. Middleware blocks future premium access with updated JWT

### Verification:
- User on `/dashboard` with active subscription
- Cancel subscription, advance test clock past expiry
- Within 10 seconds: automatic redirect to `/upgrade`
- User sees toast notification
- **Hard refresh** or **navigation** still blocks access (middleware works)
- Console shows cookie refresh success

## What We're NOT Doing

- Not removing BillingSync component (it's the right trigger mechanism)
- Not changing webhook handlers (they work correctly)
- Not modifying middleware logic (it's correct, just uses stale data)
- Not using polling (inefficient and unnecessary)
- Not implementing WebSocket-based access checks (over-engineered)

## Implementation Approach

**Solution:** Create a server-side API route that refreshes the session and updates cookies, then call it from BillingSync after detecting billing changes.

This approach:
- Uses existing Realtime trigger (BillingSync)
- Forces server-side cookie update via API route
- Triggers middleware re-evaluation on next navigation
- Works with Next.js App Router SSR architecture

---

## Phase 1: Server-Side Session Refresh API

### Overview
Create an API route that refreshes the session server-side and updates HTTP-only cookies. This ensures middleware sees the latest JWT claims.

### Changes Required:

#### 1. Create Session Refresh API Route

**File**: `app/api/auth/sync-session/route.ts`
**Changes**: Create new file

```typescript
import { createServerComponentClient } from "@/utils/supabase/server";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";

/**
 * Server-side session refresh endpoint
 *
 * Called by BillingSync (client-side) after detecting billing changes.
 * Refreshes the session server-side to update HTTP-only cookies.
 *
 * This ensures middleware sees the latest JWT claims on next request.
 */
export async function POST() {
  try {
    const supabase = await createServerComponentClient();

    // Refresh session server-side (this updates cookies)
    const { data, error } = await supabase.auth.refreshSession();

    if (error) {
      console.error("‚ùå Server-side session refresh failed:", error);
      return NextResponse.json(
        { error: "Session refresh failed", details: error.message },
        { status: 500 }
      );
    }

    if (!data.session) {
      console.error("‚ùå No session returned from refresh");
      return NextResponse.json(
        { error: "No session found" },
        { status: 401 }
      );
    }

    // Extract billing claims from new JWT
    const billing = data.session.user.app_metadata?.billing;

    console.log("‚úÖ Server-side session refreshed successfully", {
      userId: data.session.user.id,
      plan: billing?.plan,
      status: billing?.status,
      billingVersion: billing?.billing_version,
    });

    return NextResponse.json({
      success: true,
      billing: billing || null,
    });
  } catch (error) {
    console.error("‚ùå Unexpected error in session sync:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `pnpm build`
- [x] No linting errors: `pnpm lint`
- [ ] Route is accessible: `curl -X POST http://localhost:3000/api/auth/sync-session -H "Cookie: <session-cookie>"`

#### Manual Verification:
- [ ] Calling endpoint with valid session returns `{ success: true, billing: {...} }`
- [ ] Calling endpoint without session returns `401`
- [ ] Console shows: `‚úÖ Server-side session refreshed successfully`
- [ ] Cookies are updated in browser DevTools ‚Üí Application ‚Üí Cookies
- [ ] Subsequent middleware calls see new JWT claims

---

## Phase 2: Enhanced BillingSync with Server-Side Refresh

### Overview
Modify BillingSync to call the server-side refresh API after detecting billing changes, ensuring cookies are updated before attempting redirect.

### Changes Required:

#### 1. Update BillingSync Component

**File**: `components/billing-sync.tsx`
**Changes**: Replace JWT refresh logic (lines 77-94)

```typescript
// Add imports at top of file
import { getBillingFromJWT } from "@/utils/supabase/jwt";
import { useToast } from "@/hooks/use-toast";
import { usePathname } from "next/navigation";
import { PREMIUM_PATHS } from "@/utils/billing/constants";

// Inside component, add these hooks after router:
const pathname = usePathname();
const { toast } = useToast();

// Replace the try/catch block (lines 77-94) with:
try {
  console.log("üîÑ Detected billing update - refreshing session...");

  // Step 1: Refresh client-side session first
  const { data: clientData, error: clientError } = await supabase.auth.refreshSession();

  if (clientError) {
    console.error("‚ùå Client-side JWT refresh failed:", clientError);
    return;
  }

  console.log("‚úÖ Client-side JWT refreshed");

  // Step 2: Force server-side cookie update via API route
  try {
    const response = await fetch("/api/auth/sync-session", {
      method: "POST",
      credentials: "include", // Include cookies
    });

    if (!response.ok) {
      console.error("‚ùå Server-side session sync failed:", response.status);
      // Continue anyway - client-side refresh may be enough
    } else {
      const result = await response.json();
      console.log("‚úÖ Server-side session synced, new billing:", result.billing);
    }
  } catch (fetchError) {
    console.error("‚ùå Failed to call sync-session API:", fetchError);
    // Continue anyway - client-side refresh may be enough
  }

  // Step 3: Check if user lost premium access while on a premium page
  const newBilling = getBillingFromJWT(clientData.session);
  const isOnPremiumPage = PREMIUM_PATHS.some((path) => pathname.startsWith(path));

  if (newBilling) {
    const { plan, status, current_period_end, cancel_at_period_end } = newBilling;

    // Determine if user has premium access (mirrors middleware logic)
    let hasPremiumAccess = false;

    if (status === "past_due" || status === "incomplete" || status === "paused") {
      hasPremiumAccess = false;
    } else if (status === "canceled") {
      if (cancel_at_period_end && current_period_end) {
        const nowSeconds = Date.now() / 1000;
        const EXPIRY_LEEWAY_SECONDS = 120; // Match middleware
        const isExpired = nowSeconds > current_period_end + EXPIRY_LEEWAY_SECONDS;
        hasPremiumAccess = !isExpired && (plan === "premium" || plan === "unlimited" || plan === "lifetime");
      } else {
        hasPremiumAccess = false;
      }
    } else if (current_period_end && Date.now() / 1000 > current_period_end + 120) {
      hasPremiumAccess = false;
    } else {
      hasPremiumAccess = plan === "premium" || plan === "unlimited" || plan === "lifetime";
    }

    console.log("üîê Access check:", { hasPremiumAccess, isOnPremiumPage, plan, status });

    // Step 4: Redirect if access was revoked while on premium page
    if (isOnPremiumPage && !hasPremiumAccess) {
      console.warn("‚ö†Ô∏è Access revoked while on premium page - redirecting to /upgrade");

      toast({
        title: "Subscription Expired",
        description: "Your premium access has ended. Please upgrade to continue.",
        variant: "destructive",
      });

      // Redirect to upgrade page
      router.push("/upgrade");
      return; // Don't call router.refresh() - we're navigating
    }
  }

  // Step 5: Refresh server components to reflect new JWT
  router.refresh();

  console.log("‚úÖ Billing sync complete");
} catch (err) {
  console.error("‚ùå Error during billing sync:", err);
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] User on `/dashboard` with active subscription
- [ ] Advance test clock past subscription expiry
- [ ] Within 10 seconds, console shows:
  - `üîÑ Billing update detected, refreshing JWT...`
  - `‚úÖ Client-side JWT refreshed`
  - `‚úÖ Server-side session synced, new billing: {...}`
  - `üîê Access check: { hasPremiumAccess: false, ... }`
  - `‚ö†Ô∏è Access revoked while on premium page - redirecting to /upgrade`
- [ ] User is redirected to `/upgrade`
- [ ] Toast notification appears
- [ ] Browser cookies are updated (DevTools ‚Üí Application ‚Üí Cookies)

---

## Phase 3: Verify Middleware Blocks Access

### Overview
Test that middleware correctly blocks access after server-side session sync, ensuring the fix is complete.

### Changes Required:

No code changes needed - this is pure verification.

### Testing Steps:

#### Test 1: Hard Refresh After Expiry
1. User on `/dashboard` with active subscription
2. Open browser DevTools ‚Üí Network tab
3. Trigger subscription expiry (test clock)
4. Wait for BillingSync to sync (10 seconds)
5. **Hard refresh the page** (Cmd+Shift+R or Ctrl+F5)
6. Verify middleware redirects to `/upgrade` (Network tab shows 307 redirect)
7. Console shows: `‚ö†Ô∏è Subscription canceled (immediate) for user ${userId}`
8. User lands on `/upgrade` page

#### Test 2: Navigation After Expiry
1. User on `/dashboard` with active subscription
2. Trigger subscription expiry
3. Wait for BillingSync to sync
4. **Navigate to a different page** (e.g., `/profile`)
5. Then try to navigate back to `/dashboard`
6. Verify middleware redirects to `/upgrade` immediately
7. No flash of dashboard content

#### Test 3: Direct URL After Expiry
1. User with expired subscription
2. Manually type `/dashboard` in address bar
3. Verify middleware redirects to `/upgrade` before page loads
4. Server logs show: `‚ö†Ô∏è Subscription canceled (immediate) for user ${userId}`

### Success Criteria:

#### Automated Verification:
- [ ] No code changes needed for this phase

#### Manual Verification:
- [ ] Hard refresh after expiry ‚Üí redirect to `/upgrade`
- [ ] Navigation after expiry ‚Üí redirect to `/upgrade`
- [ ] Direct URL access after expiry ‚Üí redirect to `/upgrade`
- [ ] Middleware logs show correct billing claims after sync
- [ ] No premium content flashes before redirect
- [ ] Cookies contain updated JWT (check in DevTools)

---

## Phase 4: Add Diagnostic Logging

### Overview
Add logging to help debug issues in production and verify the fix is working correctly.

### Changes Required:

#### 1. Add Logging to Webhook Handler

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add log after billing_version increment (around line 1407)

```typescript
// After the database update in handleSubscriptionDeleted:
await db.update(profile).set({
  planSelected: "free",
  planSelectedAt: new Date(),
  subscriptionStatus: "canceled",
  currentPeriodEnd: null,
  cancelAtPeriodEnd: false,
  billingVersion: sql`billing_version + 1`,
}).where(eq(profile.id, userId));

logWebhookSuccess(`Reverted to free tier for user: ${userId}`);

// ADD THIS:
console.log(`üìä [Webhook] Billing version incremented for user ${userId} - BillingSync should detect within seconds`);
```

#### 2. Add Logging to Middleware

**File**: `utils/supabase/middleware.ts`
**Changes**: Enhance existing logs (around line 170)

```typescript
// After extracting billing claims (around line 170):
console.log(`‚úÖ JWT Auth: plan=${billing.plan}, status=${billing.status}, user=${enrichedUser.id}, version=${billing.billing_version}`);
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] Webhook logs show: `üìä [Webhook] Billing version incremented for user ${userId}`
- [ ] Middleware logs show billing version in access checks
- [ ] BillingSync logs correlate with webhook/middleware logs
- [ ] Full trace visible in production logs (Vercel/Railway/etc.)

---

## Testing Strategy

### Unit Tests:

Not applicable - this fix is primarily about cookie/session management which requires integration testing.

### Integration Tests:

#### Test Case 1: Subscription Expiry Flow
1. Create user with active premium subscription
2. Login and navigate to `/dashboard`
3. Open 3 browser tabs, all on `/dashboard`
4. Trigger `customer.subscription.deleted` webhook
5. Verify all 3 tabs:
   - Detect billing change within 10 seconds
   - Redirect to `/upgrade`
   - Show toast notification
6. Verify subsequent navigation is blocked by middleware

#### Test Case 2: Graceful Cancellation
1. Create user with active subscription
2. Set `cancel_at_period_end = true`
3. User should retain access until `current_period_end + 120s`
4. After expiry, verify redirect to `/upgrade`

#### Test Case 3: Network Failure Resilience
1. User on `/dashboard` with active subscription
2. Block network (DevTools ‚Üí Network ‚Üí Offline)
3. Trigger subscription expiry
4. Verify BillingSync fails gracefully (console error)
5. Restore network
6. Verify session sync within 10 seconds

### Manual Testing Steps:

#### Full End-to-End Test (Stripe Test Clock):
1. **Setup:**
   - Create Stripe test customer
   - Create premium subscription
   - Login to app
   - Navigate to `/dashboard`
   - Open browser console

2. **Trigger Expiry:**
   - Open Stripe Dashboard ‚Üí Test Clocks
   - Advance clock past `current_period_end`
   - Watch console logs

3. **Verify Flow:**
   - Within 10 seconds, see logs:
     - `üîÑ Billing update detected, refreshing JWT...` (BillingSync)
     - `‚úÖ Client-side JWT refreshed` (BillingSync)
     - `‚úÖ Server-side session synced` (BillingSync)
     - `‚ö†Ô∏è Access revoked while on premium page - redirecting` (BillingSync)
   - User redirected to `/upgrade`
   - Toast notification appears

4. **Verify Middleware:**
   - Hard refresh on `/dashboard`
   - See middleware redirect (Network tab: 307)
   - Server logs show: `‚ö†Ô∏è Subscription canceled (immediate) for user ${userId}`

5. **Verify Persistence:**
   - Close browser
   - Reopen and login
   - Try to access `/dashboard`
   - Verify immediate redirect to `/upgrade`

### Edge Cases to Test:

1. **User on non-premium page when subscription expires**
   - Should not redirect immediately
   - Should block premium access on next navigation attempt

2. **Multiple simultaneous billing changes**
   - Rapid webhook events shouldn't cause race conditions
   - BillingSync should handle multiple `billing_version` changes gracefully

3. **User has multiple tabs open**
   - All tabs should detect change via Realtime
   - All tabs should redirect simultaneously

4. **Supabase Realtime outage**
   - BillingSync won't detect change
   - But middleware will block on next navigation (JWT expires in 1 hour max)
   - Consider adding periodic polling as fallback (future enhancement)

## Performance Considerations

### Impact Assessment:

**Added Overhead:**
- +1 API call per billing change detected (POST /api/auth/sync-session)
- This is a **rare event** (only when subscription changes)
- No performance impact on normal page loads

**Latency:**
- Server-side session refresh: ~50-100ms
- Total sync time (Realtime ‚Üí Client refresh ‚Üí Server sync ‚Üí Redirect): ~5-10 seconds
- Acceptable for rare billing change events

**Optimization:**
- Server-side refresh is only called when billing changes
- No polling or periodic checks
- Middleware remains JWT-only (no database queries)

## Migration Notes

### Backwards Compatibility:
- All changes are additive (no breaking changes)
- Existing middleware logic unchanged
- Existing webhook handlers unchanged
- BillingSync enhanced but remains backwards compatible

### Deployment Strategy:
1. Deploy Phase 1 (API route) first
2. Deploy Phase 2 (BillingSync update) immediately after
3. Monitor logs for 24 hours
4. Run manual tests with Stripe test clock
5. Deploy Phase 4 (logging) for production monitoring

### Rollback Plan:
- If issues occur, revert `billing-sync.tsx` to remove API call
- API route can remain (harmless if not called)
- No database migrations (all logic changes)
- Worst case: users wait until JWT expires (1 hour) to lose access

## Known Limitations

1. **JWT Expiry Window:**
   - If Realtime fails AND BillingSync doesn't run, user retains access until JWT expires (max 1 hour)
   - Mitigation: Add periodic polling as fallback (future enhancement)

2. **Local Development:**
   - BillingSync is disabled in local dev (Realtime unavailable)
   - Must test in deployed environment or enable Realtime locally
   - Add `NEXT_PUBLIC_ENABLE_BILLING_SYNC=true` to force enable (Phase 5 from previous plan)

3. **Race Condition:**
   - User might briefly see premium content before redirect completes
   - Acceptable UX tradeoff for real-time updates
   - Can add loading state if needed (future enhancement)

## Future Enhancements (Out of Scope)

1. **Periodic Polling Fallback:**
   - Add 60-second interval check for premium access
   - Catches edge cases where Realtime fails
   - See previous plan Phase 2 for implementation

2. **Server Component Access Checks:**
   - Add database queries to premium pages as final backstop
   - See previous plan Phase 3 for implementation

3. **WebSocket Health Monitoring:**
   - Detect when Realtime connection is lost
   - Show warning banner to user
   - Force manual refresh if disconnected > 5 minutes

## References

- Supabase SSR Docs: https://supabase.com/docs/guides/auth/server-side/nextjs
- Supabase Session Refresh: https://supabase.com/docs/reference/javascript/auth-refreshsession
- Next.js Middleware: https://nextjs.org/docs/app/building-your-application/routing/middleware
- Original issue: Subscription cancellation not revoking access immediately
- Related files:
  - `components/billing-sync.tsx` - Client-side Realtime listener
  - `utils/supabase/middleware.ts` - Server-side access control
  - `app/api/stripe/webhook/route.ts` - Webhook handlers
  - `supabase/config.toml` - JWT hook configuration
