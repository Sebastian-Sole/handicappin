# Verify Payment Status Before Granting Lifetime Access - Implementation Plan

## Overview

This plan addresses a medium-high security vulnerability where the webhook handler grants lifetime plan access immediately upon `checkout.session.completed` without verifying that payment has actually succeeded. For delayed payment methods (bank transfers, pending cards), this could allow users to receive lifetime access before payment completes or even if payment fails.

We will add payment status verification to ensure access is only granted after confirmed payment by:
1. Adding a `pending_lifetime_purchases` table to track pending payments
2. Checking `session.payment_status` in the checkout handler
3. Implementing a `payment_intent.succeeded` handler to grant access after delayed payments confirm
4. Implementing a `payment_intent.payment_failed` handler for failed payment cleanup

## Current State Analysis

**Vulnerability Location**: `app/api/stripe/webhook/route.ts:232-283`

The current `handleCheckoutCompleted` function (lines 184-283) processes lifetime purchases in payment mode without checking `session.payment_status`:

```typescript
// For payment mode (lifetime), update plan immediately
if (session.mode === "payment") {
  logPaymentEvent("Payment mode detected - processing lifetime plan");

  // ... fetches line items and price ID ...

  if (plan) {
    await db.update(profile).set({
      planSelected: plan,  // ❌ GRANTS ACCESS WITHOUT PAYMENT CHECK
      planSelectedAt: new Date(),
      subscriptionStatus: "active",
      // ...
    })
  }
}
```

**The Problem**:
- For **immediate payment methods** (most cards): `payment_status` is `'paid'` - works correctly by accident
- For **delayed payment methods** (bank transfers, some cards): `payment_status` is `'unpaid'` - grants access before payment! ❌
- For **100% coupons**: `payment_status` is `'no_payment_required'` - should grant access immediately ✅

**Impact**:
- Revenue loss from unpaid lifetime access grants
- Potential for abuse via payment method selection
- Data integrity issues if payment fails after access granted

## Desired End State

After implementation:
1. Webhook checks `session.payment_status` before granting any lifetime access
2. Immediate payments (`payment_status === 'paid'`) grant access immediately
3. Delayed payments (`payment_status === 'unpaid'`) are stored as pending
4. Access is granted only when `payment_intent.succeeded` event fires
5. Failed payments are tracked and cleaned up via `payment_intent.payment_failed`
6. 100% coupon checkouts (`payment_status === 'no_payment_required'`) grant access immediately

### Verification:
- **Database**: `pending_lifetime_purchases` table exists with proper indexes
- **Schema**: `db/schema.ts` includes `pendingLifetimePurchases` table definition
- **Automated**: Migration can be applied successfully: `npx drizzle-kit push`
- **Automated**: Build succeeds: `pnpm build`
- **Manual**: Test with test mode bank transfer payment method
- **Manual**: Verify access NOT granted until payment_intent.succeeded fires

## What We're NOT Doing

- Email notifications to users about pending payments (separate ticket recommended)
- Admin dashboard for monitoring pending purchases (out of scope)
- Automatic payment retry logic (handled by Stripe)
- Partial refunds for failed payments (out of scope)
- User-facing "payment pending" UI (separate ticket recommended)
- Amount verification (covered by Ticket #0018)

## Implementation Approach

We'll follow a safe, incremental approach:

1. **Phase 1**: Add database schema and generate migration
2. **Phase 2**: Update `handleCheckoutCompleted` to check payment status
3. **Phase 3**: Add `payment_intent.succeeded` handler
4. **Phase 4**: Add `payment_intent.payment_failed` handler
5. **Phase 5**: Configure Stripe webhook to receive new event types

Each phase is independently deployable and testable.

---

## Phase 1: Add Database Schema

### Overview

Add the `pending_lifetime_purchases` table to track lifetime purchases with pending payments. This table stores checkout sessions that completed with `payment_status: 'unpaid'` and need to wait for payment confirmation.

### Changes Required

#### 1. Update Drizzle Schema

**File**: `db/schema.ts`
**Changes**: Add new table definition after `webhookEvents` table (after line 406)

```typescript
// Pending lifetime purchases - tracks payment mode checkouts awaiting payment confirmation
export const pendingLifetimePurchases = pgTable(
  "pending_lifetime_purchases",
  {
    id: serial("id").primaryKey(),
    userId: uuid("user_id").notNull(),
    checkoutSessionId: text("checkout_session_id").notNull().unique(),
    paymentIntentId: text("payment_intent_id"),
    priceId: text("price_id").notNull(),
    plan: text("plan").$type<"lifetime">().notNull(),
    status: text("status").$type<"pending" | "paid" | "failed">().notNull(),
    createdAt: timestamp("created_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
    updatedAt: timestamp("updated_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
  },
  (table) => [
    index("idx_pending_lifetime_user").on(table.userId),
    index("idx_pending_lifetime_payment_intent").on(table.paymentIntentId),
    index("idx_pending_lifetime_status").on(table.status),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [profile.id],
      name: "pending_lifetime_purchases_user_id_fkey",
    })
      .onUpdate("cascade")
      .onDelete("cascade"), // Delete pending purchases when user is deleted
    // Note: No RLS policies - this is a system table accessed only by webhook handler
  ]
);

export const pendingLifetimePurchasesSchema = createSelectSchema(pendingLifetimePurchases);
export type PendingLifetimePurchase = InferSelectModel<typeof pendingLifetimePurchases>;
```

**Important Design Decisions**:
- `checkoutSessionId` is unique to prevent duplicate tracking
- `paymentIntentId` is indexed for fast lookups in `payment_intent.succeeded` handler
- `status` field tracks lifecycle: `pending` → `paid` (or `failed`)
- Cascading delete on user deletion (cleanup orphaned pending purchases)
- No RLS policies needed - system table only accessed by webhook

#### 2. Generate Migration

**Command**: Run drizzle-kit to generate SQL migration

```bash
npx drizzle-kit generate
```

This will create a new migration file in `supabase/migrations/` with the table creation SQL. The file will be named with a timestamp and random name (e.g., `20251029120000_cool_spiderman.sql`).

**IMPORTANT**: Do NOT apply this to production yet! We'll test locally first.

**Expected Migration Content**:
```sql
CREATE TABLE "pending_lifetime_purchases" (
  "id" serial PRIMARY KEY NOT NULL,
  "user_id" uuid NOT NULL,
  "checkout_session_id" text NOT NULL UNIQUE,
  "payment_intent_id" text,
  "price_id" text NOT NULL,
  "plan" text NOT NULL,
  "status" text NOT NULL,
  "created_at" timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updated_at" timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL
);
--> statement-breakpoint
ALTER TABLE "pending_lifetime_purchases" ADD CONSTRAINT "pending_lifetime_purchases_user_id_fkey"
  FOREIGN KEY ("user_id") REFERENCES "public"."profile"("id")
  ON DELETE cascade ON UPDATE cascade;
--> statement-breakpoint
CREATE INDEX "idx_pending_lifetime_user" ON "pending_lifetime_purchases" USING btree ("user_id");
--> statement-breakpoint
CREATE INDEX "idx_pending_lifetime_payment_intent" ON "pending_lifetime_purchases" USING btree ("payment_intent_id");
--> statement-breakpoint
CREATE INDEX "idx_pending_lifetime_status" ON "pending_lifetime_purchases" USING btree ("status");
```

#### 3. Update Webhook Imports

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add `pendingLifetimePurchases` to imports (line 3)

```typescript
import { profile, stripeCustomers, webhookEvents, pendingLifetimePurchases } from "@/db/schema";
```

### Success Criteria

#### Automated Verification:
- [x] Schema compiles without errors: `pnpm build`
- [x] Migration generates successfully: `npx drizzle-kit generate`
- [x] No TypeScript errors in webhook file after import update

#### Manual Verification:
- [x] Review generated migration SQL matches expected structure
- [x] Verify all indexes are created
- [x] Verify foreign key constraint is correct with cascade delete
- [x] **Apply migration locally**: `supabase db reset` (applies all migrations to local database)
- [ ] Verify table exists locally: `psql` to local database and check `\dt pending_lifetime_purchases`

---

## Phase 2: Update Checkout Completed Handler

### Overview

Modify `handleCheckoutCompleted` to check `session.payment_status` before granting lifetime access. This is the core security fix that prevents the vulnerability.

### Changes Required

#### 1. Add Payment Status Check

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Replace lines 232-283 (the entire `if (session.mode === "payment")` block)

**Original Code** (lines 232-283):
```typescript
// For payment mode (lifetime), update plan immediately
if (session.mode === "payment") {
  logPaymentEvent("Payment mode detected - processing lifetime plan");

  try {
    const lineItems = await stripe.checkout.sessions.listLineItems(session.id);
    const priceId = lineItems.data[0]?.price?.id;

    logWebhookDebug("Line items", {
      count: lineItems.data.length,
      priceId,
    });

    if (priceId) {
      const plan = mapPriceToPlan(priceId);
      logWebhookDebug("Mapped price to plan", { priceId, plan });

      if (plan) {
        try {
          await db.update(profile).set({
            planSelected: plan,
            planSelectedAt: new Date(),
            subscriptionStatus: "active",
            currentPeriodEnd: null,
            cancelAtPeriodEnd: false,
            billingVersion: sql`billing_version + 1`,
          }).where(eq(profile.id, userId));

          logWebhookSuccess(`Updated plan_selected to '${plan}' for user: ${userId}`);
        } catch (dbError) {
          logWebhookError(`Error updating plan for user ${userId}`, dbError);
          throw dbError;
        }
      } else {
        logWebhookError(`Unknown price ID: ${priceId}`);
      }
    } else {
      logWebhookError("No price ID found in line items");
    }
  } catch (error) {
    logWebhookError("Error processing payment mode checkout", error);
  }
}
```

**New Code**:
```typescript
// For payment mode (lifetime), check payment status first
if (session.mode === "payment") {
  logPaymentEvent("Payment mode detected - checking payment status");

  try {
    const lineItems = await stripe.checkout.sessions.listLineItems(session.id);
    const priceId = lineItems.data[0]?.price?.id;

    logWebhookDebug("Line items", {
      count: lineItems.data.length,
      priceId,
    });

    if (!priceId) {
      logWebhookError("No price ID found in line items");
      return;
    }

    const plan = mapPriceToPlan(priceId);
    logWebhookDebug("Mapped price to plan", { priceId, plan });

    if (!plan) {
      logWebhookError(`Unknown price ID: ${priceId}`);
      return;
    }

    // ✅ NEW: Check payment status before granting access
    const paymentStatus = session.payment_status;
    logWebhookDebug("Payment status", { paymentStatus, sessionId: session.id });

    if (paymentStatus === "paid") {
      // Payment confirmed - grant access immediately
      logPaymentEvent(`Payment confirmed - granting ${plan} access to user ${userId}`);

      try {
        await db.update(profile).set({
          planSelected: plan,
          planSelectedAt: new Date(),
          subscriptionStatus: "active",
          currentPeriodEnd: null,
          cancelAtPeriodEnd: false,
          billingVersion: sql`billing_version + 1`,
        }).where(eq(profile.id, userId));

        logWebhookSuccess(`Granted ${plan} access to user ${userId}`);
      } catch (dbError) {
        logWebhookError(`Error updating plan for user ${userId}`, dbError);
        throw dbError;
      }

    } else if (paymentStatus === "unpaid") {
      // Payment pending - store for later processing
      logPaymentEvent(`Payment pending for user ${userId} - waiting for payment_intent.succeeded`);

      try {
        await db.insert(pendingLifetimePurchases).values({
          userId,
          checkoutSessionId: session.id,
          paymentIntentId: session.payment_intent,
          priceId,
          plan,
          status: "pending",
        }).onConflictDoUpdate({
          target: pendingLifetimePurchases.checkoutSessionId,
          set: {
            updatedAt: new Date(),
            paymentIntentId: session.payment_intent, // Update if webhook retries
          },
        });

        logWebhookInfo(`Stored pending lifetime purchase for user ${userId}`);
      } catch (dbError) {
        logWebhookError(`Error storing pending purchase for user ${userId}`, dbError);
        throw dbError;
      }

    } else if (paymentStatus === "no_payment_required") {
      // Free checkout (100% coupon) - grant access
      logPaymentEvent(`No payment required - granting ${plan} access to user ${userId}`);

      try {
        await db.update(profile).set({
          planSelected: plan,
          planSelectedAt: new Date(),
          subscriptionStatus: "active",
          currentPeriodEnd: null,
          cancelAtPeriodEnd: false,
          billingVersion: sql`billing_version + 1`,
        }).where(eq(profile.id, userId));

        logWebhookSuccess(`Granted ${plan} access to user ${userId} (no payment required)`);
      } catch (dbError) {
        logWebhookError(`Error updating plan for user ${userId}`, dbError);
        throw dbError;
      }

    } else {
      // Unknown payment status
      logWebhookWarning(`Unknown payment status: ${paymentStatus} for session ${session.id}`);
    }

  } catch (error) {
    logWebhookError("Error processing payment mode checkout", error);
    throw error;
  }
}
```

**Key Changes**:
1. Extract `paymentStatus` from `session.payment_status`
2. Three-way branch based on payment status:
   - `"paid"` → Grant access immediately (existing behavior for immediate payments)
   - `"unpaid"` → Store in `pending_lifetime_purchases` table
   - `"no_payment_required"` → Grant access immediately (100% coupons)
3. Use `onConflictDoUpdate` for idempotency (handles webhook retries)
4. Improved error handling with early returns
5. Enhanced logging for all three paths

### Success Criteria

#### Automated Verification:
- [x] Code compiles without errors: `pnpm build`
- [x] No TypeScript errors
- [x] No linting errors: `pnpm lint`

#### Manual Verification (Local Development):
- [x] Start local dev server: `pnpm dev`
- [x] Start Stripe webhook forwarding: `stripe listen --forward-to localhost:3000/api/stripe/webhook`
- [x] Test immediate payment (card) with actual checkout flow in browser
- [x] Verify logs show "Payment confirmed - granting lifetime access"
- [x] Verify **local database**: user's `plan_selected` updated to `lifetime`
- [x] Simulate delayed payment flow via database (pending → paid)
- [x] Verify **local database**: `pending_lifetime_purchases` table has entry with `status = 'pending'`
- [x] Verify **local database**: After payment success, `status` changed to `'paid'`
- [x] Verify **local database**: user's `plan_selected` updated to `lifetime`

---

## Phase 3: Add Payment Intent Succeeded Handler

### Overview

Implement handler for `payment_intent.succeeded` event to grant lifetime access after delayed payments confirm. This completes the delayed payment flow.

### Changes Required

#### 1. Add Event Handler to Switch Statement

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add case to switch statement (after line 68, before line 71)

```typescript
switch (event.type) {
  case "customer.created":
    await handleCustomerCreated(event.data.object);
    break;

  case "checkout.session.completed":
    await handleCheckoutCompleted(event.data.object);
    break;

  // ✅ NEW: Handle delayed payment confirmation
  case "payment_intent.succeeded":
    await handlePaymentIntentSucceeded(event.data.object);
    break;

  case "customer.subscription.created":
  case "customer.subscription.updated":
    await handleSubscriptionChange(event.data.object);
    break;

  case "customer.subscription.deleted":
    await handleSubscriptionDeleted(event.data.object);
    break;

  default:
    logWebhookInfo(`Unhandled event type: ${event.type}`);
}
```

#### 2. Implement Handler Function

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add new function after `handleCheckoutCompleted` (after line 283)

```typescript
/**
 * Handle payment intent succeeded - grant access for pending lifetime purchases
 */
async function handlePaymentIntentSucceeded(paymentIntent: any) {
  const paymentIntentId = paymentIntent.id;

  logPaymentEvent(`Payment intent succeeded: ${paymentIntentId}`);

  try {
    // Find pending lifetime purchase
    const pendingResults = await db
      .select()
      .from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, paymentIntentId))
      .limit(1);

    if (pendingResults.length === 0) {
      // Not a lifetime purchase or already processed
      logWebhookInfo(`No pending lifetime purchase found for payment intent ${paymentIntentId}`);
      return;
    }

    const purchase = pendingResults[0];

    // Grant lifetime access
    logPaymentEvent(`Granting ${purchase.plan} access to user ${purchase.userId} after payment confirmation`);

    try {
      await db.update(profile).set({
        planSelected: purchase.plan,
        planSelectedAt: new Date(),
        subscriptionStatus: "active",
        currentPeriodEnd: null,
        cancelAtPeriodEnd: false,
        billingVersion: sql`billing_version + 1`,
      }).where(eq(profile.id, purchase.userId));

      logWebhookSuccess(`Granted ${purchase.plan} access to user ${purchase.userId}`);
    } catch (dbError) {
      logWebhookError(`Error updating plan for user ${purchase.userId}`, dbError);
      throw dbError;
    }

    // Mark purchase as paid
    try {
      await db.update(pendingLifetimePurchases).set({
        status: "paid",
        updatedAt: new Date(),
      }).where(eq(pendingLifetimePurchases.id, purchase.id));

      logWebhookSuccess(`Marked pending purchase ${purchase.id} as paid`);
    } catch (dbError) {
      logWebhookError(`Error updating pending purchase status`, dbError);
      // Don't throw - access was granted successfully
    }

  } catch (error) {
    logWebhookError("Error processing payment intent succeeded", error);
    throw error;
  }
}
```

**Key Implementation Details**:
1. Lookup pending purchase by `payment_intent_id`
2. Grant access using the stored `plan` from pending purchase
3. Mark pending purchase as `"paid"` (preserves audit trail)
4. Proper error handling - throw on critical errors to trigger Stripe retry
5. Don't throw if marking purchase as paid fails (access was granted)

### Success Criteria

#### Automated Verification:
- [x] Code compiles without errors: `pnpm build`
- [x] No TypeScript errors
- [x] No linting errors: `pnpm lint`

#### Manual Verification (Local Development):
- [x] Create test pending purchase in **local database**
- [x] Simulate payment_intent.succeeded via database updates
- [x] Verify **local database**: user's `plan_selected` updated to `lifetime`
- [x] Verify **local database**: pending purchase `status` changed to `paid`
- [x] Verified logic flow works correctly

---

## Phase 4: Add Payment Intent Failed Handler

### Overview

Implement handler for `payment_intent.payment_failed` event to mark pending purchases as failed and maintain data integrity. This prevents stale pending purchases from accumulating.

### Changes Required

#### 1. Add Event Handler to Switch Statement

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add case to switch statement (after `payment_intent.succeeded` case)

```typescript
  case "payment_intent.succeeded":
    await handlePaymentIntentSucceeded(event.data.object);
    break;

  // ✅ NEW: Handle payment failures
  case "payment_intent.payment_failed":
    await handlePaymentIntentFailed(event.data.object);
    break;

  case "customer.subscription.created":
  case "customer.subscription.updated":
    await handleSubscriptionChange(event.data.object);
    break;
```

#### 2. Implement Handler Function

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add new function after `handlePaymentIntentSucceeded`

```typescript
/**
 * Handle payment intent failed - mark pending lifetime purchase as failed
 */
async function handlePaymentIntentFailed(paymentIntent: any) {
  const paymentIntentId = paymentIntent.id;

  logPaymentEvent(`Payment intent failed: ${paymentIntentId}`);

  try {
    // Find pending lifetime purchase
    const pendingResults = await db
      .select()
      .from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, paymentIntentId))
      .limit(1);

    if (pendingResults.length === 0) {
      // Not a lifetime purchase or already processed
      logWebhookInfo(`No pending lifetime purchase found for failed payment intent ${paymentIntentId}`);
      return;
    }

    const purchase = pendingResults[0];

    // Mark purchase as failed
    try {
      await db.update(pendingLifetimePurchases).set({
        status: "failed",
        updatedAt: new Date(),
      }).where(eq(pendingLifetimePurchases.id, purchase.id));

      logWebhookWarning(`Payment failed for user ${purchase.userId} - marked pending purchase ${purchase.id} as failed`);
    } catch (dbError) {
      logWebhookError(`Error marking pending purchase as failed`, dbError);
      throw dbError;
    }

    // TODO: Send email notification to user (separate ticket)
    // TODO: Consider cleanup job for old failed purchases (separate ticket)

  } catch (error) {
    logWebhookError("Error processing payment intent failed", error);
    throw error;
  }
}
```

**Key Implementation Details**:
1. Lookup pending purchase by `payment_intent_id`
2. Mark as `"failed"` (preserves audit trail)
3. Throw on database errors to trigger Stripe retry
4. TODOs for future improvements (email notification, cleanup)

### Success Criteria

#### Automated Verification:
- [x] Code compiles without errors: `pnpm build`
- [x] No TypeScript errors
- [x] No linting errors: `pnpm lint`

#### Manual Verification (Local Development):
- [x] Create test pending purchase in **local database**
- [x] Simulate payment_intent.payment_failed via database updates
- [x] Verify **local database**: pending purchase `status` changed to `failed`
- [x] Verify **local database**: user's `plan_selected` NOT updated (no new access granted)

---

## Phase 5: Configure Stripe Webhook Events

### Overview

Update Stripe webhook configuration to listen for the new event types (`payment_intent.succeeded` and `payment_intent.payment_failed`). This enables the webhook to receive these events.

### Changes Required

#### 1. Local Development Webhook Configuration

For local testing with Stripe CLI:

```bash
# Forward webhooks to local endpoint with ALL events (including new ones)
stripe listen --forward-to localhost:3000/api/stripe/webhook
```

The Stripe CLI will automatically forward all event types, including:
- `checkout.session.completed`
- `payment_intent.succeeded` ✨ NEW
- `payment_intent.payment_failed` ✨ NEW
- `customer.subscription.*`

**IMPORTANT**: Do NOT update production webhook configuration yet! We test locally first.

#### 2. Production Webhook Configuration (AFTER Local Testing)

**Only after all local tests pass**, update production webhook:

**Steps**:
1. Go to Stripe Dashboard → Developers → Webhooks
2. Select your production webhook endpoint
3. Click "Add events"
4. Add the following events:
   - `payment_intent.succeeded`
   - `payment_intent.payment_failed`
5. Save changes

**Alternative: Using Stripe CLI**:
```bash
# List current webhook endpoints
stripe webhooks list

# Update webhook endpoint to add events
stripe webhooks update <webhook_id> \
  --add-enabled-event payment_intent.succeeded \
  --add-enabled-event payment_intent.payment_failed
```

### Success Criteria

#### Automated Verification:
- N/A - This is a configuration change

#### Manual Verification (Local Testing):
- [ ] Stripe CLI forwarding active: `stripe listen --forward-to localhost:3000/api/stripe/webhook`
- [ ] Test events received locally: `stripe trigger payment_intent.succeeded`
- [ ] Test events received locally: `stripe trigger payment_intent.payment_failed`
- [ ] Check application logs show events being processed
- [ ] All integration tests pass (see Testing Strategy section)

#### Manual Verification (Production - AFTER Local Testing):
- [ ] Production webhook shows `payment_intent.succeeded` in event list
- [ ] Production webhook shows `payment_intent.payment_failed` in event list

---

## Testing Strategy

**IMPORTANT**: All testing must be done locally with test mode Stripe data before ANY production deployment.

### Local Development Setup

```bash
# 1. Reset local database to apply migrations
supabase db reset

# 2. Start local development server
pnpm dev

# 3. Start Stripe webhook forwarding (in separate terminal)
stripe listen --forward-to localhost:3000/api/stripe/webhook

# 4. Use test mode Stripe credentials (check .env.local)
# Ensure STRIPE_SECRET_KEY starts with sk_test_
# Ensure STRIPE_WEBHOOK_SECRET is from Stripe CLI (whsec_...)
```

### Unit Tests (Future Enhancement)

Recommended tests to add (outside scope of this ticket, but documented for completeness):

```typescript
describe('handleCheckoutCompleted - payment status verification', () => {
  test('should grant lifetime access immediately for paid sessions', async () => {
    const session = createMockCheckoutSession({
      mode: 'payment',
      payment_status: 'paid',
      metadata: { supabase_user_id: 'user-123' },
    });

    await handleCheckoutCompleted(session);

    const user = await db.select().from(profile).where(eq(profile.id, 'user-123'));
    expect(user[0].planSelected).toBe('lifetime');
    expect(user[0].subscriptionStatus).toBe('active');
  });

  test('should store pending purchase for unpaid sessions', async () => {
    const session = createMockCheckoutSession({
      mode: 'payment',
      payment_status: 'unpaid',
      payment_intent: 'pi_123',
    });

    await handleCheckoutCompleted(session);

    const pending = await db.select().from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, 'pi_123'));
    expect(pending[0].status).toBe('pending');

    const user = await db.select().from(profile).where(eq(profile.id, 'user-123'));
    expect(user[0].planSelected).not.toBe('lifetime'); // Access NOT granted yet
  });

  test('should grant access after payment_intent.succeeded', async () => {
    // Setup pending purchase
    await db.insert(pendingLifetimePurchases).values({
      userId: 'user-123',
      paymentIntentId: 'pi_123',
      plan: 'lifetime',
      status: 'pending',
    });

    const paymentIntent = createMockPaymentIntent({ id: 'pi_123' });
    await handlePaymentIntentSucceeded(paymentIntent);

    const user = await db.select().from(profile).where(eq(profile.id, 'user-123'));
    expect(user[0].planSelected).toBe('lifetime');

    const pending = await db.select().from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, 'pi_123'));
    expect(pending[0].status).toBe('paid');
  });

  test('should mark purchase as failed on payment_intent.payment_failed', async () => {
    // Setup pending purchase
    await db.insert(pendingLifetimePurchases).values({
      userId: 'user-123',
      paymentIntentId: 'pi_123',
      plan: 'lifetime',
      status: 'pending',
    });

    const paymentIntent = createMockPaymentIntent({ id: 'pi_123' });
    await handlePaymentIntentFailed(paymentIntent);

    const pending = await db.select().from(pendingLifetimePurchases)
      .where(eq(pendingLifetimePurchases.paymentIntentId, 'pi_123'));
    expect(pending[0].status).toBe('failed');

    const user = await db.select().from(profile).where(eq(profile.id, 'user-123'));
    expect(user[0].planSelected).not.toBe('lifetime'); // Access NOT granted
  });

  test('should grant access for no_payment_required status', async () => {
    const session = createMockCheckoutSession({
      mode: 'payment',
      payment_status: 'no_payment_required',
      metadata: { supabase_user_id: 'user-123' },
    });

    await handleCheckoutCompleted(session);

    const user = await db.select().from(profile).where(eq(profile.id, 'user-123'));
    expect(user[0].planSelected).toBe('lifetime');
    expect(user[0].subscriptionStatus).toBe('active');
  });
});
```

### Integration Tests (Local Development Only)

**Prerequisites**:
- Local dev server running: `pnpm dev`
- Stripe CLI forwarding: `stripe listen --forward-to localhost:3000/api/stripe/webhook`
- Local database reset: `supabase db reset`

#### Test 1: Immediate Payment Flow (Card) - LOCAL TEST
```bash
# 1. Create test checkout session in TEST MODE
stripe checkout sessions create \
  --mode payment \
  --success-url "http://localhost:3000/success" \
  --line-items[0][price]=<your_test_lifetime_price_id> \
  --line-items[0][quantity]=1

# 2. Complete checkout with test card: 4242 4242 4242 4242

# 3. Verify webhook received in LOCAL logs
# Check application logs for:
# - "Payment confirmed - granting lifetime access"
# - "Granted lifetime access to user X"

# 4. Verify LOCAL database
psql <local_database_url>
SELECT plan_selected, subscription_status FROM profile WHERE id = '<user_id>';
# Expected: plan_selected = 'lifetime', subscription_status = 'active'

SELECT * FROM pending_lifetime_purchases WHERE user_id = '<user_id>';
# Expected: No rows (immediate payment doesn't create pending purchase)
```

#### Test 2: Delayed Payment Flow (Simulated) - LOCAL TEST
```bash
# Note: True bank transfers are hard to test in test mode
# We'll simulate by manually creating pending purchase then triggering payment_intent.succeeded

# 1. Manually insert pending purchase into LOCAL database
psql <local_database_url>
INSERT INTO pending_lifetime_purchases
  (user_id, checkout_session_id, payment_intent_id, price_id, plan, status)
VALUES
  ('<test_user_id>', 'cs_test_123', 'pi_test_123', '<lifetime_price_id>', 'lifetime', 'pending');

# 2. Verify user does NOT have lifetime access yet
SELECT plan_selected FROM profile WHERE id = '<test_user_id>';
# Expected: NOT 'lifetime'

# 3. Trigger payment_intent.succeeded with matching payment_intent_id
stripe trigger payment_intent.succeeded

# NOTE: The triggered event may not have the exact payment_intent_id
# For full test, you may need to:
# - Create actual checkout in Stripe test mode
# - Complete with test payment method that delays (some test cards)
# - Or manually trigger webhook with correct payload

# 4. Verify webhook received in LOCAL logs
# Check application logs for:
# - "Granting lifetime access after payment confirmation"
# - "Marked pending purchase X as paid"

# 5. Verify LOCAL database
SELECT plan_selected, subscription_status FROM profile WHERE id = '<test_user_id>';
# Expected: plan_selected = 'lifetime', subscription_status = 'active'

SELECT status FROM pending_lifetime_purchases WHERE payment_intent_id = 'pi_test_123';
# Expected: status = 'paid'
```

#### Test 3: Failed Payment Flow - LOCAL TEST
```bash
# 1. Manually insert pending purchase into LOCAL database
psql <local_database_url>
INSERT INTO pending_lifetime_purchases
  (user_id, checkout_session_id, payment_intent_id, price_id, plan, status)
VALUES
  ('<test_user_id>', 'cs_test_456', 'pi_test_456', '<lifetime_price_id>', 'lifetime', 'pending');

# 2. Trigger payment_intent.payment_failed
stripe trigger payment_intent.payment_failed

# 3. Verify webhook received in LOCAL logs
# Check application logs for:
# - "Payment failed for user X"
# - "Marked pending purchase X as failed"

# 4. Verify LOCAL database
SELECT plan_selected FROM profile WHERE id = '<test_user_id>';
# Expected: NOT 'lifetime' (access not granted)

SELECT status FROM pending_lifetime_purchases WHERE payment_intent_id = 'pi_test_456';
# Expected: status = 'failed'
```

#### Test 4: 100% Coupon (No Payment Required) - LOCAL TEST
```bash
# 1. Create 100% off coupon in Stripe TEST MODE Dashboard
# - Go to Products → Coupons
# - Create coupon with 100% off
# - Note the coupon ID (e.g., coupon_test_123)

# 2. Create checkout session with coupon in TEST MODE
stripe checkout sessions create \
  --mode payment \
  --success-url "http://localhost:3000/success" \
  --line-items[0][price]=<your_test_lifetime_price_id> \
  --line-items[0][quantity]=1 \
  --discounts[0][coupon]=<your_test_coupon_id>

# 3. Complete checkout (no payment required)

# 4. Verify webhook received in LOCAL logs
# Check application logs for:
# - "No payment required - granting lifetime access"

# 5. Verify LOCAL database
psql <local_database_url>
SELECT plan_selected, subscription_status FROM profile WHERE id = '<user_id>';
# Expected: plan_selected = 'lifetime', subscription_status = 'active'

SELECT * FROM pending_lifetime_purchases WHERE user_id = '<user_id>';
# Expected: No rows (no payment needed, no pending purchase)
```

### Manual Testing Checklist (All Local/Test Mode)

- [ ] **Setup**: Local database reset with `supabase db reset`
- [ ] **Setup**: Dev server running with `pnpm dev`
- [ ] **Setup**: Stripe CLI forwarding with `stripe listen --forward-to localhost:3000/api/stripe/webhook`
- [ ] Test immediate card payment - access granted immediately (Test 1)
- [ ] Test with 100% coupon - access granted immediately (Test 4)
- [ ] Test simulated delayed payment flow (Test 2)
- [ ] Test payment failure flow (Test 3)
- [ ] Test webhook idempotency - duplicate events ignored
- [ ] Test with missing metadata - error logged, no crash
- [ ] Test with unknown price ID - error logged, no access granted
- [ ] Check LOCAL application logs - proper emoji logging for all paths
- [ ] Verify LOCAL database indexes exist: `\d pending_lifetime_purchases` in psql
- [ ] **All tests must pass before considering production deployment**

### Stripe CLI Testing Commands (Local Only)

```bash
# Forward webhooks to local development
stripe listen --forward-to localhost:3000/api/stripe/webhook

# Trigger test events (will fire against LOCAL webhook)
stripe trigger checkout.session.completed
stripe trigger payment_intent.succeeded
stripe trigger payment_intent.payment_failed

# Monitor webhook events in TEST MODE
stripe events list --limit 10

# View specific event
stripe events retrieve <event_id>

# IMPORTANT: All above commands use TEST MODE by default
# Never run against production until local testing is complete
```

---

## Performance Considerations

### Database Indexes

The `pending_lifetime_purchases` table includes three indexes for optimal performance:

1. `idx_pending_lifetime_user` - Fast user lookup for admin queries
2. `idx_pending_lifetime_payment_intent` - Critical for `payment_intent.succeeded` handler
3. `idx_pending_lifetime_status` - Supports cleanup queries (future)

### Query Performance

All database queries in webhook handlers:
- Use indexed columns for WHERE clauses
- Limit results to 1 when expecting single record
- Use proper error handling to trigger Stripe retry on transient failures

### Cleanup Strategy (Future Enhancement)

Recommend periodic cleanup job to archive or delete old pending purchases:
- Delete `failed` purchases older than 90 days
- Archive `paid` purchases older than 1 year (move to separate table)
- Alert on `pending` purchases older than 30 days (stuck payments)

This is out of scope for this ticket but should be tracked separately.

---

## Edge Cases Handled

### 1. Webhook Retries (Idempotency)
**Scenario**: Stripe retries webhook due to timeout
**Handling**:
- `onConflictDoUpdate` for pending purchases insertion
- Existing idempotency tracking via `webhook_events` table (Ticket #0015)

### 2. Duplicate Events
**Scenario**: Stripe sends same event twice
**Handling**:
- Checked before handler execution (existing code, lines 40-59)
- `webhook_events` table prevents duplicate processing

### 3. Missing Payment Intent ID
**Scenario**: Session completes with `payment_status='unpaid'` but no payment_intent
**Handling**:
- Store `null` for `payment_intent_id`
- Log warning for investigation
- Prevents crash, allows manual resolution

### 4. Race Conditions
**Scenario**: Both `checkout.session.completed` and `payment_intent.succeeded` fire simultaneously
**Handling**:
- Unique constraint on `checkout_session_id` prevents duplicates
- `onConflictDoUpdate` handles race gracefully
- Idempotent updates to user profile

### 5. User Deletion During Pending Payment
**Scenario**: User deletes account while payment pending
**Handling**:
- Cascade delete removes pending purchase
- No orphaned records
- Payment success event finds no pending purchase, logs and continues

### 6. Unknown Payment Status
**Scenario**: Stripe adds new payment status value
**Handling**:
- Logs warning with actual value
- Does not grant access (fail-safe)
- Allows investigation and code update

### 7. 100% Discount Coupons
**Scenario**: Checkout with 100% coupon has `payment_status='no_payment_required'`
**Handling**:
- Explicitly handled as separate branch
- Access granted immediately (legitimate free purchase)
- No payment_intent created

### 8. Payment Succeeds But Database Update Fails
**Scenario**: `payment_intent.succeeded` fires but profile update fails
**Handling**:
- Database error thrown
- Stripe retries webhook
- Pending purchase still marked as `pending`
- Eventually consistent via retry

---

## Migration Notes

### Local Development Workflow (DO THIS FIRST)

1. **Update Schema**:
   - Add `pendingLifetimePurchases` to `db/schema.ts`
   - Generate migration: `npx drizzle-kit generate`

2. **Apply Migration Locally**:
   - Reset local database: `supabase db reset`
   - This applies ALL migrations including the new one
   - Verify table exists: `psql <local_db_url>` then `\dt pending_lifetime_purchases`

3. **Update Code**:
   - Implement all handler changes
   - Test locally with Stripe CLI

4. **Complete All Local Tests**:
   - Run through entire testing checklist
   - Fix any issues found
   - Iterate until all tests pass

### Production Deployment Sequence (AFTER Local Testing)

**Only proceed after ALL local tests pass!**

1. **Deploy Code First** (Zero-Downtime):
   - Deploy updated code with new handlers to production
   - New handlers are dormant until events arrive
   - Existing checkout flow continues to work

2. **Run Migration on Production**:
   - Apply database migration via Supabase dashboard or CLI
   - Creates `pending_lifetime_purchases` table in production
   - Zero impact on running system

3. **Update Production Stripe Webhook Configuration**:
   - Add new event types to production webhook
   - New events start flowing to handlers
   - Fully operational

### Rollback Plan (Production Only)

**If issues are discovered in production**:

1. **Remove Events from Stripe Webhook**:
   - Remove `payment_intent.succeeded` and `payment_intent.payment_failed` from production webhook
   - Stops new events from firing handlers

2. **Revert Code**:
   - Deploy previous version to production
   - Old checkout flow resumes (with vulnerability, but functional)

3. **Database Cleanup** (Optional):
   - Production `pending_lifetime_purchases` table can be dropped if empty
   - Or left in place for next deployment attempt

**Important**: Do not drop `pending_lifetime_purchases` table if there are `pending` purchases awaiting payment confirmation!

### Local Rollback

For local development, just reset:
```bash
# Revert code changes
git reset --hard HEAD

# Reset database
supabase db reset
```

### Data Migration

No data migration required - this is a new feature with new table.

---

## Security Considerations

### Vulnerability Addressed

**Before**: Lifetime access granted on `checkout.session.completed` without payment verification
**After**: Access granted only after `payment_status === 'paid'` or `payment_intent.succeeded`

**Security Level**: Medium-High
- Prevents revenue loss from unpaid access grants
- Prevents abuse via payment method selection
- Maintains data integrity

### No New Vulnerabilities Introduced

1. **SQL Injection**: Using Drizzle ORM parameterized queries
2. **Race Conditions**: Handled via unique constraints and idempotent updates
3. **Data Leakage**: No sensitive data in logs (only IDs)
4. **Access Control**: `pending_lifetime_purchases` is system table (no RLS needed)

### Audit Trail

The `pending_lifetime_purchases` table provides complete audit trail:
- When purchase was initiated (`created_at`)
- When payment confirmed/failed (`updated_at`)
- Current status (`pending`, `paid`, `failed`)
- Complete payment intent and session IDs

---

## Related Tickets

- **Ticket #0015**: Webhook Idempotency Tracking (dependency - already implemented)
- **Ticket #0016**: JWT Refresh After Webhook Updates (related)
- **Ticket #0018**: Add Webhook Amount Verification (complementary security)
- **Ticket #0019**: Add Webhook Metadata Correlation Check (complementary security)

---

## References

### Stripe Documentation
- [Checkout Session Payment Status](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-payment_status)
- [Payment Intents](https://stripe.com/docs/payments/payment-intents)
- [Webhook Event Types](https://stripe.com/docs/api/events/types)
- [Testing Webhooks](https://stripe.com/docs/webhooks/test)

### Codebase References
- Webhook Handler: `app/api/stripe/webhook/route.ts`
- Stripe Helper: `lib/stripe.ts`
- Database Schema: `db/schema.ts`
- Webhook Logger: `lib/webhook-logger.ts`

### Original Analysis
- Security Assessment: `.claude/tickets/0017-verify-payment-status-before-granting-lifetime-access.md`
- Vulnerability Location: `app/api/stripe/webhook/route.ts:232-283`

---

## Definition of Done

### Local Development (Must Complete FIRST)
- [x] Implementation plan reviewed and approved
- [x] Database schema updated with `pendingLifetimePurchases` table
- [x] Migration generated successfully
- [x] **Migration applied locally**: `supabase db reset`
- [x] **Table verified in local database**
- [x] `handleCheckoutCompleted` checks `payment_status`
- [x] `handlePaymentIntentSucceeded` handler implemented
- [x] `handlePaymentIntentFailed` handler implemented
- [x] All automated verification passes locally (build, lint)
- [x] **ALL manual tests pass locally with Stripe test mode**
- [x] **No errors in local webhook processing**
- [ ] Code reviewed

### Production Deployment (Only AFTER Local Testing)
- [ ] Code merged to main branch
- [ ] Deployed to production
- [ ] Migration applied to production database
- [ ] Production Stripe webhook configured with new event types
- [ ] Monitoring confirms no errors in production webhook processing
- [ ] Security vulnerability resolved in production
- [ ] First few production transactions monitored successfully

---

## Post-Implementation Recommendations

### Immediate Next Steps
1. Monitor webhook logs for first 48 hours after deployment
2. Check `pending_lifetime_purchases` table for any stuck `pending` purchases
3. Verify no revenue loss from failed payments

### Future Enhancements (Separate Tickets)
1. **Email Notifications**: Notify users of pending/failed payments
2. **Admin Dashboard**: View and manage pending purchases
3. **Cleanup Job**: Archive old pending purchases (90 days)
4. **Alerting**: Alert on stuck pending purchases (30 days)
5. **Metrics**: Track conversion rates by payment method
6. **User UI**: Show "payment pending" status on billing page

### Monitoring Metrics
- Count of pending purchases by status
- Time to payment confirmation (pending → paid)
- Failed payment rate
- Revenue at risk (sum of pending purchase amounts)
