# Fix Critical Webhook Error Handling with Excellent User Experience

## Overview

Fix a critical bug where webhook handlers return void instead of throwing errors, causing Stripe to receive HTTP 200 (success) even when payment processing fails. This results in users paying for subscriptions but not receiving access, with no retry mechanism and false "success" messages.

**Key Focus:** Minimal code changes + excellent user experience when things go wrong.

## Current State Analysis

### What Exists (Good)

‚úÖ **webhook_events table** (db/schema.ts:377) - Tracks all webhook events with retry counts
‚úÖ **Daily reconciliation job** - Detects drift within 24 hours
‚úÖ **Structured logging** (lib/webhook-logger.ts) - Emoji-based logging throughout
‚úÖ **JWT polling on success page** - Real-time claim updates via Supabase hooks
‚úÖ **Rate limiting** - Already implemented on webhook endpoint

### What's Broken (Critical)

‚ùå **Early returns don't throw errors** - 10+ instances of `return` instead of `throw`
‚ùå **False success responses** - Handlers fail silently, return HTTP 200
‚ùå **No retry mechanism** - Stripe marks failed webhooks as delivered
‚ùå **False "success" messaging** - Success page shows "Welcome to Premium!" after timeout even if webhook failed
‚ùå **No admin visibility** - Failed webhooks logged but not monitored
‚ùå **Poor user guidance** - Users don't know what to do when webhooks are delayed

### Critical Handlers Affected

**app/api/stripe/webhook/route.ts:**
- Line 212: `handleCustomerCreated` - Missing userId
- Line 267: `handleCheckoutCompleted` - Missing userId (CRITICAL - user paid!)
- Line 305: `handleCheckoutCompleted` - Missing subscriptionId
- Line 315: `handleCheckoutCompleted` - Missing priceId
- Line 691: `handleInvoicePaymentFailed` - Missing userId
- Line 982: `handleSubscriptionChange` - Missing userId
- Line 1009: `handleSubscriptionChange` - Missing priceId
- Line 1095: `handleSubscriptionDeleted` - Missing userId

## Desired End State

### Success Metrics

1. **Zero false successes** - Users only see "success" when webhook actually processed
2. **Clear error guidance** - Users know exactly what to do if payment is delayed/failed
3. **Admin visibility** - Critical failures trigger email alerts within minutes
4. **Automatic retry** - Stripe retries failed webhooks per their exponential backoff
5. **Graceful degradation** - Even when webhooks fail, users get helpful guidance

### Verification Steps

#### Automated Verification:
- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] Test missing metadata scenario - webhook returns 500, Stripe retries
- [ ] Test success page during delayed webhook - shows "processing" or "delayed"
- [ ] Test success page after 3 failed webhooks - shows error with support contact
- [ ] Test admin alert fires after 3rd failure
- [ ] Verify no false "Welcome to Premium!" messages

## What We're NOT Doing

To keep this focused and avoid over-engineering:

‚ùå **PostHog integration** - webhook_events table is sufficient
‚ùå **New webhook status polling system** - JWT polling already works
‚ùå **getUserIdOrThrow helper with customer fallback** - adds complexity
‚ùå **Manual grant access API** - reconciliation job handles recovery
‚ùå **Slack integration** - start with email alerts
‚ùå **Comprehensive monitoring dashboard** - use existing tools (Supabase, Stripe)

## Implementation Approach

**Strategy:** Fix the bug with minimal changes, focus heavily on user experience.

**Key insight:** The webhook_events table and reconciliation job already provide the foundation. We just need to:
1. Make critical handlers throw errors (trigger Stripe retry)
2. Give users accurate feedback during the wait
3. Alert admins when automated retries are exhausted

---

## Phase 1: Fix Webhook Error Handling (Critical Handlers Only)

### Overview

Update critical webhook handlers to throw errors instead of returning void, enabling Stripe's automatic retry mechanism.

### Decision Framework: When to Throw vs Return

**THROW (triggers retry):**
- User paid money and won't get access if webhook fails
- Database update failed (temporary issue, worth retrying)
- Stripe API call failed (temporary issue, worth retrying)

**RETURN (log and continue):**
- Optional operation failed but main operation succeeded
- Event type we don't handle yet
- Data validation on non-critical field

### Changes Required

#### 1. Update handleCheckoutCompleted

**File:** `app/api/stripe/webhook/route.ts:255-558`

**Critical failures that must throw:**

```typescript
async function handleCheckoutCompleted(session: any) {
  const userId = session.metadata?.supabase_user_id;
  const customerId = session.customer;

  logWebhookDebug("Checkout session details", {
    sessionId: session.id,
    mode: session.mode,
    customerId,
    metadata: session.metadata,
    paymentStatus: session.payment_status,
  });

  // ‚úÖ THROW: User paid but we can't identify them
  if (!userId) {
    throw new Error(
      `Missing supabase_user_id in checkout session ${session.id} - cannot grant access`
    );
  }

  logWebhookSuccess(`Checkout completed for user: ${userId}`);

  // RETURN: Customer ID storage is optional (we can lookup later)
  if (customerId) {
    try {
      await db
        .insert(stripeCustomers)
        .values({
          userId,
          stripeCustomerId: customerId,
        })
        .onConflictDoNothing();

      logWebhookSuccess(`Stripe customer ID stored for user: ${userId}`);
    } catch (error) {
      // Log but don't throw - not critical for immediate access
      logWebhookError("Error storing stripe customer ID", error);
    }
  } else {
    logWebhookWarning("No customer ID in checkout session");
  }

  // For subscription mode
  if (session.mode === "subscription") {
    logSubscriptionEvent("Subscription checkout - updating plan immediately");

    try {
      const subscriptionId = session.subscription;

      // ‚úÖ THROW: User paid for subscription but we can't retrieve it
      if (!subscriptionId) {
        throw new Error(
          `Missing subscription ID in checkout session ${session.id} for user ${userId}`
        );
      }

      const subscription: any = await stripe.subscriptions.retrieve(subscriptionId as string);
      const priceId = subscription.items.data[0]?.price.id;

      // ‚úÖ THROW: Can't map price to plan
      if (!priceId) {
        throw new Error(
          `No price ID in subscription ${subscriptionId} for user ${userId}`
        );
      }

      const plan = mapPriceToPlan(priceId);
      if (!plan) {
        throw new Error(
          `Unknown price ID ${priceId} in subscription ${subscriptionId} for user ${userId}`
        );
      }

      // Verify subscription amount
      const price = subscription.items.data[0]?.price;
      if (!price) {
        throw new Error(
          `No price object in subscription ${subscriptionId} for user ${userId}`
        );
      }

      const amount = price.unit_amount || 0;
      const currency = price.currency || 'usd';

      const verification = verifyPaymentAmount(plan, currency, amount, true);

      if (!verification.valid) {
        logWebhookError('üö® Amount verification failed at checkout - NOT updating plan', {
          handler: 'handleCheckoutCompleted',
          plan,
          expected: formatAmount(verification.expected),
          actual: formatAmount(verification.actual),
          variance: verification.variance,
          currency: verification.currency,
          subscriptionId: subscription.id,
          userId,
          priceId,
          severity: 'HIGH',
        });
        // ‚úÖ THROW: Amount mismatch is critical security issue
        throw new Error(
          `Amount verification failed for subscription ${subscriptionId} - expected ${verification.expected}, got ${verification.actual}`
        );
      }

      logWebhookSuccess('‚úÖ Amount verification passed at checkout', {
        plan,
        amount: formatAmount(verification.actual),
        currency: verification.currency,
      });

      // ‚úÖ THROW: Database update failed (likely temporary, worth retrying)
      await db
        .update(profile)
        .set({
          planSelected: plan,
          planSelectedAt: new Date(),
          subscriptionStatus: subscription.status,
          currentPeriodEnd: subscription.current_period_end,
          cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
          billingVersion: sql`billing_version + 1`,
        })
        .where(eq(profile.id, userId));

      logWebhookSuccess(`Updated plan_selected to '${plan}' for user: ${userId} at checkout`);
    } catch (error) {
      logWebhookError("Error processing subscription at checkout", error);
      throw error; // Re-throw to trigger Stripe retry
    }

    return;
  }

  // For payment mode (lifetime)
  if (session.mode === "payment") {
    // ... Apply same pattern: throw for critical failures
    // (Similar changes for lifetime purchase path)
  }
}
```

**Pattern applied:**
- Missing userId ‚Üí THROW (user paid, can't grant access)
- Missing subscriptionId/priceId ‚Üí THROW (can't process payment)
- Amount verification failed ‚Üí THROW (security issue)
- Database update failed ‚Üí THROW (temporary, worth retry)
- Customer ID storage failed ‚Üí LOG and CONTINUE (not critical)

#### 2. Update handleSubscriptionChange

**File:** `app/api/stripe/webhook/route.ts:974-997`

```typescript
async function handleSubscriptionChange(subscription: any) {
  const userId = subscription.metadata?.supabase_user_id;
  const customerId = subscription.customer;

  // ‚úÖ THROW: Can't update subscription without userId
  if (!userId) {
    throw new Error(
      `Missing supabase_user_id in subscription ${subscription.id} - cannot update plan`
    );
  }

  // Verify customer ownership
  const ownership = await verifyCustomerOwnership(customerId, userId);

  if (!ownership.valid) {
    logWebhookError('Customer-User correlation check failed - NOT updating plan', {
      handler: 'handleSubscriptionChange',
      claimedUserId: userId,
      actualUserId: ownership.actualUserId,
      stripeCustomerId: customerId,
      subscriptionId: subscription.id,
      severity: 'HIGH',
    });
    // ‚úÖ THROW: Security issue, don't update wrong user's plan
    throw new Error(
      `Customer-User mismatch: subscription ${subscription.id} claims user ${userId} but customer ${customerId} belongs to ${ownership.actualUserId}`
    );
  }

  logWebhookDebug('Customer-User correlation verified', {
    userId,
    customerId,
  });

  const priceId = subscription.items.data[0]?.price.id;
  // ‚úÖ THROW: Can't update without price
  if (!priceId) {
    throw new Error(
      `No price ID in subscription ${subscription.id} for user ${userId}`
    );
  }

  const plan = mapPriceToPlan(priceId);
  if (!plan) {
    throw new Error(
      `Unknown price ID ${priceId} in subscription ${subscription.id} for user ${userId}`
    );
  }

  // Verify subscription amount
  const price = subscription.items.data[0]?.price;
  if (!price) {
    throw new Error(
      `No price object in subscription ${subscription.id} for user ${userId}`
    );
  }

  const amount = price.unit_amount || 0;
  const currency = price.currency || 'usd';

  const verification = verifyPaymentAmount(plan, currency, amount, true);

  if (!verification.valid) {
    logWebhookError('üö® CRITICAL: Subscription amount verification failed - NOT updating plan', {
      handler: 'handleSubscriptionChange',
      plan,
      expected: formatAmount(verification.expected),
      actual: formatAmount(verification.actual),
      variance: verification.variance,
      currency: verification.currency,
      subscriptionId: subscription.id,
      userId,
      priceId,
      severity: 'HIGH',
      action: 'Check environment variables and Stripe price configuration',
    });
    // ‚úÖ THROW: Amount mismatch
    throw new Error(
      `Amount verification failed for subscription ${subscription.id}`
    );
  }

  logWebhookSuccess('‚úÖ Subscription amount verification passed', {
    plan,
    amount: formatAmount(verification.actual),
    currency: verification.currency,
  });

  // Only update if subscription is active
  if (subscription.status === "active" || subscription.status === "trialing") {
    // ‚úÖ THROW: Database update failed
    await db
      .update(profile)
      .set({
        planSelected: plan,
        planSelectedAt: new Date(),
        subscriptionStatus: subscription.status,
        currentPeriodEnd: subscription.current_period_end,
        cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
        billingVersion: sql`billing_version + 1`,
      })
      .where(eq(profile.id, userId));

    logWebhookSuccess(
      `Updated plan_selected to '${plan}' for user: ${userId}`
    );
  }
}
```

#### 3. Update handleSubscriptionDeleted

**File:** `app/api/stripe/webhook/route.ts:1087-1134`

```typescript
async function handleSubscriptionDeleted(subscription: any) {
  const userId = subscription.metadata?.supabase_user_id;
  const customerId = subscription.customer;

  // ‚úÖ THROW: Can't revert without userId
  if (!userId) {
    throw new Error(
      `Missing supabase_user_id in deleted subscription ${subscription.id} - cannot revert plan`
    );
  }

  // Verify customer ownership
  const ownership = await verifyCustomerOwnership(customerId, userId);

  if (!ownership.valid) {
    logWebhookError('Customer-User correlation check failed - NOT reverting plan', {
      handler: 'handleSubscriptionDeleted',
      claimedUserId: userId,
      actualUserId: ownership.actualUserId,
      stripeCustomerId: customerId,
      severity: 'HIGH',
    });
    // ‚úÖ THROW: Security issue
    throw new Error(
      `Customer-User mismatch in subscription deletion ${subscription.id}`
    );
  }

  // ‚úÖ THROW: Database update failed
  await db
    .update(profile)
    .set({
      planSelected: "free",
      planSelectedAt: new Date(),
      subscriptionStatus: "canceled",
      currentPeriodEnd: null,
      cancelAtPeriodEnd: false,
      billingVersion: sql`billing_version + 1`,
    })
    .where(eq(profile.id, userId));

  logWebhookSuccess(`Reverted to free tier for user: ${userId}`);
}
```

#### 4. Update handleInvoicePaymentFailed

**File:** `app/api/stripe/webhook/route.ts:672-757`

```typescript
async function handleInvoicePaymentFailed(invoice: any) {
  const subscriptionId = invoice.subscription;
  const customerId = invoice.customer;
  const attemptCount = invoice.attempt_count;

  logPaymentEvent(
    `Invoice payment failed for subscription ${subscriptionId} (attempt ${attemptCount})`
  );

  // ‚úÖ THROW: Can't handle invoice without subscription
  if (!subscriptionId) {
    throw new Error(
      `Invoice ${invoice.id} has no subscription ID - cannot update user status`
    );
  }

  // Get subscription to find user ID from metadata
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  const userId = subscription.metadata?.supabase_user_id;

  // ‚úÖ THROW: Can't update status without userId
  if (!userId) {
    throw new Error(
      `No user ID in subscription ${subscriptionId} metadata for failed invoice ${invoice.id}`
    );
  }

  // Verify customer ownership (security check)
  const ownership = await verifyCustomerOwnership(customerId, userId);

  if (!ownership.valid) {
    logWebhookError('Customer-User correlation check failed for invoice payment failure', {
      handler: 'handleInvoicePaymentFailed',
      claimedUserId: userId,
      actualUserId: ownership.actualUserId,
      stripeCustomerId: customerId,
      subscriptionId,
      invoiceId: invoice.id,
      severity: 'HIGH',
    });
    // ‚úÖ THROW: Security issue
    throw new Error(
      `Customer-User mismatch for failed invoice ${invoice.id}`
    );
  }

  logWebhookDebug('Customer-User correlation verified for invoice failure', {
    userId,
    customerId,
    subscriptionId,
  });

  // ‚úÖ THROW: Database update failed
  await db
    .update(profile)
    .set({
      subscriptionStatus: "past_due",
      billingVersion: sql`billing_version + 1`,
    })
    .where(eq(profile.id, userId));

  logWebhookSuccess(
    `Updated subscription status to past_due for user ${userId}`
  );

  // Log warning if this is the final attempt
  if (attemptCount >= 3) {
    logWebhookWarning(
      `Final payment attempt failed for user ${userId} - subscription will be canceled by Stripe`,
      {
        attemptCount,
        subscriptionId,
        userId,
      }
    );
  }

  // TODO: Send email notification (separate ticket)
}
```

#### 5. Keep handleCustomerCreated as Return (Non-Critical)

**File:** `app/api/stripe/webhook/route.ts:207-250`

**Decision:** Keep as `return` (not throw) because:
- Customer creation is defensive/optional
- Main billing happens in checkout.session.completed
- Duplicate customer attempts are security logging, not failures

```typescript
async function handleCustomerCreated(customer: any) {
  const userId = customer.metadata?.supabase_user_id;

  if (!userId) {
    // RETURN: This event is informational only
    logWebhookError("No supabase_user_id in customer metadata");
    return;
  }

  try {
    // Check if user already has a customer (defensive)
    const existingCustomer = await db
      .select()
      .from(stripeCustomers)
      .where(eq(stripeCustomers.userId, userId))
      .limit(1);

    if (existingCustomer.length > 0) {
      // RETURN: Security logging, not a failure
      logWebhookWarning('üö® SECURITY: Attempt to create duplicate customer for user', {
        userId,
        existingCustomerId: existingCustomer[0].stripeCustomerId,
        newCustomerId: customer.id,
        severity: 'MEDIUM',
      });

      return;
    }

    await db
      .insert(stripeCustomers)
      .values({
        userId,
        stripeCustomerId: customer.id,
      })
      .onConflictDoNothing();

    logWebhookSuccess(`Stripe customer created for user: ${userId}`);
  } catch (error) {
    // RETURN: Don't fail webhook for customer record creation
    logWebhookError("Error creating stripe customer record", error);
  }
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] Stripe CLI test with missing userId returns 500 (not 200)
- [ ] Webhook failure recorded in webhook_events with status='failed'
- [ ] Stripe retries failed webhook after exponential backoff
- [ ] Second retry increments retryCount in webhook_events
- [ ] Non-critical handler (handleCustomerCreated) still returns void without error

---

## Phase 2: Create Webhook Status API (Accurate User Feedback)

### Overview

Create an API endpoint that the success page can poll to get accurate webhook processing status, replacing the current JWT polling which has a false timeout fallback.

### Why This is Needed

**Current issue:** Success page polls JWT claims and shows "success" after timeout even if webhook failed.

**Solution:** Poll webhook_events table directly to get accurate status.

### Changes Required

#### 1. Create Webhook Status API

**New File:** `app/api/billing/webhook-status/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/db';
import { webhookEvents, profile } from '@/db/schema';
import { eq, and, gte, desc } from 'drizzle-orm';
import { createServerComponentClient } from '@/utils/supabase/server';

export async function GET(request: NextRequest) {
  try {
    const supabase = await createServerComponentClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = user.id;

    // Get user's current plan from database
    const userProfile = await db
      .select()
      .from(profile)
      .where(eq(profile.id, userId))
      .limit(1);

    if (userProfile.length === 0) {
      return NextResponse.json({ error: 'Profile not found' }, { status: 404 });
    }

    const currentPlan = userProfile[0]?.planSelected || 'free';
    const subscriptionStatus = userProfile[0]?.subscriptionStatus;

    // Check recent webhook events (last 5 minutes - typical checkout flow)
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    const recentEvents = await db
      .select()
      .from(webhookEvents)
      .where(and(
        eq(webhookEvents.userId, userId),
        gte(webhookEvents.processedAt, fiveMinutesAgo)
      ))
      .orderBy(desc(webhookEvents.processedAt));

    // Filter for checkout-related events
    const checkoutEvents = recentEvents.filter(e =>
      e.eventType === 'checkout.session.completed' ||
      e.eventType === 'customer.subscription.created' ||
      e.eventType === 'customer.subscription.updated' ||
      e.eventType === 'payment_intent.succeeded'
    );

    const recentFailures = checkoutEvents.filter(e => e.status === 'failed');
    const lastSuccess = checkoutEvents.find(e => e.status === 'success');

    // Determine status based on database state + webhook events
    let status: 'processing' | 'success' | 'delayed' | 'failed';
    let message: string;
    let action: string | null = null;

    // Success: Plan updated and we have a successful webhook
    if (currentPlan !== 'free' && subscriptionStatus === 'active' && lastSuccess) {
      status = 'success';
      message = 'Your subscription has been activated!';
    }
    // Failed: 3+ webhook failures
    else if (recentFailures.length >= 3) {
      status = 'failed';
      message = 'We encountered an issue activating your subscription.';
      action = 'Our team has been notified and will resolve this within 24 hours. You can also contact support for immediate assistance.';
    }
    // Delayed: Some failures but not exhausted
    else if (recentFailures.length > 0 && recentFailures.length < 3) {
      status = 'delayed';
      message = 'Your payment was successful. Activation is taking longer than usual.';
      action = 'This usually resolves within a few minutes. You can check back or contact support if this persists.';
    }
    // Processing: No plan update yet, no failures
    else {
      status = 'processing';
      message = 'Activating your subscription...';
      action = null;
    }

    return NextResponse.json({
      status,
      message,
      action,
      plan: currentPlan,
      subscriptionStatus,
      failureCount: recentFailures.length,
      hasSuccessfulWebhook: !!lastSuccess,
      // Include debugging info for support
      debug: {
        recentEventCount: checkoutEvents.length,
        lastEventType: checkoutEvents[0]?.eventType,
        lastEventStatus: checkoutEvents[0]?.status,
        lastEventRetryCount: checkoutEvents[0]?.retryCount,
      },
    });
  } catch (error) {
    console.error('Error checking webhook status:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**API Response Schema:**
```typescript
{
  status: 'processing' | 'success' | 'delayed' | 'failed',
  message: string,           // User-friendly message
  action: string | null,     // What the user should do
  plan: string,              // Current plan from database
  subscriptionStatus: string,
  failureCount: number,
  hasSuccessfulWebhook: boolean,
  debug: {                   // For support troubleshooting
    recentEventCount: number,
    lastEventType: string,
    lastEventStatus: string,
    lastEventRetryCount: number,
  }
}
```

### Success Criteria

#### Automated Verification:
- [ ] API returns 401 for unauthenticated requests
- [ ] API returns correct status for user with active subscription
- [ ] API returns 'failed' status when 3+ webhook failures exist

#### Manual Verification:
- [ ] Call API after successful checkout - returns 'success' status
- [ ] Call API during webhook delay - returns 'processing' or 'delayed'
- [ ] Call API after 3 failed webhooks - returns 'failed' status
- [ ] Response includes helpful debug info for support

---

## Phase 3: Improve Success Page UX (Clear Error Guidance)

### Overview

Replace the current JWT polling approach with webhook status API polling, and add 4 distinct UI states with clear user guidance for each scenario.

### Current Problems

1. **False success message** - Shows "Welcome to Premium!" even when webhook failed
2. **No error guidance** - Users don't know what to do if delayed
3. **Generic messaging** - Same "processing" state for 0 seconds and 15 seconds
4. **No support contact** - Users can't get help when stuck

### Design Specifications

#### State 1: Processing (0-5 seconds)

**Visual:**
- Loading spinner animation
- Optimistic, encouraging tone
- No action buttons yet

```tsx
<div className="text-6xl mb-4">‚è≥</div>
<h1 className="text-4xl font-bold mb-4">Activating Your Subscription</h1>
<p className="text-lg text-gray-600 mb-8">
  We're setting up your premium access...
</p>
<p className="text-sm text-gray-500">
  This usually takes just a few seconds.
</p>
```

#### State 2: Success (plan activated)

**Visual:**
- Green checkmark
- Celebration message
- Auto-redirect to dashboard

```tsx
<div className="text-6xl mb-4">‚úÖ</div>
<h1 className="text-4xl font-bold mb-4 text-green-600">Welcome to Premium!</h1>
<p className="text-lg text-gray-600 mb-8">
  Your subscription is now active. You have access to all premium features.
</p>
<p className="text-sm text-gray-500">
  Redirecting to dashboard in 3 seconds...
</p>
```

#### State 3: Delayed (5-20 seconds, 1-2 failures)

**Visual:**
- Warning icon (not error)
- Reassuring message
- "Check Again" button
- Support email visible

```tsx
<div className="text-6xl mb-4">‚ö†Ô∏è</div>
<h1 className="text-4xl font-bold mb-4 text-amber-600">Almost There</h1>
<p className="text-lg text-gray-600 mb-4">
  Your payment was successful! Activation is taking longer than usual.
</p>
<p className="text-base text-gray-600 mb-8">
  This usually resolves within a few minutes. Our system is working on it.
</p>

<div className="space-y-4">
  <button
    onClick={checkAgain}
    className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700"
  >
    Check Again
  </button>

  <Link
    href={`/dashboard/${userId}`}
    className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50"
  >
    Continue to Dashboard
  </Link>
</div>

<div className="mt-8 pt-8 border-t">
  <p className="text-sm text-gray-600">
    Still waiting after 5 minutes?{" "}
    <a href="mailto:sebastiansole@handicappin.com" className="text-blue-600 hover:underline">
      Contact Support
    </a>
  </p>
</div>
```

#### State 4: Failed (3+ failures)

**Visual:**
- Error icon
- Honest messaging
- Reassurance that payment was captured
- Clear next steps
- Prominent support contact

```tsx
<div className="text-6xl mb-4">‚ùå</div>
<h1 className="text-4xl font-bold mb-4 text-red-600">Activation Issue</h1>
<p className="text-lg text-gray-700 mb-4">
  We encountered an issue activating your subscription.
</p>

<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
  <p className="text-sm text-blue-800">
    <strong>‚úì Your payment was successful</strong><br />
    Our team has been automatically notified and will resolve this within 24 hours.
  </p>
</div>

<p className="text-base text-gray-600 mb-8">
  For immediate assistance, contact our support team with your session ID:
</p>

<div className="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6 font-mono text-sm">
  Session ID: {sessionId}
</div>

<div className="space-y-4">
  <a
    href="mailto:sebastiansole@handicappin.com?subject=Subscription Activation Issue&body=Session ID: {sessionId}"
    className="block w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 text-center"
  >
    Email Support
  </a>

  <Link
    href="/"
    className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 text-center"
  >
    Return to Home
  </Link>
</div>

<div className="mt-8 pt-8 border-t">
  <p className="text-xs text-gray-500">
    Support: sebastiansole@handicappin.com
  </p>
</div>
```

### Changes Required

#### 1. Update Success Page Component

**File:** `app/billing/success/page.tsx`

```typescript
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@/utils/supabase/client";

type WebhookStatus = {
  status: 'processing' | 'success' | 'delayed' | 'failed';
  message: string;
  action: string | null;
  plan: string;
  failureCount: number;
  debug?: {
    recentEventCount: number;
    lastEventType: string;
    lastEventStatus: string;
  };
};

export default function BillingSuccessPage() {
  const [status, setStatus] = useState<'loading' | 'processing' | 'success' | 'delayed' | 'failed'>('loading');
  const [webhookData, setWebhookData] = useState<WebhookStatus | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [attemptCount, setAttemptCount] = useState(0);

  useEffect(() => {
    // Get session ID from URL params (passed from checkout redirect)
    const params = new URLSearchParams(window.location.search);
    setSessionId(params.get('session_id'));

    checkWebhookStatus();
  }, []);

  async function checkWebhookStatus() {
    try {
      const supabase = createClientComponentClient();

      // Get current user
      const {
        data: { user: initialUser },
      } = await supabase.auth.getUser();

      if (!initialUser) {
        window.location.href = "/login";
        return;
      }

      setUserId(initialUser.id);

      console.log("üîÑ Checking webhook status...");

      // Poll webhook status API (up to 20 seconds, every 2 seconds)
      const maxAttempts = 10;
      const pollInterval = 2000;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        setAttemptCount(attempt);
        console.log(`‚è≥ Polling webhook status (attempt ${attempt}/${maxAttempts})...`);

        // Call webhook status API
        const response = await fetch('/api/billing/webhook-status');

        if (!response.ok) {
          console.error('Failed to fetch webhook status:', response.statusText);
          // Continue polling on API errors
          if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, pollInterval));
            continue;
          } else {
            // After max attempts, show delayed state
            setStatus('delayed');
            break;
          }
        }

        const data: WebhookStatus = await response.json();
        setWebhookData(data);

        console.log(`üîç Webhook status (attempt ${attempt}):`, data);

        // Update UI state based on API response
        if (data.status === 'success') {
          console.log(`‚úÖ Subscription activated successfully!`);
          setStatus('success');

          // Wait 3 seconds to show success message, then redirect
          await new Promise(resolve => setTimeout(resolve, 3000));
          console.log("üöÄ Redirecting to dashboard...");
          window.location.href = `/dashboard/${initialUser.id}`;
          return;
        }
        else if (data.status === 'failed') {
          console.error(`‚ùå Webhook failed ${data.failureCount} times`);
          setStatus('failed');
          return;
        }
        else if (data.status === 'delayed') {
          console.warn(`‚ö†Ô∏è Webhook delayed (${data.failureCount} failures)`);
          setStatus('delayed');
          // Don't return - keep showing delayed UI, let user decide
          return;
        }
        else {
          // Still processing
          setStatus('processing');
        }

        // If not the last attempt, wait before trying again
        if (attempt < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, pollInterval));
        }
      }

      // After all attempts, if still processing, show delayed state
      if (status === 'processing') {
        console.warn("‚ö†Ô∏è Webhook not completed after 20 seconds - showing delayed state");
        setStatus('delayed');
      }
    } catch (error) {
      console.error("Error checking webhook status:", error);

      // On error, show delayed state with support contact
      setStatus('delayed');
    }
  }

  // Allow user to manually re-check status
  const handleCheckAgain = () => {
    setStatus('loading');
    setAttemptCount(0);
    checkWebhookStatus();
  };

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-2xl mx-auto text-center">
        <div className="mb-8">
          {/* Loading State */}
          {status === 'loading' && (
            <>
              <div className="text-6xl mb-4">‚è≥</div>
              <h1 className="text-4xl font-bold mb-4">Just a moment...</h1>
              <p className="text-lg text-gray-600">
                Checking your subscription status...
              </p>
            </>
          )}

          {/* Processing State (0-5 seconds) */}
          {status === 'processing' && (
            <>
              <div className="text-6xl mb-4 animate-pulse">‚è≥</div>
              <h1 className="text-4xl font-bold mb-4">Activating Your Subscription</h1>
              <p className="text-lg text-gray-600 mb-8">
                We're setting up your premium access...
              </p>
              <p className="text-sm text-gray-500">
                This usually takes just a few seconds. (Attempt {attemptCount}/10)
              </p>
            </>
          )}

          {/* Success State */}
          {status === 'success' && (
            <>
              <div className="text-6xl mb-4">‚úÖ</div>
              <h1 className="text-4xl font-bold mb-4 text-green-600">Welcome to Premium!</h1>
              <p className="text-lg text-gray-600 mb-8">
                Your subscription is now active. You have access to all premium features.
              </p>
              <p className="text-sm text-gray-500">
                Redirecting to dashboard in 3 seconds...
              </p>
            </>
          )}

          {/* Delayed State (5-20 seconds, 1-2 failures) */}
          {status === 'delayed' && (
            <>
              <div className="text-6xl mb-4">‚ö†Ô∏è</div>
              <h1 className="text-4xl font-bold mb-4 text-amber-600">Almost There</h1>
              <p className="text-lg text-gray-600 mb-4">
                Your payment was successful! Activation is taking longer than usual.
              </p>
              <p className="text-base text-gray-600 mb-8">
                {webhookData?.action || "This usually resolves within a few minutes. Our system is working on it."}
              </p>

              <div className="space-y-4">
                <button
                  onClick={handleCheckAgain}
                  className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
                >
                  Check Again
                </button>

                <Link
                  href={userId ? `/dashboard/${userId}` : "/"}
                  className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
                >
                  Continue to Dashboard
                </Link>
              </div>

              <div className="mt-8 pt-8 border-t">
                <p className="text-sm text-gray-600">
                  Still waiting after 5 minutes?{" "}
                  <a
                    href={`mailto:sebastiansole@handicappin.com?subject=Subscription Activation Delayed&body=Session ID: ${sessionId || 'unknown'}%0D%0AUser ID: ${userId || 'unknown'}`}
                    className="text-blue-600 hover:underline"
                  >
                    Contact Support
                  </a>
                </p>
              </div>
            </>
          )}

          {/* Failed State (3+ failures) */}
          {status === 'failed' && (
            <>
              <div className="text-6xl mb-4">‚ùå</div>
              <h1 className="text-4xl font-bold mb-4 text-red-600">Activation Issue</h1>
              <p className="text-lg text-gray-700 mb-4">
                We encountered an issue activating your subscription.
              </p>

              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                <p className="text-sm text-blue-800">
                  <strong>‚úì Your payment was successful</strong><br />
                  Our team has been automatically notified and will resolve this within 24 hours.
                </p>
              </div>

              <p className="text-base text-gray-600 mb-4">
                For immediate assistance, contact our support team:
              </p>

              {sessionId && (
                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
                  <p className="text-xs text-gray-500 mb-1">Session ID (for support):</p>
                  <p className="font-mono text-sm break-all">{sessionId}</p>
                </div>
              )}

              <div className="space-y-4">
                <a
                  href={`mailto:sebastiansole@handicappin.com?subject=Subscription Activation Issue&body=Session ID: ${sessionId || 'unknown'}%0D%0AUser ID: ${userId || 'unknown'}%0D%0A%0D%0APlease describe the issue:`}
                  className="block w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition text-center"
                >
                  üìß Email Support
                </a>

                <button
                  onClick={handleCheckAgain}
                  className="w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
                >
                  Try Checking Again
                </button>

                <Link
                  href="/"
                  className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition text-center"
                >
                  Return to Home
                </Link>
              </div>

              <div className="mt-8 pt-8 border-t">
                <p className="text-xs text-gray-500">
                  Support: sebastiansole@handicappin.com
                </p>
                {webhookData?.debug && (
                  <details className="mt-4 text-left">
                    <summary className="text-xs text-gray-400 cursor-pointer hover:text-gray-600">
                      Debug Info (for support)
                    </summary>
                    <pre className="mt-2 text-xs bg-gray-100 p-2 rounded overflow-auto">
                      {JSON.stringify(webhookData.debug, null, 2)}
                    </pre>
                  </details>
                )}
              </div>
            </>
          )}
        </div>

        {/* Always show navigation buttons (except on success state) */}
        {status !== 'success' && status !== 'delayed' && status !== 'failed' && (
          <div className="space-y-4">
            <Link
              href={userId ? `/dashboard/${userId}` : "/"}
              className="block w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
            >
              Go to Dashboard
            </Link>
            <Link
              href="/"
              className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
            >
              Back to Home
            </Link>
          </div>
        )}
      </div>
    </div>
  );
}
```

#### 2. Update Checkout Success Redirect

**File:** Update wherever checkout redirect happens to include session_id

The Stripe checkout success URL should include the session ID:

```typescript
// When creating checkout session
const session = await stripe.checkout.sessions.create({
  success_url: `${process.env.NEXT_PUBLIC_APP_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
  // ... other params
});
```

This allows the success page to display the session ID for support troubleshooting.

### Success Criteria

#### Automated Verification:
- [ ] TypeScript compilation passes
- [ ] No linting errors
- [ ] Component renders all 4 states correctly

#### Manual Verification:
- [ ] Processing state shows for first 5 seconds
- [ ] Success state shows when plan activated, auto-redirects
- [ ] Delayed state shows after 20 seconds if not activated
- [ ] Failed state shows when 3+ webhook failures detected
- [ ] "Check Again" button re-polls webhook status
- [ ] Support email link includes session ID and user ID
- [ ] Session ID displays correctly in failed state
- [ ] No false "Welcome to Premium!" messages
- [ ] All email links work correctly

---

## Phase 4: Add Admin Alerting (Email Notifications)

### Overview

Send email alerts to admin when webhooks fail 3+ times, indicating manual intervention may be needed.

### Why Email (Not PostHog/Slack)

**Decision rationale:**
- Simple to implement (use existing infrastructure)
- No external dependencies
- Reliable delivery
- Email already required for business
- Can add Slack later if needed

### Changes Required

#### 1. Create Email Alert Utility

**New File:** `lib/admin-alerts.ts`

```typescript
/**
 * Admin alerting for critical webhook failures
 * Sends email notifications when webhooks fail 3+ times
 */

export interface WebhookFailureAlert {
  userId: string;
  eventId: string;
  eventType: string;
  sessionId?: string;
  customerId?: string;
  subscriptionId?: string;
  errorMessage: string;
  retryCount: number;
  timestamp: Date;
}

/**
 * Determine if admin should be alerted
 * Alert on 3rd failure (Stripe will retry ~4 times total)
 */
export function shouldAlertAdmin(retryCount: number): boolean {
  return retryCount >= 3;
}

/**
 * Send email alert to admin for critical webhook failure
 * Uses simple fetch to email API endpoint
 */
export async function sendAdminWebhookAlert(failure: WebhookFailureAlert): Promise<void> {
  const adminEmails = process.env.ADMIN_ALERT_EMAILS?.split(',') || ['sebastiansole@handicappin.com'];

  const subject = `üö® CRITICAL: Webhook Failed ${failure.retryCount} Times`;

  const body = `
CRITICAL: User Paid But Webhook Failed

User ID: ${failure.userId}
Event Type: ${failure.eventType}
Event ID: ${failure.eventId}
Error: ${failure.errorMessage}
Retry Count: ${failure.retryCount}
Timestamp: ${failure.timestamp.toISOString()}

Stripe Dashboard Links:
${failure.sessionId ? `- Session: https://dashboard.stripe.com/test/checkout/sessions/${failure.sessionId}` : ''}
${failure.customerId ? `- Customer: https://dashboard.stripe.com/test/customers/${failure.customerId}` : ''}
${failure.subscriptionId ? `- Subscription: https://dashboard.stripe.com/test/subscriptions/${failure.subscriptionId}` : ''}

Database:
- User Profile: /dashboard/${failure.userId}
- Webhook Events: Check webhook_events table for event_id='${failure.eventId}'

Recommended Actions:
1. Check Stripe dashboard to verify payment was captured
2. Check webhook_events table for full error details
3. Check user's profile.plan_selected in database
4. If payment captured but plan not updated, reconciliation job will fix within 24h
5. For immediate fix, manually update profile.plan_selected in database

This alert fires after 3 failed webhook attempts. Stripe will retry once more.
The daily reconciliation job will catch any discrepancies within 24 hours.
`;

  // Log to console with high visibility
  console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.error('üö® CRITICAL WEBHOOK FAILURE - ADMIN ALERT');
  console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.error(`User ID: ${failure.userId}`);
  console.error(`Event Type: ${failure.eventType}`);
  console.error(`Retry Count: ${failure.retryCount}`);
  console.error(`Error: ${failure.errorMessage}`);
  console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

  // Send email via your email service
  // TODO: Implement email sending based on your email provider
  // Options:
  // 1. Resend (recommended for Next.js)
  // 2. SendGrid
  // 3. AWS SES
  // 4. Postmark

  try {
    // Example with fetch to email API endpoint (implement based on your setup)
    const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/admin/send-alert`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: adminEmails,
        subject,
        body,
      }),
    });

    if (!response.ok) {
      console.error('Failed to send admin alert email:', response.statusText);
    } else {
      console.log('‚úÖ Admin alert email sent successfully');
    }
  } catch (error) {
    // Don't throw - email failure shouldn't break webhook processing
    console.error('Error sending admin alert email:', error);
  }
}
```

**Environment variables needed:**
```bash
ADMIN_ALERT_EMAILS="sebastiansole@handicappin.com"
NEXT_PUBLIC_APP_URL="https://handicappin.com"  # Already exists
```

#### 2. Update Webhook Error Handler to Send Alerts

**File:** `app/api/stripe/webhook/route.ts:156-201`

```typescript
  } catch (error) {
    // Signature verification failures are client errors (400)
    if (error instanceof Error && error.message.includes("signature")) {
      logWebhookError("Invalid webhook signature", error);
      return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
    }

    // Record processing failure (only if event was validated)
    if (event?.id) {
      try {
        const userId = extractUserId(event);
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error";

        // Get or increment retry count
        const existingEvent = await db
          .select()
          .from(webhookEvents)
          .where(eq(webhookEvents.eventId, event.id))
          .limit(1);

        const retryCount = existingEvent.length > 0
          ? (existingEvent[0].retryCount || 0) + 1
          : 1;

        await db
          .insert(webhookEvents)
          .values({
            eventId: event.id,
            eventType: event.type,
            status: "failed",
            errorMessage: errorMessage,
            retryCount: retryCount,
            userId: userId,
          })
          .onConflictDoUpdate({
            target: webhookEvents.eventId,
            set: {
              retryCount: sql`${webhookEvents.retryCount} + 1`,
              errorMessage: errorMessage,
              processedAt: sql`CURRENT_TIMESTAMP`,
            },
          });

        logWebhookError(`Recorded failure for ${event.type} (${event.id}), retry count: ${retryCount}`);

        // ‚úÖ NEW: Alert admin if retry count >= 3
        if (shouldAlertAdmin(retryCount)) {
          await sendAdminWebhookAlert({
            userId: userId || 'unknown',
            eventId: event.id,
            eventType: event.type,
            sessionId: event.data.object.id, // Checkout session ID if applicable
            customerId: event.data.object.customer,
            subscriptionId: event.data.object.subscription,
            errorMessage,
            retryCount,
            timestamp: new Date(),
          });
        }
      } catch (recordError) {
        logWebhookError("Failed to record webhook failure", recordError);
      }
    }

    // All other errors are server errors (500)
    logWebhookError("Webhook handler failed", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
```

Add imports at top of file:
```typescript
import { shouldAlertAdmin, sendAdminWebhookAlert } from '@/lib/admin-alerts';
```

#### 3. Create Email Sending API Endpoint (Simple Implementation)

**New File:** `app/api/admin/send-alert/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';

/**
 * Simple email alert endpoint
 * TODO: Implement with your email provider (Resend, SendGrid, etc.)
 */
export async function POST(request: NextRequest) {
  try {
    const { to, subject, body } = await request.json();

    // TODO: Replace with your email service
    // Example with Resend:
    // const { data, error } = await resend.emails.send({
    //   from: 'alerts@handicappin.com',
    //   to: to,
    //   subject: subject,
    //   text: body,
    // });

    // For now, just log (you can implement email service later)
    console.log('üìß Email Alert:');
    console.log('To:', to);
    console.log('Subject:', subject);
    console.log('Body:', body);

    // Return success (implement actual email sending when ready)
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error sending email alert:', error);
    return NextResponse.json(
      { error: 'Failed to send email' },
      { status: 500 }
    );
  }
}
```

**Implementation Note:** Start with console logging, add actual email service (Resend recommended) when ready.

### Success Criteria

#### Automated Verification:
- [ ] shouldAlertAdmin returns true for retryCount >= 3
- [ ] shouldAlertAdmin returns false for retryCount < 3

#### Manual Verification:
- [ ] Trigger 3 webhook failures - admin alert fires
- [ ] Console shows high-visibility error log
- [ ] Email API endpoint receives correct payload
- [ ] Alert includes session ID, user ID, error message
- [ ] Alert includes Stripe dashboard links
- [ ] Alert doesn't fire for retryCount < 3

---

## Testing Strategy

### Unit Tests (Via Stripe CLI)

**Install Stripe CLI:**
```bash
brew install stripe/stripe-cli/stripe
stripe login
stripe listen --forward-to localhost:3000/api/stripe/webhook
```

**Test 1: Missing userId (should throw, return 500)**
```bash
stripe trigger checkout.session.completed \
  --override metadata='{}'
```

**Expected:**
- Webhook returns HTTP 500
- Error recorded in webhook_events with status='failed'
- Console shows error log
- Stripe will retry after exponential backoff

**Test 2: Successful checkout**
```bash
stripe trigger checkout.session.completed
```

**Expected:**
- Webhook returns HTTP 200
- Success recorded in webhook_events
- User's plan updated in database
- Success page shows "Welcome to Premium!"

**Test 3: Simulate 3 failures (admin alert)**
```bash
# Trigger same event 3 times with missing metadata
for i in {1..3}; do
  stripe trigger checkout.session.completed --override metadata='{}'
  sleep 2
done
```

**Expected:**
- First 2 failures: Error logged, retryCount incremented
- 3rd failure: Admin alert fires
- Console shows high-visibility alert
- Email API endpoint called (or email sent if implemented)

### Integration Tests (Manual)

**Test 4: Complete checkout flow in browser**
1. Navigate to `/billing`
2. Select premium plan
3. Enter test card: `4242 4242 4242 4242`
4. Complete checkout
5. Observe success page

**Expected:**
- Success page shows "Activating..." for 2-5 seconds
- Changes to "Welcome to Premium!" when webhook processes
- Auto-redirects to dashboard after 3 seconds
- Dashboard shows premium features unlocked

**Test 5: Success page during delayed webhook**
1. Complete checkout
2. Temporarily break webhook (e.g., invalid metadata)
3. Observe success page

**Expected:**
- Shows "Activating..." for ~10 seconds
- Changes to "Almost There" (delayed state)
- Shows "Check Again" button
- Shows support email
- No false "Welcome to Premium!" message

**Test 6: Success page after 3 failed webhooks**
1. Trigger 3 webhook failures for a user
2. User visits success page

**Expected:**
- Shows "Activation Issue" (failed state)
- Shows "Your payment was successful" reassurance
- Shows session ID
- Shows support email with pre-filled subject
- Shows "Try Checking Again" button

### Performance Tests

**Test 7: Webhook processing time**
```bash
time stripe trigger checkout.session.completed
```

**Expected:**
- Webhook processes in < 1 second (typical)
- Database insert completes successfully
- No performance degradation

**Test 8: Success page polling performance**
1. Monitor network tab during success page polling
2. Count number of API calls

**Expected:**
- Polls webhook status API every 2 seconds
- Maximum 10 API calls (20 seconds)
- No overload on server
- Graceful handling of API errors

### Edge Case Tests

**Test 9: Duplicate webhook (idempotency)**
```bash
# Trigger same event twice
stripe trigger checkout.session.completed
stripe trigger checkout.session.completed
```

**Expected:**
- First webhook: Processes successfully
- Second webhook: Returns 200 with `duplicate: true`
- User's plan updated only once
- No duplicate webhook_events records

**Test 10: User refreshes success page**
1. Complete checkout
2. Refresh success page multiple times

**Expected:**
- Each refresh re-polls webhook status
- Shows accurate status based on current database state
- No duplicate plan updates
- No errors in console

---

## Migration Notes

### Database Changes

No schema changes required. Existing tables sufficient:
- `webhook_events` table already tracks retryCount
- `profile` table already has all billing fields

### Backwards Compatibility

All changes are backwards compatible:
- Existing webhooks continue to work
- New error throwing doesn't affect successful webhooks
- Success page gracefully handles missing session_id

### Deployment Strategy

**Recommended deployment:**
1. Deploy Phase 1 (webhook error handling) first
2. Monitor for 24 hours
3. Deploy Phase 2 (webhook status API)
4. Deploy Phase 3 (success page UX)
5. Deploy Phase 4 (admin alerts)

**Rollback plan:**
- Phase 1: Revert throws back to returns (no data loss)
- Phase 2-4: Simply don't use new endpoints (old JWT polling still works)

### Environment Variables

Add to `.env`:
```bash
ADMIN_ALERT_EMAILS="sebastiansole@handicappin.com"
```

Already exists (no changes needed):
```bash
NEXT_PUBLIC_APP_URL="https://handicappin.com"
STRIPE_WEBHOOK_SECRET="whsec_..."
```

---

## Performance Considerations

### Webhook Processing Time

**Current:** < 500ms typical
**After changes:** < 600ms typical (minimal increase from error logging)

**Optimization:**
- Admin alert runs async (doesn't block webhook response)
- webhook_events insert uses database indexes
- No new external API calls in critical path

### Success Page Polling

**Impact:** 10 API calls over 20 seconds per user checkout
**Load:** Minimal - simple SELECT query with indexes
**Mitigation:** Consider adding rate limiting if needed (not required for MVP)

### Database Indexes

Already optimized:
- `webhook_events.eventId` (primary key)
- `webhook_events.userId` (foreign key + index)
- `webhook_events.processedAt` (index)

No additional indexes needed.

---

## References

### Original Ticket
- `.claude/tickets/0034-implement-comprehensive-webhook-error-handling-and-monitoring.md`

### Related Tickets
- #0015 - Implement webhook idempotency tracking (completed)
- #0026 - Implement billing audit logger (closed - unnecessary)
- #0025 - Implement periodic Stripe reconciliation (completed)
- #0023 - Add rate limiting to Stripe endpoints (completed)

### Stripe Documentation
- [Webhooks Best Practices](https://stripe.com/docs/webhooks/best-practices)
- [Error Handling](https://stripe.com/docs/error-handling)
- [Testing Webhooks](https://stripe.com/docs/webhooks/test)

### Existing Infrastructure
- webhook_events table: `db/schema.ts:377`
- Webhook logger: `lib/webhook-logger.ts`
- Reconciliation job: `lib/reconciliation/stripe-reconciliation.ts`
- Success page: `app/billing/success/page.tsx`

---

## Success Criteria Summary

### Critical Success Metrics

‚úÖ **Zero false successes** - Users never see "Welcome to Premium!" unless plan is activated
‚úÖ **Zero revenue loss** - All payment failures trigger Stripe retry mechanism
‚úÖ **Clear user guidance** - Users know what to do in every state (processing/delayed/failed)
‚úÖ **Admin visibility** - Critical failures trigger email alerts within minutes
‚úÖ **Graceful degradation** - Even when webhooks fail completely, users get helpful guidance and support contact

### Implementation Complete When:

- [ ] All critical webhook handlers throw errors (not return void)
- [ ] Webhook status API returns accurate status based on database + webhook_events
- [ ] Success page shows 4 distinct states with appropriate UX
- [ ] Admin alerts fire after 3rd webhook failure
- [ ] All Stripe CLI tests pass
- [ ] No false "Welcome to Premium!" messages in any scenario
- [ ] Support email links include session ID and user ID
- [ ] Documentation complete (this plan)

---

**Estimated Effort:** 4-6 hours (vs. 8-12 hours in original ticket)
**Risk Level:** LOW (incremental changes, well-tested patterns)
**Priority:** HIGH (revenue-affecting bug)
**Dependencies:** None (uses existing infrastructure)
