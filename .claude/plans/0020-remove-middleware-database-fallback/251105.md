# Remove Middleware Database Fallback - Fail Closed Implementation Plan

## Overview

This plan eliminates the authorization bypass vulnerability in middleware by removing the database fallback when JWT claims are missing. Instead of falling back to potentially stale database data, we implement industry-standard "fail closed" security by treating missing JWT claims as an authentication failure that must be recovered on a dedicated verification page.

**Key Design Principle**: Single source of truth for authorization (JWT claims only), with controlled recovery outside the middleware hot path.

## Current State Analysis

### What Exists Now

**Middleware** (`utils/supabase/middleware.ts:142-150`):
- Reads billing data from JWT claims (‚úÖ)
- Falls back to database query via `getBasicUserAccess()` when claims missing (‚ùå)
- Database fallback bypasses Stripe verification (üî¥ **SECURITY VULNERABILITY**)

**JWT Hook** (`supabase/migrations/20251025154500_fix_jwt_hook_null_handling.sql`):
- Custom Access Token Hook that populates billing claims (‚úÖ)
- Configured in `config.toml` as `pg-functions://` (‚úÖ)
- Works in production but has issues in local development (‚ö†Ô∏è)

**Access Control** (`utils/billing/access-control.ts:37-88`):
- `getBasicUserAccess()` queries database and returns `status: "active"` without Stripe verification (‚ùå)
- Used as middleware fallback when JWT claims missing (‚ùå)

### The Security Vulnerability

**Attack Flow:**
```
1. User cancels Stripe subscription
2. Webhook delayed/fails ‚Üí database not updated yet
3. Attacker strips JWT claims from token (or JWT hook fails)
4. Middleware: No claims ‚Üí Fall back to database
5. getBasicUserAccess() returns { status: "active" } (no Stripe check)
6. User gets premium access without valid subscription ‚ùå
```

**Root Cause**: Two authorization paths exist:
1. **JWT path** (secure): Uses Stripe-verified data from webhooks
2. **Database fallback path** (insecure): Blindly trusts database

### Key Constraints

- ‚úÖ JWT hook exists and works 99% of the time in production
- ‚ö†Ô∏è JWT hook unreliable in local development (`pg-functions://` issues)
- ‚ùå Cannot query Stripe in middleware (adds 200-500ms latency)
- ‚ùå Cannot query database in middleware (defeats performance goals)
- ‚úÖ Must work reliably in both local and production environments

### Key Discoveries

1. **The real issue isn't performance** - it's the **security vulnerability** created by having two auth paths
2. **Missing JWT claims should be rare** (<1% of requests) if hook is working
3. **Fail closed is industry best practice** - treat missing claims as auth failure
4. **Recovery should happen outside middleware** - not in the hot path
5. **Local development JWT hook issues** are a separate problem to fix later

## Desired End State

After implementation:

### Security
- ‚úÖ Single authorization path: JWT claims only
- ‚úÖ No database fallback in middleware
- ‚úÖ Missing claims treated as authentication failure
- ‚úÖ Fail-closed security posture (no bypass paths)

### Performance
- ‚úÖ Middleware stays ultra-fast (<1ms, zero queries)
- ‚úÖ 99%+ requests pass through normally with JWT claims
- ‚úÖ <1% redirect to verification page (acceptable overhead)

### User Experience
- ‚úÖ Normal users: seamless access (JWT claims present)
- ‚úÖ Edge case users: clear recovery flow on verification page
- ‚úÖ Failed recovery: explicit error message, forced re-login

### Maintainability
- ‚úÖ Simple middleware logic (one path, no fallbacks)
- ‚úÖ Clear separation: middleware gates, verification page recovers
- ‚úÖ Monitoring shows how often recovery is needed

### Verification

```bash
# Security verification
1. Strip JWT claims manually ‚Üí Should redirect to /auth/verify-session
2. Verification page attempts recovery
3. Success ‚Üí Return to original page
4. Failure ‚Üí Logout with clear error

# Performance verification
1. Middleware latency <1ms (no database queries)
2. Check logs: "Missing JWT claims" should be <1% of requests

# Functional verification
pnpm build    # TypeScript compilation succeeds
pnpm lint     # No linting errors
Manual test   # All user flows work correctly
```

## What We're NOT Doing

- ‚ùå Trying to fix JWT hook in middleware (not the right place)
- ‚ùå Adding Stripe queries to middleware (too slow)
- ‚ùå Creating infinite redirect loops (verification page handles retries internally)
- ‚ùå Implementing real-time JWT refresh (Ticket #0016, separate concern)
- ‚ùå Removing `getBasicUserAccess()` function (may be used elsewhere)
- ‚ùå Fixing local development JWT hook issues (Phase 4, optional)
- ‚ùå Building admin dashboard for monitoring (out of scope)

## Implementation Approach

We use the **fail-closed security pattern**:

1. **Middleware**: Strict gate - JWT claims present or REJECT
2. **Verification Page**: Controlled recovery - retry with clear limits
3. **Monitoring**: Track recovery rate - should be <1%

**Why This Works:**
- Security: No bypass paths, single source of truth
- Performance: Zero queries in middleware
- UX: 99%+ users unaffected, 1% get recovery flow
- Maintainability: Simple logic, clear responsibilities
- Works locally: No dependency on perfect JWT hook

**Architecture:**

```
Request ‚Üí Middleware
            ‚Üì
         Check JWT claims
            ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì             ‚Üì
  Claims        No claims
  Present       ‚ùå
    ‚Üì             ‚Üì
  ‚úÖ Pass    Redirect to
  Through    /auth/verify-session
                  ‚Üì
              Retry refreshSession()
                  ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚Üì           ‚Üì
        Success     Failed (3x)
            ‚Üì           ‚Üì
        Redirect    Force logout
        to origin   with error
```

---

## Phase 1: Remove Database Fallback from Middleware

### Overview

Remove the security vulnerability by eliminating the database fallback path. When JWT claims are missing, redirect to a dedicated verification page instead of querying the database.

### Changes Required

#### 1. Update Middleware - Remove Database Fallback

**File**: `utils/supabase/middleware.ts`

**Changes**: Replace database fallback (lines 142-150) with redirect to verification page

```typescript
// Lines 124-272 - UPDATE access control section

if (
  user &&
  !isPublic &&
  !pathname.startsWith("/onboarding") &&
  !pathname.startsWith("/billing") &&
  !pathname.startsWith("/upgrade") &&
  !pathname.startsWith("/auth/verify-session") // ‚úÖ NEW: Don't check claims on verify page
) {
  const startTime = performance.now();

  try {
    // Read billing info from JWT claims (NO DATABASE FALLBACK!)
    const billing = user.app_metadata?.billing as BillingClaims | undefined;

    let plan: string | null = null;
    let status: string | null = "active";
    let hasPremiumAccess: boolean = false;

    // ‚úÖ NEW: If claims missing, redirect to verification page (NO DATABASE FALLBACK)
    if (!billing) {
      console.error(
        `‚ùå Missing JWT claims for user ${user.id} - redirecting to session verification`,
        {
          pathname,
          timestamp: new Date().toISOString(),
        }
      );

      // Redirect to verification page with return URL
      const url = request.nextUrl.clone();
      url.pathname = "/auth/verify-session";
      url.searchParams.set("returnTo", pathname);
      return NextResponse.redirect(url);
    }

    // JWT claims present - use them!
    plan = billing.plan;
    status = billing.status;

    // Check for edge cases using status and period_end
    if (
      status === "past_due" ||
      status === "incomplete" ||
      status === "paused"
    ) {
      console.warn(`‚ö†Ô∏è Subscription ${status} for user ${user.id}`);
      hasPremiumAccess = false;
    }
    else if (status === "canceled") {
      if (billing.cancel_at_period_end && billing.current_period_end) {
        const nowSeconds = Date.now() / 1000;
        const isExpired =
          nowSeconds > billing.current_period_end + EXPIRY_LEEWAY_SECONDS;

        if (isExpired) {
          console.warn(`‚ö†Ô∏è Canceled subscription expired for user ${user.id}`);
          hasPremiumAccess = false;
        } else {
          hasPremiumAccess =
            plan === "premium" ||
            plan === "unlimited" ||
            plan === "lifetime";
        }
      } else {
        console.warn(`‚ö†Ô∏è Subscription canceled (immediate) for user ${user.id}`);
        hasPremiumAccess = false;
      }
    }
    else if (
      billing.current_period_end &&
      Date.now() / 1000 > billing.current_period_end + EXPIRY_LEEWAY_SECONDS
    ) {
      console.warn(`‚ö†Ô∏è Subscription expired for user ${user.id}`);
      hasPremiumAccess = false;
    }
    else {
      hasPremiumAccess =
        plan === "premium" || plan === "unlimited" || plan === "lifetime";
    }

    const endTime = performance.now();
    const duration = endTime - startTime;

    // Alert if middleware is slow (should be < 10ms with JWT-only)
    if (duration > 10) {
      console.warn(
        `üêå Slow middleware detected: ${duration.toFixed(2)}ms (threshold: 10ms)`,
        {
          userId: user.id,
          pathname,
        }
      );
    }

    // Check if user needs onboarding (no plan selected)
    if (!plan) {
      const url = request.nextUrl.clone();
      url.pathname = "/onboarding";
      return NextResponse.redirect(url);
    }

    // Check premium routes
    const isPremiumRoute = premiumPaths.some((path) =>
      pathname.startsWith(path)
    );

    if (isPremiumRoute && !hasPremiumAccess) {
      const url = request.nextUrl.clone();
      url.pathname = "/upgrade";
      return NextResponse.redirect(url);
    }

    // Check if user is trying to add a round when at limit (free tier only)
    if (pathname.startsWith("/rounds/add") && plan === "free") {
      // Count rounds from database (fast query due to index)
      const { count: roundCount, error: countError } = await supabase
        .from("round")
        .select("*", { count: "exact", head: true })
        .eq("userId", user.id);

      if (countError) {
        console.error("‚ùå Middleware: Error counting rounds:", countError);
      } else {
        if (roundCount !== null && roundCount >= FREE_TIER_ROUND_LIMIT) {
          const url = request.nextUrl.clone();
          url.pathname = "/upgrade";
          url.searchParams.set("reason", "round_limit");
          return NextResponse.redirect(url);
        }
      }
    }
  } catch (error) {
    // ‚úÖ NEW: On error, redirect to verification page (not onboarding)
    console.error("‚ùå Middleware error - redirecting to session verification:", error);

    const url = request.nextUrl.clone();
    url.pathname = "/auth/verify-session";
    url.searchParams.set("returnTo", pathname);
    url.searchParams.set("error", "middleware_exception");

    return NextResponse.redirect(url);
  }
}
```

**Key Changes:**
1. **Line ~132**: Add `/auth/verify-session` to excluded paths
2. **Lines ~142-150 (OLD)**: Remove database fallback code entirely
3. **Lines ~142-155 (NEW)**: Redirect to verification page when claims missing
4. **Lines ~285-293 (NEW)**: Error handling redirects to verification page

#### 2. Deprecate `getBasicUserAccess()` with Warning

**File**: `utils/billing/access-control.ts`

**Changes**: Add deprecation warning (function may be used elsewhere, don't remove yet)

```typescript
/**
 * ‚ö†Ô∏è DEPRECATED: This function is NO LONGER used in middleware!
 *
 * Lightweight version of access control for Edge Runtime (middleware).
 * Reads MINIMAL billing info from database WITHOUT Stripe verification.
 *
 * ‚ö†Ô∏è SECURITY WARNING: This function does NOT verify with Stripe and should
 * NOT be used for authorization decisions!
 *
 * ‚ö†Ô∏è MIDDLEWARE NOTE: Middleware no longer calls this function. Missing JWT
 * claims now trigger a redirect to /auth/verify-session for controlled recovery.
 *
 * ‚úÖ USE INSTEAD:
 * - Middleware: Read billing data from JWT claims (user.app_metadata.billing)
 * - Server Actions: Use getComprehensiveUserAccess() which verifies with Stripe
 *
 * This function is kept for backward compatibility in case other code uses it,
 * but should be removed entirely once all usages are migrated.
 *
 * @deprecated Use JWT claims in middleware or getComprehensiveUserAccess() in server actions
 */
export async function getBasicUserAccess(
  userId: string
): Promise<FeatureAccess> {
  console.warn(
    "‚ö†Ô∏è DEPRECATED: getBasicUserAccess() called - this should NOT be used for authorization!",
    {
      userId,
      caller: new Error().stack?.split("\n")[2]?.trim(), // Log caller for debugging
    }
  );

  // ... existing implementation ...
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compilation succeeds: `pnpm build`
- [x] No linting errors: `pnpm lint`
- [x] Middleware imports removed: `getBasicUserAccess` not imported in middleware.ts

#### Manual Verification:
- [ ] Normal user with JWT claims: Access granted without redirect
- [ ] User without JWT claims: Redirected to `/auth/verify-session?returnTo=<original-path>`
- [ ] Console shows: "Missing JWT claims for user X - redirecting to session verification"
- [ ] No console logs mentioning "falling back to database"
- [ ] Middleware latency <5ms (check performance logs)
- [ ] `/auth/verify-session` itself doesn't trigger middleware redirect (excluded path)

---

## Phase 2: Create Session Verification Page

### Overview

Build a dedicated page that handles JWT claim recovery with retry logic, clear UX, and proper error handling. This page is where users land when JWT claims are missing.

### Changes Required

#### 1. Create Session Verification Page Component

**File**: `app/auth/verify-session/page.tsx` (NEW)

**Changes**: Create new page with retry logic

```typescript
import { VerifySessionContent } from "./verify-session-content";
import { createServerComponentClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";

export const metadata = {
  title: "Verifying Session | Handicappin",
  description: "Verifying your session...",
};

export default async function VerifySessionPage({
  searchParams,
}: {
  searchParams: { returnTo?: string; error?: string };
}) {
  const supabase = await createServerComponentClient();

  // Check if user is authenticated
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Not authenticated ‚Üí redirect to login
  if (!user) {
    const loginUrl = new URL("/login", process.env.NEXT_PUBLIC_SITE_URL);
    loginUrl.searchParams.set("error", "session_expired");
    if (searchParams.returnTo) {
      loginUrl.searchParams.set("returnTo", searchParams.returnTo);
    }
    redirect(loginUrl.toString());
  }

  // Get return URL (default to dashboard)
  const returnTo = searchParams.returnTo || `/dashboard/${user.id}`;
  const error = searchParams.error;

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <VerifySessionContent
        userId={user.id}
        returnTo={returnTo}
        initialError={error}
      />
    </div>
  );
}
```

#### 2. Create Client-Side Verification Logic

**File**: `app/auth/verify-session/verify-session-content.tsx` (NEW)

**Changes**: Create client component with retry logic

```typescript
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@/utils/supabase/client";

const MAX_RETRY_ATTEMPTS = 3;
const RETRY_DELAY_MS = 2000; // 2 seconds between retries

type VerificationState =
  | "verifying"
  | "retrying"
  | "success"
  | "failed"
  | "error";

interface VerifySessionContentProps {
  userId: string;
  returnTo: string;
  initialError?: string;
}

export function VerifySessionContent({
  userId,
  returnTo,
  initialError,
}: VerifySessionContentProps) {
  const router = useRouter();
  const [state, setState] = useState<VerificationState>("verifying");
  const [attemptCount, setAttemptCount] = useState(0);
  const [errorMessage, setErrorMessage] = useState<string | null>(
    initialError || null
  );

  useEffect(() => {
    async function verifySession() {
      const supabase = createClientComponentClient();

      try {
        console.log(
          `üîÑ Verification attempt ${attemptCount + 1}/${MAX_RETRY_ATTEMPTS}`
        );

        // Force session refresh to re-run JWT hook
        const { data, error } = await supabase.auth.refreshSession();

        if (error) {
          console.error("‚ùå Session refresh failed:", error);
          throw error;
        }

        if (!data.session) {
          console.error("‚ùå No session returned from refresh");
          throw new Error("No session returned");
        }

        // Check if billing claims are now present
        const billing = data.session.user.app_metadata?.billing;

        if (!billing) {
          console.warn(
            `‚ö†Ô∏è Billing claims still missing after refresh (attempt ${attemptCount + 1})`
          );

          // Retry if we haven't exceeded max attempts
          if (attemptCount < MAX_RETRY_ATTEMPTS - 1) {
            setState("retrying");
            setAttemptCount(attemptCount + 1);
            // Wait before retrying
            await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS));
            return; // useEffect will re-run due to attemptCount change
          } else {
            // Max retries exceeded
            setState("failed");
            setErrorMessage(
              "Unable to verify your session after multiple attempts. Please try logging in again."
            );
            return;
          }
        }

        // Success! Claims are present
        console.log("‚úÖ Session verified successfully:", {
          plan: billing.plan,
          status: billing.status,
          version: billing.billing_version,
        });

        setState("success");

        // Wait a moment to show success message, then redirect
        setTimeout(() => {
          console.log(`‚Ü™Ô∏è Redirecting to: ${returnTo}`);
          router.push(returnTo);
          router.refresh(); // Force middleware to re-run
        }, 1000);
      } catch (error) {
        console.error("‚ùå Verification error:", error);

        // Retry if we haven't exceeded max attempts
        if (attemptCount < MAX_RETRY_ATTEMPTS - 1) {
          setState("retrying");
          setAttemptCount(attemptCount + 1);
          // Wait before retrying
          await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS));
        } else {
          // Max retries exceeded
          setState("error");
          setErrorMessage(
            error instanceof Error
              ? error.message
              : "An unexpected error occurred"
          );
        }
      }
    }

    verifySession();
  }, [attemptCount, returnTo, router, userId]);

  // Handle logout on failure
  const handleLogout = async () => {
    const supabase = createClientComponentClient();
    await supabase.auth.signOut();
    router.push("/login?error=session_verification_failed");
  };

  return (
    <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8">
      <div className="text-center">
        {/* Verifying State */}
        {state === "verifying" && (
          <>
            <div className="text-6xl mb-4 animate-spin">‚è≥</div>
            <h1 className="text-2xl font-bold mb-2">Verifying Your Session</h1>
            <p className="text-gray-600 mb-6">
              Please wait while we verify your account...
            </p>
            <div className="flex justify-center">
              <div className="animate-pulse flex space-x-2">
                <div className="w-3 h-3 bg-blue-600 rounded-full"></div>
                <div className="w-3 h-3 bg-blue-600 rounded-full"></div>
                <div className="w-3 h-3 bg-blue-600 rounded-full"></div>
              </div>
            </div>
          </>
        )}

        {/* Retrying State */}
        {state === "retrying" && (
          <>
            <div className="text-6xl mb-4 animate-pulse">üîÑ</div>
            <h1 className="text-2xl font-bold mb-2">Retrying...</h1>
            <p className="text-gray-600 mb-2">
              Attempt {attemptCount + 1} of {MAX_RETRY_ATTEMPTS}
            </p>
            <p className="text-sm text-gray-500 mb-6">
              Having trouble verifying your session. Trying again...
            </p>
            <div className="flex justify-center">
              <div className="animate-pulse flex space-x-2">
                <div className="w-3 h-3 bg-yellow-600 rounded-full"></div>
                <div className="w-3 h-3 bg-yellow-600 rounded-full"></div>
                <div className="w-3 h-3 bg-yellow-600 rounded-full"></div>
              </div>
            </div>
          </>
        )}

        {/* Success State */}
        {state === "success" && (
          <>
            <div className="text-6xl mb-4">‚úÖ</div>
            <h1 className="text-2xl font-bold mb-2">Session Verified!</h1>
            <p className="text-gray-600 mb-6">
              Redirecting you back to where you were...
            </p>
          </>
        )}

        {/* Failed State (Max Retries) */}
        {state === "failed" && (
          <>
            <div className="text-6xl mb-4">‚ùå</div>
            <h1 className="text-2xl font-bold mb-2">Verification Failed</h1>
            <p className="text-gray-600 mb-6">{errorMessage}</p>
            <div className="space-y-3">
              <button
                onClick={handleLogout}
                className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
              >
                Sign In Again
              </button>
              <a
                href="mailto:support@handicappin.com"
                className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
              >
                Contact Support
              </a>
            </div>
          </>
        )}

        {/* Error State (Unexpected) */}
        {state === "error" && (
          <>
            <div className="text-6xl mb-4">‚ö†Ô∏è</div>
            <h1 className="text-2xl font-bold mb-2">Something Went Wrong</h1>
            <p className="text-gray-600 mb-2">
              We encountered an error while verifying your session.
            </p>
            <p className="text-sm text-red-600 mb-6">{errorMessage}</p>
            <div className="space-y-3">
              <button
                onClick={() => {
                  setAttemptCount(0);
                  setState("verifying");
                }}
                className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
              >
                Try Again
              </button>
              <button
                onClick={handleLogout}
                className="w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
              >
                Sign In Again
              </button>
            </div>
          </>
        )}
      </div>

      {/* Debug Info (only in development) */}
      {process.env.NODE_ENV === "development" && (
        <div className="mt-8 p-4 bg-gray-100 rounded text-xs text-left">
          <p className="font-mono mb-1">
            <strong>Debug Info:</strong>
          </p>
          <p className="font-mono">State: {state}</p>
          <p className="font-mono">
            Attempts: {attemptCount}/{MAX_RETRY_ATTEMPTS}
          </p>
          <p className="font-mono">Return To: {returnTo}</p>
          <p className="font-mono">User ID: {userId}</p>
          {initialError && (
            <p className="font-mono text-red-600">
              Initial Error: {initialError}
            </p>
          )}
        </div>
      )}
    </div>
  );
}
```

#### 3. Ensure Client Supabase Utility Exists

**File**: `utils/supabase/client.ts`

**Action**: Verify this file exists. If not, create it:

```typescript
import { createBrowserClient } from "@supabase/ssr";
import { Database } from "@/types/supabase";

export function createClientComponentClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compilation succeeds: `pnpm build`
- [x] No linting errors: `pnpm lint`
- [x] Page renders without errors in dev mode

#### Manual Verification:
- [ ] Navigate to `/auth/verify-session` ‚Üí Shows verification UI
- [ ] While verifying, shows loading spinner
- [ ] On success, redirects to `returnTo` URL
- [ ] On failure after 3 attempts, shows error with "Sign In Again" button
- [ ] "Sign In Again" button logs user out and redirects to login
- [ ] Debug info shows in development mode only
- [ ] Return URL is preserved through verification flow
- [ ] No infinite loops (max 3 attempts, then terminal state)

---

## Phase 3: Add Monitoring & Observability

### Overview

Add metrics to track how often users hit the verification page and monitor JWT claim availability. This helps us understand if JWT hook issues are widespread or rare.

### Changes Required

#### 1. Add Verification Metrics to Verification Page

**File**: `app/auth/verify-session/verify-session-content.tsx`

**Changes**: Add metric logging (lines to add at key points)

```typescript
// After successful verification (inside success block):
console.info("METRIC: session_verification_success", {
  userId,
  attemptCount: attemptCount + 1,
  timestamp: new Date().toISOString(),
});

// After failed verification (inside failed block):
console.error("METRIC: session_verification_failed", {
  userId,
  attemptCount: MAX_RETRY_ATTEMPTS,
  reason: "max_retries_exceeded",
  timestamp: new Date().toISOString(),
});

// After error verification (inside error block):
console.error("METRIC: session_verification_error", {
  userId,
  attemptCount: attemptCount + 1,
  error: errorMessage,
  timestamp: new Date().toISOString(),
});
```

#### 2. Add Missing Claims Metric to Middleware

**File**: `utils/supabase/middleware.ts`

**Changes**: Add metric when claims are missing (already added in Phase 1, just document it)

```typescript
// When claims missing (line ~142):
console.error(
  "METRIC: jwt_claims_missing", // ‚Üê This is the metric key
  {
    userId: user.id,
    pathname,
    timestamp: new Date().toISOString(),
  }
);
```

#### 3. Document Metrics for Monitoring

**File**: `.claude/plans/0020-remove-middleware-database-fallback/METRICS.md` (NEW)

**Changes**: Create metrics documentation

```markdown
# Session Verification Metrics

## Key Metrics to Monitor

### 1. JWT Claims Missing Rate
**Metric**: `jwt_claims_missing`
**Location**: Middleware (utils/supabase/middleware.ts)
**Expected**: <1% of authenticated requests
**Alert Threshold**: >5% over 1 hour

**What it means**:
- How often users hit middleware without JWT claims
- Should be rare if JWT hook is working
- Spike indicates JWT hook issues

### 2. Verification Success Rate
**Metric**: `session_verification_success`
**Location**: Verification page (app/auth/verify-session)
**Expected**: >95% of verification attempts
**Alert Threshold**: <90% over 1 hour

**What it means**:
- How often retry logic successfully recovers claims
- High success rate = JWT hook works, just needs a refresh
- Low success rate = deeper JWT hook issues

### 3. Verification Failure Rate
**Metric**: `session_verification_failed`
**Location**: Verification page (app/auth/verify-session)
**Expected**: <5% of verification attempts
**Alert Threshold**: >10% over 1 hour

**What it means**:
- Users who couldn't recover after 3 attempts
- These users are forced to re-login
- High rate indicates critical JWT hook issues

### 4. Verification Error Rate
**Metric**: `session_verification_error`
**Location**: Verification page (app/auth/verify-session)
**Expected**: <1% of verification attempts
**Alert Threshold**: >5% over 1 hour

**What it means**:
- Unexpected errors during verification
- May indicate API issues, network problems, etc.

## How to Monitor (Examples)

### Using grep in production logs:
```bash
# Count missing claims in last hour
grep "METRIC: jwt_claims_missing" logs.txt | wc -l

# Count verification successes
grep "METRIC: session_verification_success" logs.txt | wc -l

# Find verification failures
grep "METRIC: session_verification_failed" logs.txt
```

### Using log aggregation (Datadog, Sentry, etc.):
1. Filter logs by metric keys
2. Create dashboards with counts over time
3. Set up alerts based on thresholds above

## Expected Behavior

**Healthy System:**
- `jwt_claims_missing`: 1-10 per day (rare)
- `session_verification_success`: 95%+ of verification attempts
- `session_verification_failed`: <5% of verification attempts

**Unhealthy System:**
- `jwt_claims_missing`: >100 per day (JWT hook issues)
- `session_verification_success`: <90% (hook not recovering)
- `session_verification_failed`: >10% (users forced to re-login)

## Action Items Based on Metrics

**If `jwt_claims_missing` >5% of requests:**
‚Üí Investigate JWT hook (Phase 4: Fix Local JWT Hook Issues)
‚Üí Check Supabase logs for hook errors
‚Üí Consider switching from pg-functions:// to HTTP hook

**If `session_verification_failed` >10%:**
‚Üí Critical issue with JWT hook
‚Üí May need to increase retry attempts or delay
‚Üí Consider temporary rollback to database fallback

**If `session_verification_error` spikes:**
‚Üí Check API availability
‚Üí Check network issues
‚Üí Review error messages in logs
```

### Success Criteria

#### Automated Verification:
- [x] Metrics logged in correct format (parseable JSON)
- [x] Metrics visible in development console logs

#### Manual Verification:
- [ ] Trigger verification flow ‚Üí See "METRIC: jwt_claims_missing" in logs
- [ ] Complete verification ‚Üí See "METRIC: session_verification_success" in logs
- [ ] Fail verification (simulate) ‚Üí See "METRIC: session_verification_failed" in logs
- [ ] Metrics include userId, timestamp, and relevant context
- [ ] Metrics are NOT logged for normal requests (only edge cases)

---

## Phase 4 (Optional): Investigate Local JWT Hook Issues

### Overview

This phase is optional and addresses the root cause of why JWT claims may be missing in local development. Only needed if Phase 1-3 show high rates of missing claims.

### Investigation Steps

#### 1. Check Local JWT Hook Execution

**Action**: Verify hook is actually running locally

```sql
-- In Supabase Studio SQL Editor (or psql):

-- Check if function exists
SELECT
  proname,
  prosrc,
  prosecdef
FROM pg_proc
WHERE proname = 'custom_access_token_hook';

-- Check permissions
SELECT
  has_function_privilege('supabase_auth_admin', 'public.custom_access_token_hook(jsonb)', 'EXECUTE') as has_execute,
  has_table_privilege('supabase_auth_admin', 'public.profile', 'SELECT') as has_select;
```

**Expected**:
- Function exists with `prosecdef = true` (SECURITY DEFINER)
- Both permissions return `true`

#### 2. Test JWT Hook Manually

**Action**: Call hook directly to see if it works

```sql
-- Test hook with mock event
SELECT public.custom_access_token_hook(
  jsonb_build_object(
    'user_id', '<your-test-user-id>',
    'claims', jsonb_build_object(
      'sub', '<your-test-user-id>',
      'email', 'test@example.com',
      'role', 'authenticated',
      'aal', 'aal1',
      'iss', 'https://test.supabase.co/auth/v1',
      'aud', 'authenticated',
      'exp', extract(epoch from now() + interval '1 hour')::bigint,
      'iat', extract(epoch from now())::bigint,
      'session_id', 'test-session-id'
    )
  )
);
```

**Expected**: Returns claims object with `app_metadata.billing` populated

#### 3. Check Supabase Local Logs

**Action**: Monitor logs while logging in

```bash
# Terminal 1: Watch Supabase logs
supabase logs --local

# Terminal 2: Trigger login
# Login via UI and watch logs for hook execution
```

**Look for**:
- Hook invocation logs
- Any errors in hook execution
- Claims population confirmation

#### 4. Common Local Issues & Fixes

**Issue 1: Hook Not Configured Locally**

**Check**: `supabase/config.toml` has hook enabled

```toml
[auth.hook.custom_access_token]
enabled = true
uri = "pg-functions://postgres/public/custom_access_token_hook"
```

**Fix**: Ensure hook is enabled and URI matches function name

---

**Issue 2: Function Missing Required Claims**

**Check**: JWT hook SQL function preserves all required claims

**Fix**: Ensure function includes all required JWT claims (lines 28-46 in your existing hook)

---

**Issue 3: Profile Data Missing**

**Check**: User's profile exists with billing data

```sql
SELECT
  id,
  plan_selected,
  subscription_status,
  current_period_end,
  billing_version
FROM profile
WHERE id = '<your-test-user-id>';
```

**Fix**: Ensure profile has data. If NULL, hook returns default values but may not work as expected.

---

**Issue 4: Using `pg-functions://` vs HTTP Hook**

**Problem**: `pg-functions://` may have issues in local development

**Alternative**: Switch to HTTP hook (Edge Function)

**File**: `supabase/functions/custom-access-token-hook/index.ts` (NEW)

```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

serve(async (req) => {
  try {
    const { user_id, claims } = await req.json();

    // Create Supabase client
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    // Get profile data
    const { data: profile, error } = await supabase
      .from("profile")
      .select("plan_selected, subscription_status, current_period_end, cancel_at_period_end, billing_version")
      .eq("id", user_id)
      .single();

    if (error) {
      console.error("Error fetching profile:", error);
      // Return original claims on error
      return new Response(JSON.stringify({ claims }), {
        headers: { "Content-Type": "application/json" },
      });
    }

    // Add billing to claims
    const updatedClaims = {
      ...claims,
      app_metadata: {
        ...claims.app_metadata,
        billing: {
          plan: profile.plan_selected || "free",
          status: profile.subscription_status || "active",
          current_period_end: profile.current_period_end,
          cancel_at_period_end: profile.cancel_at_period_end || false,
          billing_version: profile.billing_version || 1,
        },
      },
    };

    return new Response(JSON.stringify({ claims: updatedClaims }), {
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Hook error:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
});
```

**Update config.toml**:
```toml
[auth.hook.custom_access_token]
enabled = true
uri = "http://localhost:54321/functions/v1/custom-access-token-hook"
secrets = "env(AUTH_HOOK_SECRET)"
```

### Success Criteria

#### Investigation Complete When:
- [ ] Root cause of missing claims identified
- [ ] Fix applied (if needed)
- [ ] Hook executes reliably in local development
- [ ] JWT claims populated on first login (no verification page redirect)
- [ ] `METRIC: jwt_claims_missing` drops to <1% in logs

---

## Testing Strategy

### Unit Tests (Optional)

Given this is primarily middleware and page logic, unit tests are optional. Focus on integration and manual testing.

### Integration Tests

#### Test 1: Normal User Flow (JWT Claims Present)
```bash
# 1. Login as user with existing JWT claims
# 2. Navigate to protected route (e.g., /dashboard)
# Expected: Direct access, no redirect to verification page
# Check logs: Should NOT see "Missing JWT claims"
```

#### Test 2: Missing Claims Recovery Flow
```bash
# 1. Login as user
# 2. Manually strip JWT claims (see below for how)
# 3. Navigate to protected route
# Expected: Redirect to /auth/verify-session
# Expected: Verification page shows, retries 1-3 times
# Expected: Claims recovered, redirect back to original page
# Check logs: "Missing JWT claims" ‚Üí "session_verification_success"
```

**How to Manually Strip JWT Claims:**
```typescript
// In browser console:
// 1. Open DevTools ‚Üí Application ‚Üí Cookies
// 2. Find Supabase auth cookie (sb-<project>-auth-token)
// 3. Copy cookie value (JWT)
// 4. Decode JWT at jwt.io
// 5. Remove app_metadata.billing from payload
// 6. Re-encode JWT (note: signature will be invalid, but that's okay for testing recovery)
// Or simpler: Just delete the cookie and login again with hook disabled
```

#### Test 3: Verification Failure (Max Retries)
```bash
# 1. Disable JWT hook (set enabled = false in config.toml)
# 2. Restart Supabase: supabase restart
# 3. Login as user (claims won't populate)
# 4. Navigate to protected route
# Expected: Redirect to /auth/verify-session
# Expected: Retries 3 times, then shows failure screen
# Expected: "Sign In Again" button logs out and redirects to login
# Check logs: "session_verification_failed"
```

#### Test 4: Middleware Performance
```bash
# 1. Login as user with JWT claims
# 2. Navigate to multiple protected routes rapidly
# Expected: All requests <5ms in middleware
# Check logs: No "Slow middleware detected" warnings
# Verify: No database queries in middleware (grep for "SELECT")
```

#### Test 5: Error Handling
```bash
# 1. Simulate error during verification (e.g., network failure)
# 2. Navigate to protected route without claims
# Expected: Verification page shows error state
# Expected: "Try Again" button re-attempts verification
# Expected: "Sign In Again" button logs out
```

### Manual Testing Checklist

**Pre-Deployment:**
- [ ] Deploy to staging environment
- [ ] Test all flows above in staging
- [ ] Monitor metrics for 24 hours in staging
- [ ] Verify <1% of requests hit verification page
- [ ] Verify >95% verification success rate

**Post-Deployment:**
- [ ] Monitor production metrics for 1 week
- [ ] Check for spike in "jwt_claims_missing" metric
- [ ] Check for user complaints about verification page
- [ ] Verify no infinite redirect loops reported
- [ ] Verify middleware performance <5ms

### Performance Tests

#### Baseline Measurement
```bash
# Before changes (with database fallback):
# - Middleware latency with claims: <1ms
# - Middleware latency without claims: 50-200ms (database query)

# After changes (fail-closed):
# - Middleware latency with claims: <1ms
# - Middleware latency without claims: <1ms (redirect, no query)
# - Verification page latency: 2-6 seconds (retries with delays)
```

**How to Measure:**
```typescript
// Middleware already has performance monitoring (line ~212-228):
const startTime = performance.now();
// ... access control logic ...
const endTime = performance.now();
const duration = endTime - startTime;
console.log(`‚è±Ô∏è Middleware latency: ${duration.toFixed(2)}ms`);
```

### Load Testing (Optional)

If you want to stress-test the verification flow:

```bash
# Install k6 or similar load testing tool
# Create load test script:

import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 50 },  // Ramp up to 50 users
    { duration: '3m', target: 50 },  // Stay at 50 users
    { duration: '1m', target: 0 },   // Ramp down
  ],
};

export default function () {
  const res = http.get('http://localhost:3000/dashboard/test-user-id');
  check(res, {
    'status is 200 or 307': (r) => r.status === 200 || r.status === 307,
    'response time < 100ms': (r) => r.timings.duration < 100,
  });
  sleep(1);
}
```

---

## Migration Notes

### Deployment Strategy

**Step 1: Deploy to Staging**
1. Deploy all changes to staging environment
2. Run full test suite
3. Monitor for 24 hours
4. Verify metrics look healthy

**Step 2: Deploy to Production (Phased Rollout)**
1. Deploy during low-traffic period
2. Monitor error rates closely
3. Have rollback plan ready (see below)
4. If stable after 1 hour, consider success

**Step 3: Monitor and Adjust**
1. Monitor metrics for 1 week
2. Check verification page hit rate (<1% expected)
3. Check verification success rate (>95% expected)
4. Adjust retry attempts/delays if needed

### Rollback Plan

If issues arise, rollback is simple and fast:

**Immediate Rollback (< 5 minutes):**

1. Revert middleware changes:
```typescript
// In utils/supabase/middleware.ts
// Restore database fallback code:

if (!billing) {
  console.warn(
    `‚ö†Ô∏è Missing JWT claims for user ${user.id}, falling back to database`
  );
  const access = await getBasicUserAccess(user.id);
  plan = access.plan;
  hasPremiumAccess = access.hasPremiumAccess;
}
```

2. Redeploy immediately
3. System returns to original behavior
4. Users no longer redirected to verification page

**Full Rollback (< 10 minutes):**
1. Revert all code changes via git:
```bash
git revert <commit-hash>
git push
# Trigger deployment
```

2. Verification page remains (harmless, not used)
3. Can remove page in next deployment

### Data Migration

No data migration needed! This is purely a code change.

### Backward Compatibility

- ‚úÖ Verification page is new, doesn't break anything
- ‚úÖ Middleware changes are isolated
- ‚úÖ `getBasicUserAccess()` still exists (deprecated but functional)
- ‚úÖ No database schema changes
- ‚úÖ No API contract changes

### Known Limitations & Edge Cases

**Limitation 1: First-Time Login Race Condition**
- **Issue**: New user's first login may not have claims yet
- **Impact**: First request redirects to verification page
- **Mitigation**: Verification page recovers in 1-2 seconds
- **UX**: Minor delay on first login only

**Limitation 2: JWT Hook Failures**
- **Issue**: If JWT hook fails in production, all users affected
- **Impact**: All users redirect to verification page
- **Mitigation**: Monitor hook error rates, fix immediately
- **Rollback**: Revert to database fallback if widespread

**Edge Case 1: Verification Page in Middleware Check**
- **Issue**: Verification page itself needs JWT claims to render
- **Solution**: Exclude `/auth/verify-session` from middleware checks (Phase 1)
- **Verification**: Page loads even without claims

**Edge Case 2: Concurrent Requests During Verification**
- **Issue**: User opens multiple tabs, all trigger verification
- **Impact**: Multiple refresh attempts, but harmless
- **Mitigation**: `refreshSession()` is idempotent, safe to call multiple times

**Edge Case 3: Verification Fails on Onboarding Page**
- **Issue**: New users without plans may have NULL claims
- **Solution**: Middleware checks `!plan` separately and redirects to onboarding (line ~249)
- **Verification**: Onboarding flow unaffected

---

## Production Readiness Checklist

### Security
- [ ] No database fallback in middleware (single auth path)
- [ ] Fail-closed posture (missing claims = reject)
- [ ] No Stripe queries in middleware (performance)
- [ ] Verification page limits retries (no infinite loops)
- [ ] Logout on permanent failure (no stuck states)
- [ ] `getBasicUserAccess()` deprecated with warnings

### Performance
- [ ] Middleware latency <5ms (no queries)
- [ ] Verification page non-blocking (off hot path)
- [ ] <1% of requests hit verification page
- [ ] No performance degradation vs baseline

### Reliability
- [ ] Verification page handles all error cases
- [ ] Max retry limit prevents infinite loops
- [ ] Clear error messages for users
- [ ] Logout fallback for unrecoverable errors
- [ ] Metrics track recovery success rate

### Observability
- [ ] Metrics for missing claims rate
- [ ] Metrics for verification success/failure
- [ ] Metrics for verification errors
- [ ] Metrics documented in METRICS.md
- [ ] Alerts configured for anomalies

### User Experience
- [ ] Normal users unaffected (99%+ have claims)
- [ ] Edge case users see clear recovery flow
- [ ] Loading states during verification
- [ ] Error states with actionable CTAs
- [ ] No confusing UX or dead ends

### Testing
- [ ] All integration tests pass
- [ ] Manual testing complete
- [ ] Performance testing shows no regressions
- [ ] Load testing (optional) shows stability
- [ ] Staging deployment successful

### Documentation
- [ ] Implementation plan complete ‚úÖ (this document)
- [ ] Metrics documented in METRICS.md
- [ ] Code comments explain key decisions
- [ ] Deprecation warnings added
- [ ] Rollback plan documented

---

## Future Enhancements (Out of Scope)

**Enhancement 1: Proactive JWT Refresh (Ticket #0016)**
- Use Supabase Realtime to refresh JWT after webhooks
- Prevents claims from going stale
- Reduces verification page hit rate to ~0%

**Enhancement 2: HTTP-Based JWT Hook**
- Switch from `pg-functions://` to Edge Function
- Better debugging and error handling
- More reliable in local development

**Enhancement 3: Advanced Monitoring**
- Integrate with Datadog/Sentry for alerts
- Dashboard for JWT claim health
- Automated alerts on anomalies

**Enhancement 4: Graceful Degradation**
- If verification fails, grant limited access instead of logout
- Show banner: "Having trouble verifying your plan"
- Allow basic features while investigation ongoing

**Enhancement 5: Remove `getBasicUserAccess()` Entirely**
- Audit codebase for all usages
- Migrate to `getComprehensiveUserAccess()`
- Delete deprecated function

---

## References

- **Original Ticket**: `.claude/tickets/0020-remove-middleware-database-fallback.md`
- **Related Tickets**:
  - Ticket #0016: JWT Refresh After Webhook Updates
  - Ticket #0010: Migrate to JWT Claims Access Control (implemented)
- **Related Plans**:
  - `.claude/plans/0010-migrate-to-jwt-claims-access-control/251012-production-grade.md`
- **Current Implementation**:
  - Middleware: `utils/supabase/middleware.ts:142-150` (database fallback)
  - JWT Hook: `supabase/migrations/20251025154500_fix_jwt_hook_null_handling.sql`
  - Config: `supabase/config.toml:142-144` (hook config)
  - Access Control: `utils/billing/access-control.ts:37-88`
- **Supabase Documentation**:
  - [Custom Access Token Hooks](https://supabase.com/docs/guides/auth/auth-hooks/custom-access-token-hook)
  - [JWT Fields](https://supabase.com/docs/guides/auth/jwt-fields)
  - [Auth Hooks](https://supabase.com/docs/guides/auth/auth-hooks)

---

## Summary

This implementation plan eliminates the authorization bypass vulnerability by:

1. **Removing the insecure database fallback** from middleware
2. **Implementing fail-closed security** (missing claims = reject)
3. **Creating a dedicated recovery page** for the <1% of edge cases
4. **Adding comprehensive monitoring** to track system health
5. **Maintaining excellent performance** (zero queries in middleware)

The solution is:
- ‚úÖ **Secure**: Single auth path, no bypasses
- ‚úÖ **Scalable**: Zero queries, <1ms middleware latency
- ‚úÖ **Maintainable**: Simple logic, clear responsibilities
- ‚úÖ **Reliable**: Works in local and production
- ‚úÖ **Observable**: Metrics for all key events

**Next Steps:**
1. Review this plan
2. Implement Phase 1 (Remove database fallback)
3. Implement Phase 2 (Create verification page)
4. Implement Phase 3 (Add monitoring)
5. Test thoroughly in staging
6. Deploy to production with monitoring
7. Monitor metrics for 1 week
8. (Optional) Phase 4: Investigate local JWT hook issues if needed
