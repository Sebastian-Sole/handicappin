# JWT Claims-Based Access Control Implementation Plan

## Overview

This plan migrates middleware access control from database queries to JWT claims, improving performance by ~200x (from ~200ms to <1ms per request). We'll use Supabase's **Custom Access Token Hook** to automatically inject billing information into JWT claims without directly modifying the `auth.users` table.

## Current State Analysis

### What Exists Now:
- **Middleware** (`utils/supabase/middleware.ts:119`) queries database on every request via `getBasicUserAccess()`
- **Database Schema** (`db/schema.ts:39-43`) has `plan_selected`, `rounds_used`, `plan_selected_at` in `profile` table
- **Webhook Handlers** (`app/api/stripe/webhook/route.ts`) update `profile` table when billing changes
- **Performance Issue**: 50-200ms added latency per request due to database queries

### Key Constraints:
- ‚úÖ Existing webhook handlers work and throw errors properly for retries
- ‚úÖ Database schema is already set up correctly
- ‚ö†Ô∏è Must NOT directly modify `auth.users` table
- ‚ö†Ô∏è JWT claims can be stale (1-60 minutes until token refresh)
- ‚ö†Ô∏è Middleware runs on Edge Runtime (limited Node.js APIs)

### Key Discoveries:
- Supabase provides **Custom Access Token Hooks** for adding claims to JWTs
- Hook runs automatically before each token is issued (login, refresh)
- Claims are read-only in middleware via `user.app_metadata`
- Token refresh happens automatically ~every hour

## Desired End State

After implementation:
- ‚úÖ Middleware reads billing info from JWT claims (NO database queries)
- ‚úÖ Custom Access Token Hook syncs `profile` data to JWT claims automatically
- ‚úÖ Middleware latency reduced from 50-200ms to <1ms
- ‚úÖ Graceful fallback to database if claims missing
- ‚úÖ Manual refresh endpoint for immediate claim updates after checkout
- ‚úÖ All existing access control logic works identically

### Verification:
```bash
# Performance verification
pnpm test:performance  # Measure middleware latency

# Functional verification
pnpm test              # All tests pass
pnpm build             # TypeScript compilation succeeds

# Manual verification
# 1. Login ‚Üí Check JWT has billing claims
# 2. Complete checkout ‚Üí Immediate access granted
# 3. Webhook updates plan ‚Üí Claims updated on next refresh
```

## What We're NOT Doing

- ‚ùå Real-time claim updates (WebSocket/SSE)
- ‚ùå Migrating to Stripe Sync Engine (separate future enhancement)
- ‚ùå Removing `getComprehensiveUserAccess()` (still needed for page-level verification)
- ‚ùå Directly modifying `auth.users` table via triggers
- ‚ùå Subscription status tracking beyond plan type (separate ticket)
- ‚ùå Reconciliation jobs (separate ticket)

## Implementation Approach

We'll use **Supabase Custom Access Token Hooks** (official approach) to inject billing claims into JWTs. This approach:
1. Runs automatically on token issue/refresh
2. Reads from existing `profile` table
3. Adds custom claims without touching `auth.users` directly
4. Zero changes to webhook handlers (they already update `profile`)

The implementation is phased for safe, incremental deployment with rollback capability.

---

## Phase 1: Create Custom Access Token Hook

### Overview
Create a Postgres function that runs before each JWT is issued, reading billing data from the `profile` table and adding it to the JWT claims.

### Changes Required:

#### 1. Supabase Migration: Custom Access Token Hook

**File**: `supabase/migrations/YYYYMMDDHHMMSS_add_billing_jwt_hook.sql` (NEW)

**Changes**: Create SQL migration for the custom access token hook

```sql
-- Migration: Add Custom Access Token Hook for Billing Claims
-- This function runs automatically before each JWT is issued (login, refresh)
-- and adds billing information from the profile table to JWT claims.

-- Create the custom access token hook function
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  user_profile record;
BEGIN
  -- Extract claims from the event
  claims := event->'claims';

  -- Get user's billing information from profile table
  SELECT
    plan_selected,
    rounds_used,
    EXTRACT(EPOCH FROM plan_selected_at)::bigint as plan_selected_at
  INTO user_profile
  FROM public.profile
  WHERE id = (event->>'user_id')::uuid;

  -- Add billing information to claims
  -- This will be available in JWT as app_metadata.billing
  IF user_profile IS NOT NULL THEN
    claims := jsonb_set(
      claims,
      '{app_metadata, billing}',
      jsonb_build_object(
        'plan', COALESCE(user_profile.plan_selected, 'free'),
        'rounds_used', COALESCE(user_profile.rounds_used, 0),
        'plan_selected_at', user_profile.plan_selected_at,
        'updated_at', EXTRACT(EPOCH FROM NOW())::bigint
      )
    );
  ELSE
    -- User has no profile yet (shouldn't happen, but handle gracefully)
    claims := jsonb_set(
      claims,
      '{app_metadata, billing}',
      jsonb_build_object(
        'plan', 'free',
        'rounds_used', 0,
        'plan_selected_at', null,
        'updated_at', EXTRACT(EPOCH FROM NOW())::bigint
      )
    );
  END IF;

  -- Return modified claims
  RETURN jsonb_set(event, '{claims}', claims);
END;
$$;

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
GRANT SELECT ON public.profile TO supabase_auth_admin;

-- Add comment for documentation
COMMENT ON FUNCTION public.custom_access_token_hook IS
  'Custom Access Token Hook: Injects billing information from profile table into JWT claims. Runs automatically on token issue/refresh.';
```

#### 2. Configure Hook in Supabase Dashboard

**Manual Step**: Enable the custom access token hook in Supabase Dashboard

**Instructions**:
1. Go to Supabase Dashboard ‚Üí Authentication ‚Üí Hooks
2. Select "Custom Access Token Hook"
3. Choose the function: `public.custom_access_token_hook`
4. Enable the hook
5. Test with a test user login

**Alternative (Supabase CLI)**:
```bash
# If using Supabase CLI v1.27.0+
supabase hooks create custom_access_token \
  --function public.custom_access_token_hook \
  --enabled
```

### Success Criteria:

#### Automated Verification:
- [ ] Migration applies successfully: `supabase db push`
- [ ] Function exists in database: `SELECT * FROM pg_proc WHERE proname = 'custom_access_token_hook'`
- [ ] Permissions granted correctly: `SELECT has_function_privilege('supabase_auth_admin', 'public.custom_access_token_hook', 'EXECUTE')`

#### Manual Verification:
- [ ] Login as test user ‚Üí inspect JWT ‚Üí verify `app_metadata.billing` exists
- [ ] JWT contains: `plan`, `rounds_used`, `plan_selected_at`, `updated_at`
- [ ] Hook function executes without errors (check Supabase logs)
- [ ] Token refresh updates billing claims correctly

---

## Phase 2: Update Middleware to Read JWT Claims

### Overview
Refactor middleware to read billing information from JWT claims instead of querying the database. Include graceful fallback for migration safety.

### Changes Required:

#### 1. Middleware: Read JWT Claims

**File**: `utils/supabase/middleware.ts`

**Changes**: Replace database query with JWT claim reading

```typescript
export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const { pathname } = request.nextUrl;

  const publicPaths = [
    "/login",
    "/signup",
    "/about",
    "/api",
    "/verify-email",
    "/forgot-password",
    "/",
  ];

  const isPublic = publicPaths.some((path) => pathname.startsWith(path));

  if (!user && pathname === "/update-password") {
    const resetToken = request.nextUrl.searchParams.get("token");
    if (!resetToken) {
      const url = request.nextUrl.clone();
      url.pathname = "/login";
      return NextResponse.redirect(url);
    }

    try {
      const secret = new TextEncoder().encode(process.env.RESET_TOKEN_SECRET);
      const { payload } = await jwtVerify<PasswordResetPayload>(
        resetToken,
        secret
      );

      if (payload.metadata.type === "password-reset") {
        const url = request.nextUrl.clone();
        url.searchParams.set("email", payload.email);
        return NextResponse.rewrite(url);
      }
    } catch (err) {
      console.error("Invalid reset token:", err);
      const url = request.nextUrl.clone();
      url.pathname = "/login";
      return NextResponse.redirect(url);
    }
  }

  if (!user && !isPublic) {
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    return NextResponse.redirect(url);
  }

  if (
    user &&
    (pathname.startsWith("/login") || pathname.startsWith("/signup"))
  ) {
    const url = request.nextUrl.clone();
    url.pathname = "/";
    return NextResponse.redirect(url);
  }

  // Check access control for authenticated users on protected routes
  const premiumPaths = PREMIUM_PATHS;

  if (
    user &&
    !isPublic &&
    !pathname.startsWith("/onboarding") &&
    !pathname.startsWith("/billing") &&
    !pathname.startsWith("/upgrade")
  ) {
    console.log("üîç Middleware: Checking access for user:", user.id);

    try {
      // NEW: Read billing info from JWT claims (NO DATABASE QUERY!)
      const billing = user.app_metadata?.billing as
        | {
            plan?: string;
            rounds_used?: number;
            plan_selected_at?: number;
            updated_at?: number;
          }
        | undefined;

      let plan = billing?.plan || null;
      let roundsUsed = billing?.rounds_used || 0;

      // Graceful fallback to database if claims missing (during migration)
      if (!billing) {
        console.warn(
          `‚ö†Ô∏è Missing JWT claims for user ${user.id}, falling back to database`
        );
        const access = await getBasicUserAccess(user.id);
        plan = access.plan;
        roundsUsed =
          access.remainingRounds === Infinity
            ? 0
            : 25 - access.remainingRounds;
      } else {
        // JWT claims present - log for monitoring
        const claimsAge = billing.updated_at
          ? Date.now() / 1000 - billing.updated_at
          : Infinity;

        if (claimsAge > 3600) {
          console.warn(
            `‚è∞ Stale billing claims for user ${user.id}: ${Math.floor(
              claimsAge / 60
            )} minutes old`
          );
        } else {
          console.log(
            `‚úÖ Using JWT claims for user ${user.id} (age: ${Math.floor(
              claimsAge / 60
            )}m)`
          );
        }
      }

      console.log("üìä Middleware: User access:", {
        plan,
        roundsUsed,
        source: billing ? "jwt" : "database",
      });

      // Check if user needs onboarding (no plan selected)
      if (!plan) {
        console.log(
          "üö´ Middleware: No plan selected, redirecting to onboarding"
        );
        const url = request.nextUrl.clone();
        url.pathname = "/onboarding";
        return NextResponse.redirect(url);
      }

      // Check premium routes
      const isPremiumRoute = premiumPaths.some((path) =>
        pathname.startsWith(path)
      );

      if (isPremiumRoute) {
        const hasPremiumAccess =
          plan === "premium" || plan === "unlimited" || plan === "lifetime";

        if (!hasPremiumAccess) {
          console.log(
            "üö´ Middleware: Premium route blocked, redirecting to upgrade"
          );
          const url = request.nextUrl.clone();
          url.pathname = "/upgrade";
          return NextResponse.redirect(url);
        }
      }

      console.log("‚úÖ Middleware: Access granted for plan:", plan);
    } catch (error) {
      console.error("‚ùå Middleware: Error checking access:", error);
      // On error, redirect to onboarding to be safe
      const url = request.nextUrl.clone();
      url.pathname = "/onboarding";
      return NextResponse.redirect(url);
    }
  }

  return supabaseResponse;
}
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compilation succeeds: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] No runtime errors in middleware

#### Manual Verification:
- [ ] User with JWT claims can access protected routes without database query
- [ ] User without JWT claims falls back to database query gracefully
- [ ] Logging shows "Using JWT claims" for users with claims
- [ ] Logging shows "falling back to database" for users without claims
- [ ] Access control logic works identically to before (no regressions)
- [ ] Premium routes still blocked for free users
- [ ] Onboarding redirect works for users without plan

---

## Phase 3: Add JWT Refresh Endpoint

### Overview
Create an API endpoint to force JWT token refresh, enabling immediate access after checkout or subscription changes.

### Changes Required:

#### 1. JWT Refresh API Endpoint

**File**: `app/api/auth/refresh-claims/route.ts` (NEW)

**Changes**: Create new API route for manual JWT refresh

```typescript
import { createClient } from "@/utils/supabase/server";
import { NextRequest, NextResponse } from "next/server";

/**
 * POST /api/auth/refresh-claims
 *
 * Forces a JWT token refresh to immediately update billing claims.
 * This is useful after checkout completion or subscription changes
 * to avoid waiting for the automatic token refresh (~1 hour).
 *
 * Returns:
 * - 200: Success with updated billing claims
 * - 401: Unauthorized (no user session)
 * - 500: Internal server error
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error("JWT refresh failed: No authenticated user", userError);
      return NextResponse.json(
        { error: "Unauthorized", message: "No authenticated user" },
        { status: 401 }
      );
    }

    console.log(`üîÑ JWT Refresh requested for user: ${user.id}`);

    // Force token refresh by updating user metadata
    // This triggers Supabase to issue a new JWT with updated claims
    // The custom access token hook will automatically inject latest billing data
    const { data, error } = await supabase.auth.updateUser({
      data: {
        last_claims_refresh: new Date().toISOString(),
      },
    });

    if (error) {
      console.error("JWT refresh failed:", error);
      return NextResponse.json(
        { error: "Refresh failed", message: error.message },
        { status: 500 }
      );
    }

    const billing = data.user?.app_metadata?.billing;

    console.log("‚úÖ JWT refresh successful:", {
      userId: user.id,
      billing,
    });

    return NextResponse.json(
      {
        success: true,
        billing,
        message: "JWT claims refreshed successfully",
      },
      { status: 200 }
    );
  } catch (error) {
    console.error("JWT refresh error:", error);
    return NextResponse.json(
      {
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
```

#### 2. Update Checkout Success Page

**File**: `app/billing/success/page.tsx`

**Changes**: Add JWT refresh after checkout

```typescript
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { createClient } from "@/utils/supabase/client";

export default function BillingSuccessPage() {
  const router = useRouter();
  const [status, setStatus] = useState<"loading" | "success" | "error">(
    "loading"
  );
  const [userId, setUserId] = useState<string | null>(null);

  useEffect(() => {
    async function refreshClaims() {
      try {
        // Get current user
        const supabase = createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          router.push("/login");
          return;
        }

        setUserId(user.id);

        // Refresh JWT claims immediately
        console.log("üîÑ Refreshing JWT claims after checkout...");
        const response = await fetch("/api/auth/refresh-claims", {
          method: "POST",
        });

        if (!response.ok) {
          throw new Error("Failed to refresh claims");
        }

        const data = await response.json();
        console.log("‚úÖ JWT claims refreshed:", data);

        setStatus("success");

        // Wait 2 seconds to show success message, then redirect
        setTimeout(() => {
          router.push(`/dashboard/${user.id}`);
          router.refresh(); // Force Next.js to re-run middleware
        }, 2000);
      } catch (error) {
        console.error("Failed to refresh claims:", error);
        // Continue anyway - claims will refresh naturally within ~1 hour
        setStatus("success");
        setTimeout(() => {
          if (userId) {
            router.push(`/dashboard/${userId}`);
            router.refresh();
          }
        }, 2000);
      }
    }

    refreshClaims();
  }, [router]);

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-2xl mx-auto text-center">
        <div className="mb-8">
          {status === "loading" && (
            <>
              <div className="text-6xl mb-4">‚è≥</div>
              <h1 className="text-4xl font-bold mb-4">Processing...</h1>
              <p className="text-lg text-gray-600 mb-8">
                Activating your subscription...
              </p>
            </>
          )}

          {status === "success" && (
            <>
              <div className="text-6xl mb-4">‚úÖ</div>
              <h1 className="text-4xl font-bold mb-4">Welcome to Premium!</h1>
              <p className="text-lg text-gray-600 mb-8">
                Your subscription is now active. You now have access to all
                premium features including the dashboard, advanced calculators,
                and unlimited rounds.
              </p>
              <p className="text-sm text-gray-500">
                Redirecting to dashboard...
              </p>
            </>
          )}

          {status === "error" && (
            <>
              <div className="text-6xl mb-4">‚ö†Ô∏è</div>
              <h1 className="text-4xl font-bold mb-4">Almost There!</h1>
              <p className="text-lg text-gray-600 mb-8">
                Your subscription is being processed. You'll have access within
                a few minutes.
              </p>
            </>
          )}
        </div>

        <div className="space-y-4">
          <Link
            href={userId ? `/dashboard/${userId}` : "/"}
            className="block w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition"
          >
            Go to Dashboard
          </Link>
          <Link
            href="/"
            className="block w-full border border-gray-300 px-6 py-3 rounded-lg hover:bg-gray-50 transition"
          >
            Back to Home
          </Link>
        </div>

        <div className="mt-8 pt-8 border-t">
          <p className="text-sm text-gray-600">
            Need help? Contact us at{" "}
            <a
              href="mailto:support@handicappin.com"
              className="text-blue-600 hover:underline"
            >
              support@handicappin.com
            </a>
          </p>
        </div>
      </div>
    </div>
  );
}
```

#### 3. Add Client-Side Supabase Client (if not exists)

**File**: `utils/supabase/client.ts` (check if exists, if not create)

**Changes**: Create client-side Supabase client

```typescript
import { createBrowserClient } from "@supabase/ssr";
import { Database } from "@/types/supabase";

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compilation succeeds: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] API endpoint returns 401 when not authenticated
- [ ] API endpoint returns 200 with billing data when authenticated

#### Manual Verification:
- [ ] Complete checkout ‚Üí redirected to success page
- [ ] Success page calls refresh endpoint automatically
- [ ] JWT claims updated immediately (check browser DevTools ‚Üí Application ‚Üí Cookies)
- [ ] User redirected to dashboard after 2 seconds
- [ ] Dashboard loads successfully with new premium access
- [ ] No database query logged in middleware (check console for "Using JWT claims")

---

## Phase 4: Testing & Monitoring

### Overview
Comprehensive testing to verify performance improvements, functional correctness, and add monitoring for production.

### Changes Required:

#### 1. Add Performance Monitoring to Middleware

**File**: `utils/supabase/middleware.ts`

**Changes**: Add performance timing logs

```typescript
// At the start of the access control block (line ~115)
if (
  user &&
  !isPublic &&
  !pathname.startsWith("/onboarding") &&
  !pathname.startsWith("/billing") &&
  !pathname.startsWith("/upgrade")
) {
  const startTime = performance.now(); // Add timing
  console.log("üîç Middleware: Checking access for user:", user.id);

  try {
    // ... existing code ...

    const endTime = performance.now();
    const duration = endTime - startTime;

    console.log(`‚è±Ô∏è Middleware access check took: ${duration.toFixed(2)}ms`, {
      userId: user.id,
      source: billing ? "jwt" : "database",
    });

    // Alert if middleware is slow (>10ms with JWT, >100ms with DB)
    const threshold = billing ? 10 : 100;
    if (duration > threshold) {
      console.warn(
        `üêå Slow middleware detected: ${duration.toFixed(2)}ms (threshold: ${threshold}ms)`,
        {
          userId: user.id,
          source: billing ? "jwt" : "database",
          pathname,
        }
      );
    }
  } catch (error) {
    // ... existing error handling ...
  }
}
```

#### 2. Update Access Control Documentation

**File**: `utils/billing/access-control.ts`

**Changes**: Update comments to reflect new JWT-based approach

```typescript
/**
 * Lightweight version of access control for Edge Runtime (middleware)
 * Reads billing info from JWT claims for optimal performance (<1ms).
 *
 * ‚ö†Ô∏è PERFORMANCE NOTE: This function now reads from JWT claims by default,
 * with graceful fallback to database if claims are missing.
 *
 * JWT claims are updated automatically via Custom Access Token Hook on:
 * - User login
 * - Token refresh (~every 1 hour)
 * - Manual refresh via /api/auth/refresh-claims
 *
 * ‚ö†Ô∏è STALENESS NOTE: JWT claims can be stale (1-60 minutes). This is acceptable
 * because middleware is a coarse filter. Page components SHOULD still use
 * getComprehensiveUserAccess() which verifies with Stripe directly.
 *
 * This middleware check is a performance optimization to avoid database queries
 * on every request, but should be paired with Stripe verification at the page level.
 */
export async function getBasicUserAccess(
  userId: string
): Promise<FeatureAccess> {
  // This function is now only used as a fallback when JWT claims are missing
  // In normal operation, middleware reads directly from JWT claims
  const supabase = await createServerComponentClient();

  // Get user profile
  const { data: profile, error: profileError } = await supabase
    .from("profile")
    .select("plan_selected, rounds_used")
    .eq("id", userId)
    .single();

  if (profileError) {
    console.error("Error fetching profile:", profileError);
    return createNoAccessResponse();
  }

  // No plan selected yet
  if (!profile.plan_selected) {
    return createNoAccessResponse();
  }

  // Free plan
  if (profile.plan_selected === "free") {
    return createFreeTierResponse(profile.rounds_used || 0);
  }

  // Paid plan (trust database, Stripe verification happens in page components)
  return {
    plan: profile.plan_selected as "premium" | "unlimited" | "lifetime",
    hasAccess: true,
    hasPremiumAccess: true,
    hasUnlimitedRounds: hasUnlimitedRounds(profile.plan_selected),
    remainingRounds: Infinity,
    status: "active",
    isLifetime: profile.plan_selected === "lifetime",
    currentPeriodEnd:
      profile.plan_selected === "lifetime"
        ? new Date("2099-12-31T23:59:59.000Z")
        : null,
  };
}
```

### Testing Strategy

#### Unit Tests (Future)
- Test JWT claim decoding in middleware
- Test fallback to database when claims missing
- Test stale claim detection
- Test refresh endpoint success/failure cases

#### Integration Tests (Manual)
- [ ] **Test 1: New User Signup**
  - Create new account
  - Check JWT contains billing claims
  - Select plan during onboarding
  - Verify claims updated on next page load

- [ ] **Test 2: Checkout Flow**
  - Complete Stripe checkout (test mode)
  - Verify redirect to success page
  - Verify JWT refresh triggered
  - Verify immediate dashboard access
  - Check middleware logs for "Using JWT claims"

- [ ] **Test 3: Webhook Updates**
  - Trigger Stripe webhook (subscription.updated)
  - Database updated via existing handler
  - User logs out and back in
  - Verify JWT has updated billing info

- [ ] **Test 4: Token Refresh**
  - Login as user
  - Wait 5+ minutes (or force token expiry)
  - Refresh page
  - Verify new JWT issued with fresh claims

- [ ] **Test 5: Fallback Behavior**
  - Login as user without JWT claims (legacy user)
  - Verify middleware falls back to database
  - Check logs for "falling back to database"
  - Verify access control still works correctly

#### Performance Tests
- [ ] **Before Migration Baseline**
  - Measure middleware latency with database queries
  - Record: p50, p95, p99 latencies
  - Expected: 50-200ms

- [ ] **After Migration Measurement**
  - Measure middleware latency with JWT claims
  - Record: p50, p95, p99 latencies
  - Expected: <1ms (99% improvement)

- [ ] **Load Test**
  - Simulate 100 requests/second
  - Verify no database connection pool exhaustion
  - Verify all requests use JWT claims
  - Verify middleware stays under 5ms

#### Manual Testing Checklist
- [ ] Login ‚Üí JWT has billing claims
- [ ] Logout/Login ‚Üí Fresh claims loaded
- [ ] Upgrade to premium ‚Üí Immediate access granted (via refresh endpoint)
- [ ] Downgrade to free ‚Üí Access revoked (within token refresh window)
- [ ] Subscription expires ‚Üí Access revoked (within token refresh window)
- [ ] Force refresh endpoint ‚Üí Immediate claim update
- [ ] Premium route access works correctly
- [ ] Onboarding redirect works correctly
- [ ] No regression in existing functionality

### Success Criteria:

#### Automated Verification:
- [ ] All TypeScript types pass: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] No console errors in development

#### Manual Verification:
- [ ] Middleware latency reduced by >95% (from ~100ms to <5ms)
- [ ] JWT claims present for all authenticated users
- [ ] Fallback works when claims missing
- [ ] Monitoring logs show claim age and source
- [ ] No access control regressions
- [ ] Checkout flow grants immediate access

---

## Performance Considerations

### Expected Performance Gains:

**Before (Database Query):**
- Middleware latency: 50-200ms per request
- Database queries: 100 req/s = 100 DB queries/s
- Connection pool pressure: High
- Single point of failure: Database

**After (JWT Claims):**
- Middleware latency: <1ms per request (99% improvement)
- Database queries: 0 (JWT decode is CPU-only)
- Connection pool pressure: None from middleware
- Single point of failure: None (JWT is self-contained)

### Staleness Trade-offs:

**Token Refresh Timing:**
- Automatic refresh: ~1 hour
- Manual refresh: Immediate (via `/api/auth/refresh-claims`)
- Login/Logout: Immediate (new token issued)

**Acceptable Staleness:**
- ‚úÖ Upgrades: Immediate via refresh endpoint
- ‚úÖ New signups: Immediate via hook on first token
- ‚ö†Ô∏è Downgrades: 1-60 minute delay (acceptable)
- ‚ö†Ô∏è Subscription expiry: 1-60 minute delay (acceptable)

**Mitigation:**
- Call refresh endpoint after critical operations (checkout)
- Page components still verify with Stripe for sensitive actions
- Middleware is a coarse filter, not source of truth

---

## Migration Notes

### Deployment Strategy:

**Phase 1: Deploy Hook (No Breaking Changes)**
1. Apply migration: `supabase db push`
2. Enable hook in Supabase Dashboard
3. Test with development users
4. Monitor logs for errors
5. No code changes yet ‚Üí fully backward compatible

**Phase 2: Deploy Middleware Changes (Graceful Fallback)**
1. Deploy updated middleware code
2. Middleware reads JWT claims first
3. Falls back to database if claims missing
4. Both approaches work simultaneously
5. Monitor ratio of JWT vs database usage

**Phase 3: Deploy Refresh Endpoint (Optional but Recommended)**
1. Deploy refresh endpoint
2. Update success page to call endpoint
3. Test checkout flow
4. Verify immediate access

**Phase 4: Monitor and Optimize**
1. Monitor middleware latency (should be <5ms)
2. Monitor claim freshness
3. Monitor fallback usage (should decrease to 0%)
4. Once confident, remove fallback (future optimization)

### Rollback Plan:

If issues arise, rollback is simple:

**Immediate Rollback (Code Level):**
```typescript
// In middleware, temporarily force database fallback
const billing = null; // Force fallback to database
// OR
if (!billing || true) { // Always use database
  const access = await getBasicUserAccess(user.id);
  // ... existing code
}
```

**Full Rollback (Remove Hook):**
1. Disable hook in Supabase Dashboard
2. Redeploy previous middleware code
3. System returns to original database-query behavior
4. No data loss (database unchanged)

### Edge Cases:

**Missing Claims:**
- New users: Hook creates claims on first login
- Legacy users: Middleware falls back to database
- Hook failure: Fallback ensures access control still works

**Stale Claims:**
- Detection: Middleware logs claims older than 1 hour
- Impact: Minor (downgrades delayed by <1 hour)
- Mitigation: Manual refresh endpoint for critical operations

**Hook Failure:**
- Database trigger would fail loudly
- Fallback ensures users can still authenticate
- Monitor Supabase logs for hook errors

---

## Testing Requirements

See Phase 4 above for comprehensive testing checklist.

---

## References

- Original ticket: `.claude/tickets/0010-migrate-to-jwt-claims-access-control.md`
- Related documentation:
  - `.claude/plans/0004-refactor-stripe-billing-code/JWT_CLAIMS_MIGRATION.md`
  - `.claude/plans/0004-refactor-stripe-billing-code/SECURITY_NOTES.md`
- Supabase documentation:
  - [Custom Access Token Hooks](https://supabase.com/docs/guides/auth/auth-hooks/custom-access-token-hook)
  - [JWT Fields](https://supabase.com/docs/guides/auth/jwt-fields)
  - [JWTs in Supabase](https://supabase.com/docs/guides/auth/jwts)
- Current implementation:
  - Middleware: `utils/supabase/middleware.ts:119`
  - Access control: `utils/billing/access-control.ts:26`
  - Webhook handlers: `app/api/stripe/webhook/route.ts`

---

## Future Enhancements (Out of Scope)

- Add Supabase Stripe Sync Engine for better webhook reliability
- Real-time claim updates via WebSocket/SSE
- Subscription status tracking (active, past_due, canceled)
- Reconciliation job to detect DB/Stripe mismatches
- Remove database fallback (after monitoring confirms 100% JWT coverage)
- Add automated performance testing in CI/CD
