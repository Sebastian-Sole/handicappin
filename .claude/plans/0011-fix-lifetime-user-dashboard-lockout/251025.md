# Fix Lifetime User Dashboard Lockout - Implementation Plan

## Overview

Fix critical access control bug where lifetime plan users are locked out of the dashboard and premium features. The `getComprehensiveUserAccess()` function incorrectly queries Stripe subscriptions for lifetime plans, which are one-time payments, not subscriptions. This causes the function to return no access, blocking users who have paid $199.

## Current State Analysis

### What Works:

- **Webhook handles lifetime payments correctly** (webhook/route.ts:158-204)

  - Sets `plan_selected='lifetime'` in database ✅
  - Sets `subscription_status='active'` ✅
  - Sets `current_period_end=null` for lifetime (no expiry) ✅
  - Increments `billing_version` to trigger JWT refresh ✅

- **`getBasicUserAccess()` handles lifetime correctly** (access-control.ts:64-77)

  - Trusts database value for paid plans ✅
  - Returns lifetime access without Stripe query ✅
  - Sets `currentPeriodEnd` to 2099-12-31 ✅
  - Sets `isLifetime=true` ✅

- **Middleware uses JWT claims** (middleware.ts:132-197)
  - Reads billing info from JWT app_metadata ✅
  - Only falls back to `getBasicUserAccess()` if claims missing ✅

### What's Broken:

- **`getComprehensiveUserAccess()` treats lifetime as subscription** (access-control.ts:175-186)
  - Lines 176-179: Includes `lifetime` in subscription check ❌
  - Line 181: Calls `getUserAccess(userId)` for lifetime ❌
  - `getUserAccess()` queries `stripe.subscriptions.list` (line 103) ❌
  - Returns `null` because lifetime has NO subscription ❌
  - Falls back to `createNoAccessResponse()` (line 195) ❌
  - **Result**: User locked out despite valid payment

### Where This Function is Called:

1. **tRPC procedures** - Use it for server-side authorization
2. **Page components** - Use it for comprehensive checks (per comments in access-control.ts:32)
3. **`canAddRound()` helper** - Uses it to check round limits (line 202)

### Root Cause:

The code lumps lifetime with premium/unlimited in the subscription verification block, but:

- **Premium/Unlimited** = Recurring subscriptions → Query Stripe ✅
- **Lifetime** = One-time payment → NO subscription → Trust database ✅

### Evidence from Webhook Events:

```
Lifetime purchase (mode=payment):
  ✅ checkout.session.completed
  ✅ charge.succeeded
  ✅ payment_intent.succeeded
  ❌ NO customer.subscription.created (expected!)

Premium/Unlimited purchase (mode=subscription):
  ✅ checkout.session.completed
  ✅ customer.subscription.created
  ✅ invoice.paid
```

### Key Discoveries:

- Database has all needed fields: `plan_selected`, `subscription_status`, `current_period_end`, `billing_version`
- Webhook sets these fields correctly for lifetime plans
- `getBasicUserAccess()` already implements the correct pattern
- Only `getComprehensiveUserAccess()` needs fixing

## Desired End State

### After Implementation:

1. `getComprehensiveUserAccess()` handles lifetime plans correctly
2. Lifetime users can access `/dashboard` and all premium routes immediately after payment
3. No Stripe API calls for lifetime users (performance improvement: ~200-500ms → ~20-50ms)
4. Premium/Unlimited subscription users continue working (no regression)
5. Free tier users still blocked from premium routes

### Verification:

- Manual test: Purchase lifetime plan with Stripe test card
- Verify immediate dashboard access after webhook processes payment
- Check all premium routes accessible (`/calculators`, `/dashboard`)
- Confirm no Stripe API calls in server logs for lifetime users
- Test that free users still redirected to upgrade page

## What We're NOT Doing

- NOT refactoring the entire access control system
- NOT adding payment verification via Stripe Charges API (webhook signature verification is sufficient)
- NOT changing webhook handling (already works correctly)
- NOT modifying middleware (JWT claims handle lifetime correctly)
- NOT changing database schema (all needed fields exist)
- NOT updating `getBasicUserAccess()` (already correct)
- NOT adding analytics or tracking
- NOT implementing subscription management features
- NOT migrating to different billing provider

## Implementation Approach

**Strategy**: Follow the pattern already established in `getBasicUserAccess()` - trust the database value for lifetime plans instead of querying Stripe.

**Why This is Safe**:

1. Webhook validates payment via Stripe signature verification (cryptographically secure)
2. If `plan_selected='lifetime'` exists in database, payment MUST have succeeded
3. Webhook would have failed/retried if payment didn't complete
4. No risk of false positives - plan only set after successful webhook
5. Pattern already used successfully in `getBasicUserAccess()`

**Performance Impact**:

- **Before**: Database query + Stripe API call = ~200-500ms
- **After**: Database query only = ~20-50ms
- **Improvement**: 4-10x faster for lifetime users

## Phase 1: Fix `getComprehensiveUserAccess()` Function

### Overview

Modify `getComprehensiveUserAccess()` to handle lifetime plans separately from subscription plans, mirroring the correct pattern already used in `getBasicUserAccess()`.

### Changes Required:

#### 1. Update Access Control Logic

**File**: `utils/billing/access-control.ts`

**Change**: Split lifetime plan handling from subscription plans (lines 175-192)

**Current Code** (lines 175-192):

```typescript
// 4. Check if user selected recurring paid plan - verify with Stripe
if (
  profile.plan_selected === "premium" ||
  profile.plan_selected === "unlimited" ||
  profile.plan_selected === "lifetime" // ❌ BUG: Lifetime is NOT a subscription!
) {
  const subscriptionAccess = await getUserAccess(userId);

  if (subscriptionAccess?.hasAccess) {
    // Stripe confirms active subscription
    return subscriptionAccess;
  }

  // Stripe says no active subscription (expired/cancelled)
  // Fall back to free tier
  console.log("Subscription expired, falling back to free tier");
  // Note: Webhook should have updated plan_selected to 'free', but handle gracefully
}

// 5. No plan selected yet - needs onboarding
return createNoAccessResponse();
```

**New Code**:

```typescript
// 3. LIFETIME plan (one-time payment, NOT subscription)
if (profile.plan_selected === "lifetime") {
  // Lifetime: Trust database value set by webhook after successful payment
  // No need to query Stripe - if plan_selected='lifetime', payment succeeded
  // Webhook validates payment via signature verification (cryptographically secure)
  return {
    plan: "lifetime",
    hasAccess: true,
    hasPremiumAccess: true,
    hasUnlimitedRounds: true,
    remainingRounds: Infinity,
    status: "active",
    isLifetime: true,
    currentPeriodEnd: new Date("2099-12-31T23:59:59.000Z"), // Never expires
  };
}

// 4. PREMIUM/UNLIMITED plans (recurring subscriptions)
if (
  profile.plan_selected === "premium" ||
  profile.plan_selected === "unlimited"
) {
  const subscriptionAccess = await getUserAccess(userId);

  if (subscriptionAccess?.hasAccess) {
    // Stripe confirms active subscription
    return subscriptionAccess;
  }

  // Subscription expired/cancelled - fall back to free tier
  console.log("Subscription expired, falling back to free tier");
  // Note: Webhook should have updated plan_selected to 'free', but handle gracefully
}

// 5. No plan selected yet - needs onboarding
return createNoAccessResponse();
```

**Explanation**:

- Move lifetime check BEFORE subscription check (new step 3)
- Return lifetime access object directly (matches pattern in `getBasicUserAccess()`)
- Remove lifetime from subscription verification block (step 4)
- Add comment explaining why we trust database value (webhook security)
- Set `currentPeriodEnd` to far future date (2099-12-31) to indicate no expiry

### Success Criteria:

#### Automated Verification:

- [x] TypeScript compilation passes: `pnpm build`
- [x] No type errors in access-control.ts
- [x] Linting passes: `pnpm lint`

#### Manual Verification:

- [ ] Purchase lifetime plan using Stripe test card (4242 4242 4242 4242)
- [ ] Verify webhook processes successfully (check server logs)
- [ ] Verify `plan_selected='lifetime'` in database after purchase
- [ ] Access `/dashboard` immediately after purchase - should succeed
- [ ] Access `/calculators` route - should succeed
- [ ] Verify no Stripe API calls in server logs for lifetime user access checks
- [ ] Check profile page shows correct plan information
- [ ] Test after logout/login (JWT refresh) - access should persist

## Phase 2: Regression Testing

### Overview

Verify that other plan types still work correctly and no new bugs were introduced.

### Changes Required:

None - this is testing only.

### Testing Steps:

#### 1. Free Tier Users

- [ ] Create new account, select free plan
- [ ] Verify can access non-premium routes
- [ ] Verify blocked from `/dashboard` → redirected to `/upgrade`
- [ ] Verify blocked from `/calculators` → redirected to `/upgrade`
- [ ] Verify `getComprehensiveUserAccess()` returns free tier response

#### 2. Premium Subscription Users

- [ ] Purchase premium plan using Stripe test card
- [ ] Verify webhook creates subscription
- [ ] Verify `plan_selected='premium'` in database
- [ ] Verify can access `/dashboard` and `/calculators`
- [ ] Verify `getComprehensiveUserAccess()` queries Stripe and returns premium access
- [ ] Cancel subscription in Stripe dashboard
- [ ] Verify webhook reverts to free tier after cancellation
- [ ] Verify blocked from premium routes after cancellation

#### 3. Unlimited Subscription Users

- [ ] Purchase unlimited plan using Stripe test card
- [ ] Verify same behavior as premium (above)

#### 4. Users Without Plan

- [ ] Create new account, don't select plan
- [ ] Verify redirected to `/onboarding` when accessing protected routes
- [ ] Verify `getComprehensiveUserAccess()` returns no access response

### Success Criteria:

#### Automated Verification:

- [ ] No console errors in browser dev tools
- [ ] No server errors in logs

#### Manual Verification:

- [ ] All test scenarios above pass
- [ ] No regressions in existing functionality
- [ ] Middleware continues to work correctly
- [ ] JWT claims continue to provide fast access checks

## Phase 3: Edge Case Testing

### Overview

Test unusual scenarios to ensure robustness.

### Edge Cases to Test:

#### 1. Stale JWT Claims

- [ ] Purchase lifetime plan
- [ ] Don't refresh browser (keep old JWT claims)
- [ ] Wait for fallback to `getComprehensiveUserAccess()`
- [ ] Verify access still granted via database query

#### 2. Manual Database Manipulation

- [ ] Manually set `plan_selected='lifetime'` in database
- [ ] Verify access granted (demonstrates trust in database)
- [ ] Note: In production, only webhook should set this field

#### 3. Concurrent Purchases

- [ ] Attempt multiple lifetime purchases for same user
- [ ] Verify only charged once (Stripe handles this)
- [ ] Verify database updated correctly

#### 4. Session Expiry During Payment

- [ ] Start checkout flow
- [ ] Let session expire
- [ ] Complete payment
- [ ] Verify webhook still updates database correctly

#### 5. Browser Change Mid-Payment

- [ ] Start checkout on Chrome
- [ ] Complete payment on Safari
- [ ] Verify access granted after login on either browser

### Success Criteria:

#### Manual Verification:

- [ ] All edge cases handled gracefully
- [ ] No crashes or unhandled errors
- [ ] Appropriate fallback behavior in all scenarios
- [ ] User can always access features after successful payment

## Testing Strategy

### Unit Tests (if time permits):

- Test `getComprehensiveUserAccess()` with mocked database responses
- Verify lifetime plan returns correct access object
- Verify premium/unlimited still query Stripe
- Verify free plan returns free tier response
- Verify null plan returns no access response

### Integration Tests:

- Full checkout flow for lifetime plan
- Webhook → Database → Access Control → Route Access
- Verify end-to-end flow works

### Manual Testing Checklist:

1. **Setup**: Configure Stripe test mode, webhook endpoint
2. **Test Lifetime Purchase**:
   - Use test card: 4242 4242 4242 4242
   - Complete checkout for lifetime plan ($199)
   - Verify webhook logs show successful processing
   - Check database: `SELECT plan_selected, subscription_status FROM profile WHERE id = 'user_id'`
   - Access `/dashboard` - should load immediately
   - Access `/calculators` - should load immediately
   - Check server logs - no Stripe API calls for access checks
3. **Test Free User Lockout**:
   - Create new account, select free plan
   - Try accessing `/dashboard` - should redirect to `/upgrade`
4. **Test Premium Subscription**:
   - Purchase premium plan
   - Verify dashboard access
   - Cancel subscription
   - Verify access revoked after cancellation
5. **Performance Check**:
   - Monitor access check duration in logs
   - Lifetime: Should be <50ms (database only)
   - Premium/Unlimited: Will be >100ms (Stripe API call expected)

### Testing with Stripe CLI:

```bash
# Forward webhooks to local development server
stripe listen --forward-to localhost:3000/api/stripe/webhook

# Watch for these events:
# Lifetime purchase:
#   ✅ checkout.session.completed (mode=payment)
#   ✅ charge.succeeded
#   ✅ payment_intent.succeeded
#   ❌ NO customer.subscription.created (correct!)

# Premium/Unlimited purchase:
#   ✅ checkout.session.completed (mode=subscription)
#   ✅ customer.subscription.created
#   ✅ invoice.paid
```

## Performance Considerations

### Before Fix:

- **Lifetime User Access Check**: ~200-500ms
  - Database query: ~20ms
  - Stripe API call: ~180-480ms (fails because no subscription)
  - Total: ~200-500ms

### After Fix:

- **Lifetime User Access Check**: ~20-50ms
  - Database query: ~20-50ms
  - No Stripe API call: 0ms
  - Total: ~20-50ms

### Improvement:

- **4-10x faster** for lifetime users
- **Reduced Stripe API usage** (lower costs, better rate limit headroom)
- **Better user experience** (faster page loads)

### No Impact On:

- Premium/Unlimited users (still query Stripe as before)
- Free tier users (no Stripe calls)
- Middleware (already uses JWT claims)

## Migration Notes

### No Database Migration Required:

All necessary fields already exist in schema:

- `plan_selected` - Stores "lifetime" value ✅
- `subscription_status` - Set to "active" for lifetime ✅
- `current_period_end` - Set to null for lifetime ✅
- `billing_version` - Incremented on plan changes ✅

### No Data Backfill Required:

If any users purchased lifetime plan before this fix:

1. Database already has `plan_selected='lifetime'` (webhook set it)
2. After deploying fix, they'll immediately gain access
3. No manual intervention needed

### Deployment Steps:

1. Deploy code changes (this is a pure code fix)
2. No database migrations to run
3. Monitor logs for successful lifetime user access
4. Watch for any errors in error tracking system

### Rollback Plan:

If issues arise:

1. Revert code changes (git revert)
2. Re-deploy previous version
3. Lifetime users will be locked out again (critical bug returns)
4. Investigate and fix issues before re-deploying

## References

- **Original ticket**: `.claude/tickets/0011-fix-lifetime-user-dashboard-lockout.md`
- **Broken function**: `utils/billing/access-control.ts:153-196` (getComprehensiveUserAccess)
- **Correct pattern**: `utils/billing/access-control.ts:37-78` (getBasicUserAccess)
- **Webhook handler**: `app/api/stripe/webhook/route.ts:158-204` (lifetime payment)
- **Middleware integration**: `utils/supabase/middleware.ts:117-255` (access checks)
- **Type definitions**: `types/billing.ts` (FeatureAccess, PlanType)
- **Database schema**: `db/schema.ts:25-91` (profile table)

## Implementation Notes

### Why This Fix is Minimal and Safe:

1. **Follows existing pattern**: Copies logic from `getBasicUserAccess()` which already works
2. **No new dependencies**: Uses existing helper functions and types
3. **No schema changes**: Works with existing database structure
4. **No webhook changes**: Webhook already handles lifetime correctly
5. **No middleware changes**: Middleware already handles lifetime via JWT claims
6. **Pure bug fix**: Only fixes broken subscription query for lifetime plans

### Why We Trust Database Values:

1. **Webhook signature verification**: Stripe webhooks are cryptographically signed
2. **Atomic database updates**: Webhook sets plan only after successful payment
3. **Retry mechanism**: Stripe retries failed webhooks (prevents missed payments)
4. **Same pattern as subscriptions**: We trust database for `subscription_status` too
5. **Already proven**: `getBasicUserAccess()` uses this pattern successfully

### Alternative Approaches Considered:

#### Option 1: Query Stripe Charges API ❌

```typescript
// Verify lifetime payment in Stripe
const charges = await stripe.charges.list({
  customer: stripeCustomer.stripe_customer_id,
  limit: 10,
});
const lifetimePayment = charges.data.find(
  (charge) => charge.amount === 19900 && charge.paid
);
```

**Rejected because**:

- Adds unnecessary API call (~200ms penalty)
- Same trust issue: we trust charges API but not webhook?
- More complex code
- Worse performance

#### Option 2: Store payment_intent_id in Database ❌

**Rejected because**:

- Requires schema migration
- Requires webhook changes
- Requires data backfill for existing users
- Doesn't solve the fundamental trust issue
- More complex than necessary

#### Option 3: Create Fake Stripe Subscription for Lifetime ❌

**Rejected because**:

- Abuses Stripe data model
- Confusing for accounting/reporting
- Still requires special handling
- Adds technical debt

#### Option 4: Trust Database (SELECTED) ✅

**Selected because**:

- Simple, fast, secure
- Follows existing pattern (`getBasicUserAccess()`)
- No schema changes
- No webhook changes
- Best performance
- Minimal code changes

## Appendix: Code Comparison

### getBasicUserAccess() - CORRECT (for reference)

```typescript
// Lines 64-77 in access-control.ts
// Paid plan (trust database, Stripe verification happens in page components)
return {
  plan: profile.plan_selected as "premium" | "unlimited" | "lifetime",
  hasAccess: true,
  hasPremiumAccess: true,
  hasUnlimitedRounds: hasUnlimitedRounds(profile.plan_selected),
  remainingRounds: Infinity,
  status: "active",
  isLifetime: profile.plan_selected === "lifetime",
  currentPeriodEnd:
    profile.plan_selected === "lifetime"
      ? new Date("2099-12-31T23:59:59.000Z")
      : null,
};
```

### getComprehensiveUserAccess() - BEFORE FIX (broken)

```typescript
// Lines 175-186 in access-control.ts
if (
  profile.plan_selected === "premium" ||
  profile.plan_selected === "unlimited" ||
  profile.plan_selected === "lifetime" // ❌ BUG HERE
) {
  const subscriptionAccess = await getUserAccess(userId); // Queries Stripe

  if (subscriptionAccess?.hasAccess) {
    return subscriptionAccess;
  }

  console.log("Subscription expired, falling back to free tier");
}
```

### getComprehensiveUserAccess() - AFTER FIX (correct)

```typescript
// Lifetime check BEFORE subscription check
if (profile.plan_selected === "lifetime") {
  return {
    plan: "lifetime",
    hasAccess: true,
    hasPremiumAccess: true,
    hasUnlimitedRounds: true,
    remainingRounds: Infinity,
    status: "active",
    isLifetime: true,
    currentPeriodEnd: new Date("2099-12-31T23:59:59.000Z"),
  };
}

// Subscription plans only
if (
  profile.plan_selected === "premium" ||
  profile.plan_selected === "unlimited"
) {
  const subscriptionAccess = await getUserAccess(userId);

  if (subscriptionAccess?.hasAccess) {
    return subscriptionAccess;
  }

  console.log("Subscription expired, falling back to free tier");
}
```

## Summary

This is a **critical but simple bug fix** that requires changing only ~15 lines of code in a single function. The fix:

1. Separates lifetime plan handling from subscription plans
2. Trusts database values for lifetime (same as `getBasicUserAccess()`)
3. Improves performance by eliminating unnecessary Stripe API calls
4. Requires no schema changes, no webhook changes, no middleware changes
5. Can be deployed immediately with no migration required

The bug has clear evidence (webhook logs showing no subscription for lifetime purchases) and a clear solution (follow the pattern already working in `getBasicUserAccess()`).
