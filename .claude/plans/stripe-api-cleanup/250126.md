# Stripe API Cleanup Implementation Plan

## Overview

Clean up the Stripe API implementation by:
1. Removing unnecessary Zod response validation from API routes
2. Migrating client-initiated endpoints to tRPC for better type safety
3. Maintaining rate limiting and UX while simplifying the codebase

## Current State Analysis

**API Routes:**
- 4 client-initiated endpoints using Zod response validation (checkout, portal, subscription GET/PUT)
- 1 webhook endpoint (no response validation, must remain as API route)
- 1 cron job (must remain as API route)

**Frontend:**
- 3 components use typed client library (`lib/stripe-api-client.ts`)
- 1 component uses raw `fetch` (legacy)
- All expect `ApiResult<T>` discriminated union pattern

**tRPC Infrastructure:**
- Already established with 6 routers
- Uses `authedProcedure` for authenticated routes
- Configured with superjson for Date handling

### Key Discoveries:

- Response validation is overkill for simple object construction (`checkout/route.ts:137`, `portal/route.ts:70`, `subscription/route.ts:194,213`)
- TypeScript already provides compile-time safety for response types
- tRPC will provide end-to-end type inference, eliminating need for manual validation
- Rate limiting is critical UX feature that must be preserved
- Current error handling with retry messages must be maintained

## Desired End State

**After completion:**
- All Zod response validation removed from Stripe API routes
- 4 client-initiated endpoints migrated to tRPC (`server/api/routers/stripe.ts`)
- Frontend components use tRPC hooks instead of custom client library
- Same UX for rate limiting and error handling
- Webhook and cron job remain as API routes (external triggers)
- `lib/stripe-api-client.ts` removed (no longer needed)
- Type safety improved through tRPC's automatic inference

### Verification:
- `pnpm build` passes (no type errors)
- All existing Stripe flows work (checkout, portal, subscription updates)
- Rate limiting still enforced with same error messages
- Error handling maintains retry-after feedback

## What We're NOT Doing

- ❌ Migrating webhook endpoint to tRPC (external webhooks require raw body for signature verification)
- ❌ Migrating cron job to tRPC (scheduled jobs need API route for Vercel cron)
- ❌ Removing request validation (input validation is still valuable)
- ❌ Changing rate limit thresholds (10/min checkout, 5/min portal)
- ❌ Modifying webhook security checks or payment verification logic
- ❌ Adding new Stripe features (cleanup only)

## Implementation Approach

**Strategy:** Incremental migration in 4 phases to minimize risk

1. **Phase 1:** Remove response validation (safe, no functional changes)
2. **Phase 2:** Create tRPC router (additive, no breaking changes)
3. **Phase 3:** Migrate frontend components one-by-one (can rollback individually)
4. **Phase 4:** Remove old API routes and client library (final cleanup)

Each phase can be committed independently for easier debugging and rollback.

---

## Phase 1: Remove Zod Response Validation

### Overview

Remove unnecessary Zod response validation from all Stripe API routes. This is a safe change that only removes defensive code without altering functionality.

### Changes Required:

#### 1. Checkout Endpoint

**File:** `app/api/stripe/checkout/route.ts`

**Changes:** Remove `CheckoutResponseSchema` import and validation

**Before (lines 136-139):**
```typescript
return successResponse(
  CheckoutResponseSchema.parse({ url: session.url }),
  rateLimitHeaders
);
```

**After:**
```typescript
return successResponse(
  { url: session.url },
  rateLimitHeaders
);
```

**Additional cleanup (line 18):**
Remove `CheckoutResponseSchema` from imports:
```typescript
import {
  CheckoutRequestSchema,
  // Remove: CheckoutResponseSchema,
} from "@/lib/stripe-types";
```

---

#### 2. Portal Endpoint

**File:** `app/api/stripe/portal/route.ts`

**Changes:** Remove `PortalResponseSchema` import and validation

**Before (lines 69-72):**
```typescript
return successResponse(
  PortalResponseSchema.parse({ url: session.url }),
  rateLimitHeaders
);
```

**After:**
```typescript
return successResponse(
  { url: session.url },
  rateLimitHeaders
);
```

**Additional cleanup (line 6):**
Remove `PortalResponseSchema` from imports:
```typescript
// Remove this import line entirely
import { PortalResponseSchema } from "@/lib/stripe-types";
```

---

#### 3. Subscription Endpoint - GET

**File:** `app/api/stripe/subscription/route.ts`

**Changes:** Remove validation in GET handler (lines 78-85)

**Before:**
```typescript
// ✅ NEW: Validate response before returning
const response = GetSubscriptionResponseSchema.parse({
  hasStripeCustomer: true,
  stripeCustomerId: stripeCustomer.stripe_customer_id,
  subscriptions: subscriptionData,
});

return successResponse(response);
```

**After:**
```typescript
return successResponse({
  hasStripeCustomer: true,
  stripeCustomerId: stripeCustomer.stripe_customer_id,
  subscriptions: subscriptionData,
});
```

**Also update the "no customer" case (lines 41-46):**

**Before:**
```typescript
if (!stripeCustomer?.stripe_customer_id) {
  return NextResponse.json({
    hasStripeCustomer: false,
    subscriptions: [],
    error: "No Stripe customer found",
  });
}
```

**After:**
```typescript
if (!stripeCustomer?.stripe_customer_id) {
  return successResponse({
    hasStripeCustomer: false,
    subscriptions: [],
  });
}
```

**Note:** Remove the confusing `error` field - `hasStripeCustomer: false` already communicates this state.

---

#### 4. Subscription Endpoint - PUT

**File:** `app/api/stripe/subscription/route.ts`

**Changes:** Remove validation in PUT handler (2 instances)

**Before (lines 193-200):**
```typescript
// ✅ NEW: Return validated response
const response = UpdateSubscriptionResponseSchema.parse({
  success: true,
  changeType: "lifetime",
  checkoutUrl: session.url,
});

return successResponse(response);
```

**After:**
```typescript
return successResponse({
  success: true,
  changeType: "lifetime",
  checkoutUrl: session.url,
});
```

**Before (lines 213-219):**
```typescript
const response = UpdateSubscriptionResponseSchema.parse({
  success: true,
  changeType: result.changeType,
  message,
});

return successResponse(response);
```

**After:**
```typescript
return successResponse({
  success: true,
  changeType: result.changeType,
  message,
});
```

**Additional cleanup (lines 18-21):**
Remove schema imports:
```typescript
import {
  // Remove: GetSubscriptionResponseSchema,
  UpdateSubscriptionRequestSchema,
  // Remove: UpdateSubscriptionResponseSchema,
} from "@/lib/stripe-types";
```

---

#### 5. Update Type Definitions

**File:** `lib/stripe-types.ts`

**Changes:** Mark response schemas as deprecated (don't delete yet - still used by client library until Phase 4)

Add comments to lines 54, 60, 80, 89:
```typescript
// @deprecated - Remove after tRPC migration (see .claude/plans/stripe-api-cleanup/250126.md)
export const CheckoutResponseSchema = z.object({
  url: z.string().url(),
});

// @deprecated - Remove after tRPC migration
export const PortalResponseSchema = z.object({
  url: z.string().url(),
});

// @deprecated - Remove after tRPC migration
export const GetSubscriptionResponseSchema = z.object({
  hasStripeCustomer: z.boolean(),
  stripeCustomerId: z.string().optional(),
  subscriptions: z.array(SubscriptionInfoSchema),
  error: z.string().optional(),
});

// @deprecated - Remove after tRPC migration
export const UpdateSubscriptionResponseSchema = z.object({
  success: z.boolean(),
  changeType: z.enum(["upgrade", "downgrade", "cancel", "lifetime"]),
  checkoutUrl: z.string().url().optional(),
  message: z.string().optional(),
});
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No type errors in changed files
- [x] Linting passes: `pnpm lint`

#### Manual Verification:
- [ ] Checkout flow still works (test in onboarding)
- [ ] Portal redirect still works (test from billing tab)
- [ ] Subscription updates still work (upgrade/downgrade)
- [ ] Rate limiting still returns proper error messages
- [ ] No regression in error handling

---

## Phase 2: Create tRPC Stripe Router

### Overview

Create a new tRPC router for Stripe operations with the same functionality as the existing API routes, including rate limiting.

### Changes Required:

#### 1. Create Stripe Router

**File:** `server/api/routers/stripe.ts` (new file)

```typescript
import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { createTRPCRouter, authedProcedure } from "../trpc";
import {
  createCheckoutSession,
  createLifetimeCheckoutSession,
  createPortalSession,
  updateSubscription as updateStripeSubscription,
  PLAN_TO_PRICE_MAP,
  stripe,
  mapPriceToPlan,
} from "@/lib/stripe";
import { verifyPaymentAmount, formatAmount } from "@/utils/billing/pricing";
import {
  checkoutRateLimit,
  portalRateLimit,
  getIdentifier,
} from "@/lib/rate-limit";
import {
  sendSubscriptionUpgradedEmail,
  sendSubscriptionDowngradedEmail,
  sendSubscriptionCancelledEmail,
} from "@/lib/email-service";
import { PlanSchema } from "@/lib/stripe-types";

// Helper to check rate limits and throw tRPC error if exceeded
async function checkRateLimit(
  identifier: string,
  rateLimit: typeof checkoutRateLimit
) {
  const { success, limit, remaining, reset } = await rateLimit.limit(
    identifier
  );

  if (!success) {
    const retryAfterSeconds = Math.ceil((reset - Date.now()) / 1000);

    throw new TRPCError({
      code: "TOO_MANY_REQUESTS",
      message: "Too many requests. Please try again in a moment.",
      cause: {
        retryAfter: retryAfterSeconds,
        limit,
        remaining,
        reset: new Date(reset).toISOString(),
      },
    });
  }

  return { limit, remaining, reset };
}

export const stripeRouter = createTRPCRouter({
  // POST /api/stripe/checkout
  createCheckout: authedProcedure
    .input(
      z.object({
        plan: z.enum(["premium", "unlimited", "lifetime"]),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { user, supabase } = ctx;

      if (!user.email) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Email required for checkout",
        });
      }

      // Rate limiting check
      const identifier = user.id;
      await checkRateLimit(identifier, checkoutRateLimit);

      const priceId = PLAN_TO_PRICE_MAP[input.plan];

      if (!priceId) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Price ID not configured for this plan",
        });
      }

      // Verify price ID points to correct amount (Defense in Depth)
      try {
        const price = await stripe.prices.retrieve(priceId);

        const verification = verifyPaymentAmount(
          input.plan,
          price.currency,
          price.unit_amount || 0,
          price.type === "recurring"
        );

        if (!verification.valid) {
          console.error("❌ CRITICAL: Price verification failed at checkout", {
            plan: input.plan,
            priceId,
            expected: formatAmount(verification.expected),
            actual: formatAmount(verification.actual),
            variance: verification.variance,
            severity: "HIGH",
            action: "Check environment variables and Stripe dashboard",
          });

          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Pricing configuration error. Please contact support.",
          });
        }
      } catch (error) {
        if (error instanceof TRPCError) throw error;

        console.error("❌ Failed to verify price during checkout", error);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to verify pricing",
        });
      }

      // Create the checkout session
      const session =
        input.plan === "lifetime"
          ? await createLifetimeCheckoutSession({
              userId: user.id,
              email: user.email,
              priceId,
              successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
              cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/onboarding`,
            })
          : await createCheckoutSession({
              userId: user.id,
              email: user.email,
              priceId,
              successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
              cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/onboarding`,
            });

      if (!session.url) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create checkout session URL",
        });
      }

      return {
        url: session.url,
      };
    }),

  // POST /api/stripe/portal
  createPortal: authedProcedure.mutation(async ({ ctx }) => {
    const { user, supabase } = ctx;

    // Rate limiting check
    const identifier = user.id;
    await checkRateLimit(identifier, portalRateLimit);

    // Get the Stripe customer ID from the database
    const { data: stripeCustomer } = await supabase
      .from("stripe_customers")
      .select("stripe_customer_id")
      .eq("user_id", user.id)
      .single();

    if (!stripeCustomer?.stripe_customer_id) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "No Stripe customer found",
      });
    }

    // Create a portal session
    const session = await createPortalSession({
      customerId: stripeCustomer.stripe_customer_id,
      returnUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/profile/${user.id}?tab=billing`,
    });

    if (!session.url) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to create portal session URL",
      });
    }

    return {
      url: session.url,
    };
  }),

  // GET /api/stripe/subscription
  getSubscription: authedProcedure.query(async ({ ctx }) => {
    const { user, supabase } = ctx;

    // Get the Stripe customer ID from the database
    const { data: stripeCustomer } = await supabase
      .from("stripe_customers")
      .select("stripe_customer_id")
      .eq("user_id", user.id)
      .single();

    if (!stripeCustomer?.stripe_customer_id) {
      return {
        hasStripeCustomer: false,
        subscriptions: [],
      };
    }

    // Get subscriptions from Stripe
    const subscriptions = await stripe.subscriptions.list({
      customer: stripeCustomer.stripe_customer_id,
      limit: 10,
    });

    const subscriptionData = subscriptions.data.map((sub) => {
      const items = sub.items.data;
      const item = items[0];

      return {
        id: sub.id,
        status: sub.status,
        currentPeriodStart: item?.current_period_start
          ? new Date(item.current_period_start * 1000)
          : null,
        currentPeriodEnd: item?.current_period_end
          ? new Date(item.current_period_end * 1000)
          : null,
        priceId: item?.price.id,
        plan: mapPriceToPlan(item?.price.id || ""),
        cancelAtPeriodEnd: sub.cancel_at_period_end,
        canceledAt: sub.canceled_at ? new Date(sub.canceled_at * 1000) : null,
        metadata: sub.metadata,
      };
    });

    return {
      hasStripeCustomer: true,
      stripeCustomerId: stripeCustomer.stripe_customer_id,
      subscriptions: subscriptionData,
    };
  }),

  // PUT /api/stripe/subscription
  updateSubscription: authedProcedure
    .input(
      z.object({
        newPlan: PlanSchema,
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { user, supabase } = ctx;

      // Get current plan before update
      const { data: currentProfile } = await supabase
        .from("profile")
        .select("plan_selected")
        .eq("id", user.id)
        .single();

      const currentPlan = currentProfile?.plan_selected || "free";

      // Update subscription via Stripe
      const result = await updateStripeSubscription({
        userId: user.id,
        newPlan: input.newPlan,
      });

      // Send email notification (non-blocking)
      const billingUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/billing`;

      try {
        if (result.changeType === "upgrade" && user.email) {
          const proratedCharge =
            result.subscription?.latest_invoice &&
            typeof result.subscription.latest_invoice !== "string"
              ? (result.subscription.latest_invoice as any).amount_due || 0
              : 0;

          const currency =
            result.subscription?.items.data[0]?.price.currency || "usd";

          await sendSubscriptionUpgradedEmail({
            to: user.email,
            oldPlan: currentPlan,
            newPlan: input.newPlan,
            proratedCharge,
            currency,
            billingUrl,
          });
        } else if (result.changeType === "downgrade" && user.email) {
          const periodEnd = result.subscription?.items?.data[0]?.current_period_end;
          const effectiveDate = periodEnd
            ? new Date(periodEnd * 1000)
            : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

          await sendSubscriptionDowngradedEmail({
            to: user.email,
            oldPlan: currentPlan,
            newPlan: input.newPlan,
            effectiveDate,
            billingUrl,
          });
        } else if (result.changeType === "cancel" && user.email) {
          const periodEnd = result.subscription?.items?.data[0]?.current_period_end;
          const endDate = periodEnd
            ? new Date(periodEnd * 1000)
            : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

          await sendSubscriptionCancelledEmail({
            to: user.email,
            plan: currentPlan,
            endDate,
            billingUrl,
          });
        }
      } catch (emailError) {
        console.error("Failed to send subscription change email:", emailError);
      }

      // If changing to lifetime, return checkout URL
      if ("requiresCheckout" in result && result.requiresCheckout) {
        const priceId = PLAN_TO_PRICE_MAP.lifetime;

        const session = await createLifetimeCheckoutSession({
          userId: user.id,
          email: user.email!,
          priceId,
          successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
          cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/upgrade`,
        });

        if (!session.url) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to create lifetime checkout session",
          });
        }

        return {
          success: true,
          changeType: "lifetime" as const,
          checkoutUrl: session.url,
        };
      }

      // Return success response for other changes
      const message =
        result.changeType === "cancel"
          ? "alreadyCancelled" in result
            ? "Your subscription has been cancelled. You're now on the free plan."
            : "Subscription will cancel at the end of your billing period"
          : result.changeType === "upgrade"
          ? "Plan upgraded! You'll be charged the prorated difference."
          : "Plan change scheduled for end of billing period";

      return {
        success: true,
        changeType: result.changeType,
        message,
      };
    }),
});
```

---

#### 2. Register Router in Root

**File:** `server/api/root.ts`

**Add import (after line 6):**
```typescript
import { stripeRouter } from "./routers/stripe";
```

**Add to appRouter (after line 21):**
```typescript
export const appRouter = createTRPCRouter({
  round: roundRouter,
  auth: authRouter,
  hole: holeRouter,
  course: courseRouter,
  tee: teeRouter,
  scorecard: scorecardRouter,
  stripe: stripeRouter, // Add this line
});
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No type errors in new router file
- [x] tRPC types regenerate correctly

#### Manual Verification:
- [ ] New router accessible via tRPC client (test in console)
- [ ] Rate limiting helper function works (test with rapid calls)
- [ ] Error formatting includes retry metadata
- [ ] Server logs show router is registered

---

## Phase 3: Migrate Frontend Components to tRPC

### Overview

Update frontend components to use tRPC hooks instead of the custom client library. Maintain identical UX including rate limiting feedback.

### Changes Required:

#### 1. Plan Selector Component

**File:** `components/billing/plan-selector.tsx`

**Add tRPC import (line 5):**
```typescript
import { api } from "@/trpc/react";
```

**Remove old import (line 8):**
```typescript
// Remove: import { createCheckout, updateSubscription } from "@/lib/stripe-api-client";
```

**Replace createCheckout call (lines 205-229):**

**Before:**
```typescript
const result = await createCheckout({ plan });

if (!result.success) {
  if (result.error.retryAfter) {
    setFeedbackMessage({
      type: "error",
      title: "Too Many Requests",
      message: `Please wait ${result.error.retryAfter} seconds before trying again. This helps us keep the service running smoothly for everyone.`,
    });
  } else {
    throw new Error(result.error.error);
  }
  setLoading(null);
  return;
}

// Success: Redirect to Stripe checkout
window.location.href = result.data.url;
```

**After:**
```typescript
const result = await api.stripe.createCheckout.mutate({ plan });

// Success: Redirect to Stripe checkout
window.location.href = result.url;
```

**Update error handling in try-catch (lines 230-239):**

**Before:**
```typescript
} catch (error) {
  console.error("Error during checkout:", error);
  setFeedbackMessage({
    type: "error",
    title: "Error",
    message:
      error instanceof Error
        ? error.message
        : "An unexpected error occurred. Please try again.",
  });
  setLoading(null);
}
```

**After:**
```typescript
} catch (error: any) {
  console.error("Error during checkout:", error);

  // Check if it's a rate limit error
  if (error?.data?.code === "TOO_MANY_REQUESTS" && error?.data?.cause?.retryAfter) {
    setFeedbackMessage({
      type: "error",
      title: "Too Many Requests",
      message: `Please wait ${error.data.cause.retryAfter} seconds before trying again. This helps us keep the service running smoothly for everyone.`,
    });
  } else {
    setFeedbackMessage({
      type: "error",
      title: "Error",
      message: error?.message || "An unexpected error occurred. Please try again.",
    });
  }
  setLoading(null);
}
```

**Replace first updateSubscription call (lines 76-100):**

**Before:**
```typescript
const result = await updateSubscription({ newPlan: "free" });

if (!result.success) {
  throw new Error(result.error.error);
}

// Show success message
setFeedbackMessage({
  type: "success",
  title: "Plan Updated",
  message:
    result.data.message || "Your plan has been updated successfully.",
});

// Delay navigation to show success message
setTimeout(() => {
  router.push("/billing");
  router.refresh();
}, 2000);
```

**After:**
```typescript
const result = await api.stripe.updateSubscription.mutate({ newPlan: "free" });

// Show success message
setFeedbackMessage({
  type: "success",
  title: "Plan Updated",
  message: result.message || "Your plan has been updated successfully.",
});

// Delay navigation to show success message
setTimeout(() => {
  router.push("/billing");
  router.refresh();
}, 2000);
```

**Update error handling for downgrade (lines 101-155):**
Same pattern - check for `error?.data?.code === "TOO_MANY_REQUESTS"`

**Replace second updateSubscription call (lines 163-204):**

**Before:**
```typescript
const result = await updateSubscription({ newPlan: plan });

if (!result.success) {
  if (result.error.retryAfter) {
    setFeedbackMessage({
      type: "error",
      title: "Too Many Requests",
      message: `Please wait ${result.error.retryAfter} seconds before trying again...`,
    });
  } else {
    throw new Error(result.error.error);
  }
  setLoading(null);
  return;
}

// Special case: Lifetime upgrade requires checkout
if (result.data.checkoutUrl) {
  window.location.href = result.data.checkoutUrl;
  return;
}

// Show success message
setFeedbackMessage({
  type: "success",
  title: "Plan Updated",
  message: result.data.message || "Your plan has been updated successfully.",
});
```

**After:**
```typescript
const result = await api.stripe.updateSubscription.mutate({ newPlan: plan });

// Special case: Lifetime upgrade requires checkout
if (result.checkoutUrl) {
  window.location.href = result.checkoutUrl;
  return;
}

// Show success message
setFeedbackMessage({
  type: "success",
  title: "Plan Updated",
  message: result.message || "Your plan has been updated successfully.",
});
```

**Update error handling (same rate limit check pattern)**

---

#### 2. Manage Subscription Button

**File:** `components/billing/manage-subscription-button.tsx`

**Add tRPC import (line 4):**
```typescript
import { api } from "@/trpc/react";
```

**Remove old import (line 5):**
```typescript
// Remove: import { createPortal } from "@/lib/stripe-api-client";
```

**Replace entire handleManageSubscription function (lines 10-36):**

**Before:**
```typescript
const handleManageSubscription = async () => {
  try {
    setLoading(true);

    const result = await createPortal();

    if (!result.success) {
      if (result.error.retryAfter) {
        alert(
          `Too many requests. Please wait ${result.error.retryAfter} seconds and try again.`
        );
      } else {
        throw new Error(result.error.error);
      }
      return;
    }

    window.location.href = result.data.url;
  } catch (error) {
    console.error("Error opening customer portal:", error);
    alert("Failed to open subscription management. Please try again.");
  } finally {
    setLoading(false);
  }
};
```

**After:**
```typescript
const handleManageSubscription = async () => {
  try {
    setLoading(true);

    const result = await api.stripe.createPortal.mutate();

    window.location.href = result.url;
  } catch (error: any) {
    console.error("Error opening customer portal:", error);

    if (error?.data?.code === "TOO_MANY_REQUESTS" && error?.data?.cause?.retryAfter) {
      alert(
        `Too many requests. Please wait ${error.data.cause.retryAfter} seconds and try again.`
      );
    } else {
      alert("Failed to open subscription management. Please try again.");
    }
  } finally {
    setLoading(false);
  }
};
```

---

#### 3. Portal Button (Legacy Component)

**File:** `components/billing/portal-button.tsx`

**Add tRPC import (line 3):**
```typescript
import { api } from "@/trpc/react";
```

**Replace entire handleManageSubscription function (lines 10-40):**

**Before:**
```typescript
const handleManageSubscription = async () => {
  try {
    setLoading(true);

    const response = await fetch("/api/stripe/portal", {
      method: "POST",
    });

    const data = await response.json();

    // Handle rate limiting
    if (response.status === 429) {
      const retryAfter = data.retryAfter || 60;
      alert(
        `Too many requests. Please wait ${retryAfter} seconds and try again.`
      );
      setLoading(false);
      return;
    }

    if (!response.ok) {
      throw new Error(data.error || "Failed to access billing portal");
    }

    if (data.url) {
      window.location.href = data.url;
    } else {
      throw new Error("No portal URL returned");
    }
  } catch (error) {
    console.error("Error accessing billing portal:", error);
    alert("Failed to access billing portal. Please try again.");
    setLoading(false);
  }
};
```

**After:**
```typescript
const handleManageSubscription = async () => {
  try {
    setLoading(true);

    const result = await api.stripe.createPortal.mutate();

    window.location.href = result.url;
  } catch (error: any) {
    console.error("Error accessing billing portal:", error);

    if (error?.data?.code === "TOO_MANY_REQUESTS" && error?.data?.cause?.retryAfter) {
      alert(
        `Too many requests. Please wait ${error.data.cause.retryAfter} seconds and try again.`
      );
    } else {
      alert("Failed to access billing portal. Please try again.");
    }
    setLoading(false);
  }
};
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No type errors in updated components
- [x] Linting passes: `pnpm lint`

#### Manual Verification:
- [ ] Checkout flow works from onboarding (free → paid plan)
- [ ] Checkout flow works from upgrade page (paid → different paid plan)
- [ ] Portal button works from billing tab
- [ ] Rate limit errors show "retry after X seconds" message
- [ ] Success messages display correctly
- [ ] Lifetime upgrade redirects to checkout URL
- [ ] Other upgrades show success message with 2s delay
- [ ] Loading states work correctly

---

## Phase 4: Remove Old API Routes and Client Library

### Overview

Clean up deprecated code now that all clients use tRPC. Keep webhook and cron job as API routes.

### Changes Required:

#### 1. Delete Client-Initiated API Routes

**Files to delete:**
- `app/api/stripe/checkout/route.ts`
- `app/api/stripe/portal/route.ts`
- `app/api/stripe/subscription/route.ts`

**Files to keep:**
- `app/api/stripe/webhook/route.ts` (external webhook)
- `app/api/cron/reconcile-stripe/route.ts` (scheduled job)

---

#### 2. Delete Client Library

**File to delete:**
- `lib/stripe-api-client.ts`

---

#### 3. Clean Up Type Definitions

**File:** `lib/stripe-types.ts`

**Remove deprecated response schemas (lines 54-95):**
```typescript
// Delete these schemas:
export const CheckoutResponseSchema = z.object({
  url: z.string().url(),
});

export type CheckoutResponse = z.infer<typeof CheckoutResponseSchema>;

export const PortalResponseSchema = z.object({
  url: z.string().url(),
});

export type PortalResponse = z.infer<typeof PortalResponseSchema>;

export const GetSubscriptionResponseSchema = z.object({
  hasStripeCustomer: z.boolean(),
  stripeCustomerId: z.string().optional(),
  subscriptions: z.array(SubscriptionInfoSchema),
  error: z.string().optional(),
});

export type GetSubscriptionResponse = z.infer<typeof GetSubscriptionResponseSchema>;

export const UpdateSubscriptionResponseSchema = z.object({
  success: z.boolean(),
  changeType: z.enum(["upgrade", "downgrade", "cancel", "lifetime"]),
  checkoutUrl: z.string().url().optional(),
  message: z.string().optional(),
});

export type UpdateSubscriptionResponse = z.infer<typeof UpdateSubscriptionResponseSchema>;

export const ErrorResponseSchema = z.object({
  error: z.string(),
  retryAfter: z.number().optional(),
  details: z.string().optional(),
});

export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;

export type ApiResult<T> =
  | { success: true; data: T }
  | { success: false; error: ErrorResponse };
```

**Keep:**
- Request schemas (`CheckoutRequestSchema`, `UpdateSubscriptionRequestSchema`)
- Subscription info schema (`SubscriptionInfoSchema`)
- Plan and status schemas

---

#### 4. Update API Validation Helper

**File:** `lib/api-validation.ts`

**Check if `successResponse` is still used elsewhere:**
- Grep for `successResponse` usage in webhook and cron routes
- If still used, keep the helper
- If not used, can be removed

**Note:** `validateRequest` is still used for request validation in webhook/cron, so keep it.

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No imports of deleted files remain
- [x] Linting passes: `pnpm lint`
- [x] No dead code warnings

#### Manual Verification:
- [ ] All Stripe flows still work (final end-to-end test)
- [ ] Webhook endpoint still responds (test with Stripe CLI)
- [ ] Cron job still accessible (if testable)
- [ ] No 404 errors in browser console
- [ ] No broken imports

---

## Testing Strategy

### Unit Tests
- No new unit tests required (tRPC provides type safety)
- Existing Stripe webhook tests should still pass

### Integration Tests
Manual end-to-end testing for each flow:

**Checkout Flow:**
1. Log in as free user
2. Navigate to onboarding or upgrade page
3. Select paid plan (premium, unlimited, lifetime)
4. Verify redirect to Stripe checkout
5. Test rate limiting by rapid clicking

**Portal Flow:**
1. Log in as paid user (not lifetime)
2. Navigate to profile billing tab
3. Click "Manage Subscription"
4. Verify redirect to Stripe portal
5. Test rate limiting by rapid clicking

**Subscription Update Flow:**
1. Log in as paid user
2. Navigate to upgrade page
3. Downgrade to free plan
4. Verify success message and redirect
5. Upgrade to different paid plan
6. Verify success message and redirect
7. Upgrade to lifetime (if applicable)
8. Verify redirect to checkout
9. Test rate limiting

**Error Handling:**
1. Disconnect network and test error messages
2. Trigger rate limit and verify retry message shows seconds
3. Test with invalid session (logout mid-flow)

### Manual Testing Checklist

- [ ] New user can sign up and select free plan
- [ ] Free user can upgrade to premium via checkout
- [ ] Free user can upgrade to unlimited via checkout
- [ ] Free user can upgrade to lifetime via checkout
- [ ] Premium user can downgrade to free
- [ ] Premium user can upgrade to unlimited
- [ ] Premium user can upgrade to lifetime (via checkout)
- [ ] Unlimited user can downgrade to premium
- [ ] Unlimited user can downgrade to free
- [ ] Unlimited user can upgrade to lifetime (via checkout)
- [ ] Any paid user can access customer portal
- [ ] Lifetime user cannot access portal (no subscription to manage)
- [ ] Rate limiting shows correct retry time
- [ ] Error messages are user-friendly
- [ ] Success messages display for 5 seconds
- [ ] Loading states show during API calls
- [ ] Webhook still processes Stripe events

---

## Performance Considerations

**Rate Limiting:**
- tRPC adds minimal overhead (<5ms per request)
- Rate limiting logic unchanged (Redis-based, same performance)
- Error throwing is negligible overhead vs returning error objects

**Bundle Size:**
- Removing `lib/stripe-api-client.ts` saves ~1KB gzipped
- tRPC client already included in bundle
- Net improvement in bundle size

**Type Safety:**
- tRPC provides compile-time type checking (zero runtime cost)
- Eliminates need for runtime Zod validation (performance improvement)

---

## Migration Notes

**Rollback Strategy:**
- Each phase can be rolled back independently via git
- Phase 1 is purely cleanup (safe to rollback)
- Phase 2 is additive (no breaking changes)
- Phase 3 can be rolled back per-component
- Phase 4 deletion can be reverted from git history

**Deployment Strategy:**
- Deploy phases 1-3 together (validate response removal + tRPC migration)
- Deploy phase 4 separately after monitoring Phase 1-3 in production

**Monitoring:**
- Watch Stripe webhook success rate (should remain 100%)
- Monitor rate limit trigger frequency
- Check error logs for new tRPC errors
- Verify checkout conversion rate unchanged

---

## References

- Original discussion: Code review comment on `app/api/stripe/subscription/route.ts:41`
- tRPC error handling: https://trpc.io/docs/server/error-handling
- Rate limiting implementation: `lib/rate-limit.ts`
- Existing tRPC routers: `server/api/routers/round.ts` (complex mutation example)
