# Simplify Onboarding/Upgrade Flow - Three-Page Architecture

## Overview

Implement a clear, secure, and user-friendly three-page architecture for plan selection and management:
1. `/onboarding` - First-time plan selection (users with no plan)
2. `/billing` - Subscription dashboard (all users with a plan)
3. `/upgrade` - Smart plan change interface (users wanting to change their plan)

This consolidates the user journey, improves security by separating concerns, and provides better UX through context-aware messaging.

## Current State Analysis

### Existing Implementation:

**`/onboarding` (app/onboarding/page.tsx)**
- ✅ Shows all 4 plans via PlanSelector component
- ✅ Redirects users who already have plans (lines 19-28)
- ✅ Well-designed for first-time selection

**`/billing` (app/billing/page.tsx)**
- ✅ Shows current plan details
- ✅ Has "Upgrade Plan" link to `/upgrade` for free users
- ✅ Has ManageSubscriptionButton for paid users
- ✅ Already structured as a dashboard

**`/upgrade` (app/upgrade/page.tsx)**
- ❌ Currently just static content
- ❌ Shows only Premium and Unlimited (missing Free and Lifetime)
- ❌ Links back to `/onboarding` (incorrect)
- ❌ No logic for current plan detection
- ❌ No upgrade vs downgrade distinction
- ❌ Per ticket #0006, this needs complete rewrite

**PlanSelector (components/billing/plan-selector.tsx)**
- ✅ Shows all 4 plans
- ✅ Handles free plan selection via server action
- ✅ Handles paid plan checkout via Stripe
- ⚠️ No awareness of current plan (shows all options to everyone)

### Key Discoveries:

- Stripe Customer Portal integration already exists via ManageSubscriptionButton (components/billing/manage-subscription-button.tsx)
- Webhook handlers properly distinguish between checkout (new) and subscription updates (app/api/stripe/webhook/route.ts)
- Access control system (utils/billing/access-control.ts) supports comprehensive user state queries
- Stripe automatically handles proration for subscription changes (no custom calculation needed)

## Desired End State

### User Journey by State:

**New User (no plan):**
1. Login → Middleware redirects to `/onboarding`
2. Select plan (Free/Premium/Unlimited/Lifetime)
3. Redirected to `/` (free) or `/billing/success` (paid)

**Free User:**
1. Navigate to `/billing` → See plan dashboard
2. Click "Upgrade Plan" → `/upgrade`
3. See upgrade options (Premium, Unlimited, Lifetime)
4. Complete checkout → Stripe handles payment
5. Return to `/billing/success`

**Premium User:**
1. Navigate to `/billing` → See plan dashboard
2. Click "Manage Subscription" → Stripe Customer Portal (cancel, payment method)
3. Click "Change Plan" → `/upgrade`
4. See upgrade options (Unlimited, Lifetime) and downgrade options (Free)
5. Upgrades: Immediate with proration
6. Downgrades: Scheduled for end of billing cycle

**Unlimited User:**
1. Navigate to `/billing` → See plan dashboard
2. Same as Premium, but can upgrade to Lifetime or downgrade to Premium/Free

**Lifetime User:**
1. Navigate to `/billing` → See plan dashboard
2. "Manage Subscription" shows "No subscription management needed"
3. `/upgrade` shows "You're on the best plan!"

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`
- [x] All unit tests pass: `pnpm test`
- [x] Linting passes: `pnpm lint`

#### Manual Verification:
- [ ] New users are redirected to `/onboarding` (not `/upgrade`)
- [ ] Users with plans accessing `/onboarding` are redirected to `/billing`
- [ ] Free users see only upgrade options on `/upgrade`
- [ ] Paid users see appropriate upgrade and downgrade options on `/upgrade`
- [ ] Lifetime users see "best plan" message on `/upgrade`
- [ ] Current plan is clearly highlighted on `/upgrade`
- [ ] Upgrade messages indicate immediate effect with proration
- [ ] Downgrade messages indicate end-of-cycle scheduling
- [ ] Stripe Customer Portal opens correctly for paid users
- [ ] Plan changes update database correctly via webhooks
- [ ] No security vulnerabilities (customer ID verification works)

## What We're NOT Doing

- Custom proration calculation (Stripe handles this)
- Annual billing options (future enhancement)
- Trial periods (future enhancement)
- Detailed proration amount preview (just show message that Stripe will prorate)
- Custom plan tiers beyond existing 4
- Coupon/promo code UI (Stripe Checkout already supports this)
- Billing history page (separate feature)
- Invoice downloads (separate feature)

## Implementation Approach

### Phase 1: Enhance PlanSelector to be Context-Aware
Make PlanSelector accept a `currentPlan` prop and disable/highlight accordingly.

### Phase 2: Implement Smart `/upgrade` Page
Complete rewrite following ticket #0006 with context-aware plan options.

### Phase 3: Add Stripe Subscription Update API
Create new API endpoint for modifying existing subscriptions (upgrade/downgrade).

### Phase 4: Refine `/billing` Page
Ensure clear CTAs based on plan type.

### Phase 5: Update `/onboarding` Redirects
Ensure users with existing plans can't access onboarding.

---

## Phase 1: Enhance PlanSelector Component

### Overview
Make PlanSelector context-aware so it can be reused in both `/onboarding` (all options) and `/upgrade` (filtered options).

### Changes Required:

#### 1. Update PlanSelector Interface

**File**: `components/billing/plan-selector.tsx`

**Changes**: Add optional props for context awareness

```typescript
interface PlanSelectorProps {
  userId: string;
  currentPlan?: "free" | "premium" | "unlimited" | "lifetime" | null;
  mode?: "onboarding" | "upgrade"; // Default: "onboarding"
  onPlanChange?: (plan: string) => void; // Optional callback
}

export function PlanSelector({
  userId,
  currentPlan = null,
  mode = "onboarding",
  onPlanChange
}: PlanSelectorProps) {
  // ... existing code
}
```

#### 2. Add Plan Filtering Logic

**File**: `components/billing/plan-selector.tsx`

**Changes**: Filter available plans based on current plan

```typescript
// Add after imports
const getAvailablePlans = (
  currentPlan: string | null | undefined,
  mode: "onboarding" | "upgrade"
) => {
  // Onboarding: show all plans
  if (mode === "onboarding" || !currentPlan) {
    return ["free", "premium", "unlimited", "lifetime"];
  }

  // Upgrade mode: filter based on current plan
  switch (currentPlan) {
    case "free":
      return ["premium", "unlimited", "lifetime"]; // Only upgrades
    case "premium":
      return ["unlimited", "lifetime", "free"]; // Upgrades + downgrade
    case "unlimited":
      return ["lifetime", "premium", "free"]; // Upgrade + downgrades
    case "lifetime":
      return []; // No changes available
    default:
      return ["free", "premium", "unlimited", "lifetime"];
  }
};

// Inside component, before return
const availablePlans = getAvailablePlans(currentPlan, mode);
const shouldShowPlan = (plan: string) => availablePlans.includes(plan);
```

#### 3. Update Plan Card Rendering

**File**: `components/billing/plan-selector.tsx`

**Changes**: Conditionally render cards and add current plan indicator

```typescript
// Wrap each plan card div with conditional:
{shouldShowPlan("free") && (
  <div className="border rounded-lg p-8 shadow-md hover:shadow-lg transition">
    {/* Add current plan badge if applicable */}
    {currentPlan === "free" && (
      <div className="absolute -top-4 left-1/2 transform -translate-x-1/2">
        <span className="bg-gray-500 text-white px-4 py-1 rounded-full text-sm font-semibold">
          Current Plan
        </span>
      </div>
    )}
    {/* ... rest of free plan card */}
    <Button
      onClick={handleFreePlan}
      disabled={loading !== null || currentPlan === "free"}
      className="w-full"
      variant="outline"
    >
      {currentPlan === "free"
        ? "Current Plan"
        : loading === "free"
        ? "Setting up..."
        : "Start Free"}
    </Button>
  </div>
)}

// Repeat for premium, unlimited, lifetime cards with their respective checks
```

#### 4. Add Upgrade/Downgrade Messaging

**File**: `components/billing/plan-selector.tsx`

**Changes**: Add context-specific messaging above plan cards

```typescript
// Add before plan grid
{mode === "upgrade" && currentPlan && (
  <div className="mb-8 text-center">
    <p className="text-gray-600 text-lg">
      {availablePlans.length === 0 ? (
        <>You&apos;re on the best plan! No changes available.</>
      ) : (
        <>Change your plan below</>
      )}
    </p>
    <div className="mt-4 space-y-2 text-sm text-gray-500">
      <p>✓ Upgrades take effect immediately (prorated charge)</p>
      <p>✓ Downgrades take effect at the end of your billing cycle</p>
    </div>
  </div>
)}
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`
- [x] Component renders without errors

#### Manual Verification:
- [ ] PlanSelector in onboarding mode shows all 4 plans
- [ ] PlanSelector in upgrade mode filters plans correctly
- [ ] Current plan badge displays on the correct card
- [ ] Button states are correct (disabled for current plan)
- [ ] Messaging about upgrade/downgrade timing is clear

---

## Phase 2: Implement Smart `/upgrade` Page

### Overview
Complete rewrite of `/upgrade` page to show context-aware plan options with proper upgrade/downgrade flows.

### Changes Required:

#### 1. Rewrite Upgrade Page

**File**: `app/upgrade/page.tsx`

**Changes**: Complete rewrite

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import { getComprehensiveUserAccess } from "@/utils/billing/access-control";
import { PlanSelector } from "@/components/billing/plan-selector";
import Link from "next/link";

export default async function UpgradePage() {
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Get current access details
  const access = await getComprehensiveUserAccess(user.id);

  // No plan selected - redirect to onboarding
  if (!access.hasAccess) {
    redirect("/onboarding");
  }

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-6xl mx-auto">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold mb-4">Change Your Plan</h1>
          <p className="text-lg text-gray-600">
            Currently on: <span className="font-semibold capitalize">{access.plan}</span> Plan
          </p>
        </div>

        {/* Context-aware plan selector */}
        <PlanSelector
          userId={user.id}
          currentPlan={access.plan}
          mode="upgrade"
        />

        {/* Back to billing link */}
        <div className="text-center mt-12">
          <Link href="/billing" className="text-gray-600 hover:text-gray-800">
            ← Back to Billing
          </Link>
        </div>
      </div>
    </div>
  );
}
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`
- [x] Page renders without errors

#### Manual Verification:
- [ ] Users without a plan are redirected to `/onboarding`
- [ ] Current plan is displayed prominently
- [ ] Only relevant plan options are shown (filtered by PlanSelector)
- [ ] Back to billing link works correctly

---

## Phase 3: Add Stripe Subscription Update API

### Overview
Create API endpoint to handle subscription upgrades/downgrades with proper Stripe proration.

### Changes Required:

#### 1. Create Subscription Update Helpers

**File**: `lib/stripe.ts` (add to existing file)

**Changes**: Add subscription management functions

```typescript
/**
 * Update an existing subscription to a new price
 * Handles both upgrades (immediate with proration) and downgrades (end of cycle)
 */
export async function updateSubscription({
  userId,
  newPlan,
}: {
  userId: string;
  newPlan: "free" | "premium" | "unlimited" | "lifetime";
}) {
  // Get user's Stripe customer ID
  const { data: customer } = await db
    .select()
    .from(stripeCustomers)
    .where(eq(stripeCustomers.userId, userId))
    .limit(1);

  if (!customer || customer.length === 0) {
    throw new Error("No Stripe customer found for user");
  }

  const customerId = customer[0].stripeCustomerId;

  // Get active subscription
  const subscriptions = await stripe.subscriptions.list({
    customer: customerId,
    status: "active",
    limit: 1,
  });

  const subscription = subscriptions.data[0];

  if (!subscription) {
    throw new Error("No active subscription found");
  }

  const currentPlan = mapPriceToPlan(subscription.items.data[0]?.price.id || "");

  // Determine if upgrade or downgrade
  const planHierarchy = { free: 0, premium: 1, unlimited: 2, lifetime: 3 };
  const isUpgrade = planHierarchy[newPlan] > planHierarchy[currentPlan || "free"];

  // Handle downgrade to free = cancel subscription
  if (newPlan === "free") {
    const updated = await stripe.subscriptions.update(subscription.id, {
      cancel_at_period_end: true,
    });
    return { subscription: updated, changeType: "cancel" };
  }

  // Handle upgrade to lifetime = cancel subscription + create checkout
  if (newPlan === "lifetime") {
    // Cancel current subscription at period end
    await stripe.subscriptions.update(subscription.id, {
      cancel_at_period_end: true,
    });

    // Return signal to create lifetime checkout
    return {
      subscription: null,
      changeType: "lifetime",
      requiresCheckout: true
    };
  }

  // Handle subscription tier change (premium <-> unlimited)
  const newPriceId = PLAN_TO_PRICE_MAP[newPlan];

  if (!newPriceId) {
    throw new Error(`No price ID found for plan: ${newPlan}`);
  }

  const updated = await stripe.subscriptions.update(subscription.id, {
    items: [
      {
        id: subscription.items.data[0].id,
        price: newPriceId,
      },
    ],
    proration_behavior: isUpgrade ? "always_invoice" : "create_prorations",
    billing_cycle_anchor: isUpgrade ? "now" : "unchanged",
  });

  return {
    subscription: updated,
    changeType: isUpgrade ? "upgrade" : "downgrade"
  };
}
```

#### 2. Create Subscription Update API Route

**File**: `app/api/stripe/subscription/route.ts` (modify existing or create new)

**Changes**: Add PUT handler for subscription updates

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import { updateSubscription, PLAN_TO_PRICE_MAP } from "@/lib/stripe";

export async function PUT(request: NextRequest) {
  try {
    const supabase = await createServerComponentClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { newPlan } = (await request.json()) as {
      newPlan: "free" | "premium" | "unlimited" | "lifetime"
    };

    if (!["free", "premium", "unlimited", "lifetime"].includes(newPlan)) {
      return NextResponse.json({ error: "Invalid plan" }, { status: 400 });
    }

    // Update subscription via Stripe
    const result = await updateSubscription({
      userId: user.id,
      newPlan,
    });

    // If changing to lifetime, return checkout URL
    if (result.requiresCheckout) {
      const priceId = PLAN_TO_PRICE_MAP.lifetime;
      const { createLifetimeCheckoutSession } = await import("@/lib/stripe");

      const session = await createLifetimeCheckoutSession({
        userId: user.id,
        email: user.email!,
        priceId,
        successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
        cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/upgrade`,
      });

      return NextResponse.json({
        success: true,
        changeType: "lifetime",
        checkoutUrl: session.url
      });
    }

    return NextResponse.json({
      success: true,
      changeType: result.changeType,
      message: result.changeType === "cancel"
        ? "Subscription will cancel at the end of your billing period"
        : result.changeType === "upgrade"
        ? "Plan upgraded! You'll be charged the prorated difference."
        : "Plan change scheduled for end of billing period"
    });

  } catch (error) {
    console.error("Error updating subscription:", error);
    return NextResponse.json(
      {
        error: "Failed to update subscription",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}
```

#### 3. Update PlanSelector to Handle Subscription Changes

**File**: `components/billing/plan-selector.tsx`

**Changes**: Modify paid plan handler to detect subscription updates

```typescript
const handlePaidPlan = async (
  plan: "premium" | "unlimited" | "lifetime"
) => {
  try {
    setLoading(plan);

    // If in upgrade mode and user has a paid plan, use subscription update API
    if (mode === "upgrade" && currentPlan && currentPlan !== "free") {
      const response = await fetch("/api/stripe/subscription", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ newPlan: plan }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Failed to update subscription");
      }

      // If lifetime, redirect to checkout
      if (result.checkoutUrl) {
        window.location.href = result.checkoutUrl;
        return;
      }

      // Show success message
      alert(result.message);
      router.push("/billing");
      router.refresh();
      return;
    }

    // Otherwise, create new checkout (existing logic)
    const response = await fetch("/api/stripe/checkout", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ plan, userId }),
    });

    const { url } = await response.json();

    if (url) {
      window.location.href = url;
    } else {
      throw new Error("No checkout URL returned");
    }
  } catch (error) {
    console.error("Error with plan change:", error);
    alert("Failed to process plan change. Please try again.");
    setLoading(null);
  }
};
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`
- [x] API routes respond correctly

#### Manual Verification:
- [ ] Premium → Unlimited upgrade works with immediate proration
- [ ] Unlimited → Premium downgrade schedules change for end of cycle
- [ ] Premium → Lifetime cancels subscription and redirects to checkout
- [ ] Premium → Free cancels subscription at period end
- [ ] Error handling works for invalid requests
- [ ] Webhook properly updates database after subscription changes

---

## Phase 4: Refine `/billing` Page

### Overview
Ensure `/billing` page has clear CTAs based on user's plan type.

### Changes Required:

#### 1. Update Billing Page CTAs

**File**: `app/billing/page.tsx`

**Changes**: Add more nuanced CTAs

```typescript
<div className="flex items-center justify-between">
  <div>
    <p className="text-lg font-medium capitalize">{access.plan} Plan</p>
    {access.plan === "free" && (
      <p className="text-gray-600 mt-1">
        {access.remainingRounds} rounds remaining
      </p>
    )}
    {access.currentPeriodEnd && !access.isLifetime && (
      <p className="text-gray-600 mt-1">
        {access.cancelAtPeriodEnd
          ? `Cancels on ${access.currentPeriodEnd.toLocaleDateString()}`
          : `Renews on ${access.currentPeriodEnd.toLocaleDateString()}`
        }
      </p>
    )}
    {access.isLifetime && (
      <p className="text-green-600 mt-1 font-medium">
        ✓ Lifetime Access
      </p>
    )}
  </div>

  <div className="flex gap-4">
    {/* Always show "Change Plan" for non-lifetime users */}
    {!access.isLifetime && (
      <a
        href="/upgrade"
        className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition"
      >
        {access.plan === "free" ? "Upgrade Plan" : "Change Plan"}
      </a>
    )}

    {/* Show subscription management for paid users only */}
    {access.plan !== "free" && !access.isLifetime && (
      <ManageSubscriptionButton />
    )}

    {/* Lifetime users: no action needed */}
    {access.isLifetime && (
      <div className="text-gray-500 text-sm">
        No subscription management needed
      </div>
    )}
  </div>
</div>
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`

#### Manual Verification:
- [ ] Free users see "Upgrade Plan" button
- [ ] Premium/Unlimited users see both "Change Plan" and "Manage Subscription"
- [ ] Lifetime users see no action buttons
- [ ] Cancellation status displays correctly
- [ ] Next billing date shows correctly for active subscriptions

---

## Phase 5: Update `/onboarding` Redirects

### Overview
Ensure users with existing plans cannot access onboarding and are properly redirected.

### Changes Required:

#### 1. Strengthen Onboarding Guard

**File**: `app/onboarding/page.tsx`

**Changes**: Already has redirect logic (lines 16-28), but add clearer messaging

```typescript
// Check if user already has access
const access = await getComprehensiveUserAccess(user.id);

if (access.hasAccess) {
  // User already has a plan selected - redirect to appropriate page
  if (access.plan === "free") {
    // Free users should see billing page or upgrade
    redirect("/billing");
  } else if (access.hasPremiumAccess) {
    // Paid users go to billing dashboard
    redirect("/billing");
  }
}

// If no access, show onboarding
return (
  <div className="container mx-auto px-4 py-16">
    <div className="max-w-6xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Welcome to Handicappin!</h1>
        <p className="text-lg text-gray-600">
          Choose the plan that&apos;s right for you and start tracking your golf rounds
        </p>
      </div>

      <PlanSelector userId={user.id} mode="onboarding" />
    </div>
  </div>
);
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `pnpm build`

#### Manual Verification:
- [ ] Users with free plan accessing `/onboarding` → redirected to `/billing`
- [ ] Users with paid plans accessing `/onboarding` → redirected to `/billing`
- [ ] New users (no plan) can access `/onboarding` successfully
- [ ] After selecting a plan on onboarding, redirect works correctly

---

## Testing Strategy

### Unit Tests:
- [ ] Test `getAvailablePlans()` helper with all plan combinations
- [ ] Test PlanSelector filtering logic
- [ ] Test subscription update API with mock Stripe responses

### Integration Tests:
- [ ] Test complete onboarding flow (new user → plan selection → redirect)
- [ ] Test upgrade flow (free → premium → success)
- [ ] Test downgrade flow (premium → free → scheduled cancellation)
- [ ] Test lifetime purchase flow (premium → lifetime → checkout)

### Manual Testing Steps:

**New User Flow:**
1. Create new account
2. Verify redirect to `/onboarding`
3. Select free plan
4. Verify redirect to `/`
5. Navigate to `/billing` - should see free plan details
6. Click "Upgrade Plan" - verify redirect to `/upgrade`
7. Verify only Premium, Unlimited, Lifetime show on `/upgrade`

**Free → Paid Upgrade:**
1. As free user, go to `/upgrade`
2. Click "Subscribe" on Premium
3. Complete Stripe checkout
4. Verify webhook updates plan to Premium
5. Verify redirect to `/billing/success`
6. Navigate to `/billing` - should show Premium plan details

**Premium → Unlimited Upgrade:**
1. As premium user, go to `/upgrade`
2. Click "Subscribe" on Unlimited
3. Verify immediate proration message
4. Confirm change
5. Verify webhook updates plan to Unlimited
6. Check Stripe dashboard for proration invoice

**Premium → Free Downgrade:**
1. As premium user, go to `/upgrade`
2. Click "Start Free"
3. Verify "scheduled for end of cycle" message
4. Confirm change
5. Verify subscription shows `cancel_at_period_end: true`
6. Verify `/billing` shows cancellation date
7. Wait for period end (or simulate in Stripe)
8. Verify plan reverts to Free

**Lifetime Purchase:**
1. As premium user, go to `/upgrade`
2. Click "Buy Lifetime"
3. Verify subscription cancellation + redirect to checkout
4. Complete Stripe checkout
5. Verify webhook updates plan to Lifetime
6. Navigate to `/billing` - should show Lifetime with no management options
7. Navigate to `/upgrade` - should show "best plan" message

**Edge Cases:**
- [ ] User with plan tries to access `/onboarding` - redirected to `/billing`
- [ ] User without plan tries to access `/upgrade` - redirected to `/onboarding`
- [ ] Lifetime user goes to `/upgrade` - sees "best plan" message
- [ ] Canceled subscription (cancel_at_period_end) still has access until period end
- [ ] Failed payment transitions user to `past_due` status

## Performance Considerations

- **Stripe API calls**: Subscription updates are async; use webhooks for database updates
- **Proration calculation**: Let Stripe handle it (no client-side calculation needed)
- **Caching**: Access control checks hit database; consider caching user plan in session

## Migration Notes

No database migrations required - all existing tables and fields are sufficient.

### Deployment Steps:
1. Deploy code changes
2. Test in production with test Stripe account
3. Verify webhooks are processing correctly
4. Monitor error logs for first 24 hours

## References

- Original ticket: `.claude/tickets/0006-implement-upgrade-downgrade-page.md`
- Stripe Subscriptions API: https://stripe.com/docs/api/subscriptions/update
- Stripe Proration: https://stripe.com/docs/billing/subscriptions/prorations
- Existing webhook handler: `app/api/stripe/webhook/route.ts`
- Access control: `utils/billing/access-control.ts`
