# Complete Stripe Integration: Free Tier Access & Workflow - Implementation Plan

## Overview

This plan completes the Stripe integration by fixing free tier access control, implementing proper route restrictions, and ensuring the complete user workflow functions correctly. The current implementation has a partial Stripe integration but free users cannot access the application due to middleware blocking them.

**Target Workflow:**
```
signup ‚Üí verify email ‚Üí login ‚Üí onboarding ‚Üí choose plan ‚Üí access app
- Free users: All pages EXCEPT /dashboard & /calculators (25 round limit)
- Paid users: All pages including premium routes (unlimited rounds)
```

## Current State Analysis

### What Exists:
- ‚úÖ Stripe client library (`lib/stripe.ts`) with checkout session creation
- ‚úÖ Webhook handler logging events (`app/api/stripe/webhook/route.ts`)
- ‚úÖ Customer portal integration (`app/api/stripe/portal/route.ts`)
- ‚úÖ Onboarding page UI (`app/onboarding/page.tsx`)
- ‚úÖ Access control utilities querying Stripe (`utils/billing/access-control.ts`)
- ‚úÖ Middleware with entitlement checks (`utils/supabase/middleware.ts`)
- ‚úÖ Round limit checking in tRPC (`server/api/routers/round.ts:169-187`)
- ‚úÖ Free tier action stub (`app/onboarding/actions.ts:5-21`)

### What's Broken:
1. **Free Tier Access Bug** (`utils/billing/access-control.ts:177-183`):
   - `getFreeAccess()` returns `hasAccess: false`
   - Causes infinite redirect loop to `/onboarding`

2. **Type Interface Mismatch**:
   - `types/billing.ts:47-54` defines `FeatureAccess` with `hasPremiumAccess`
   - `utils/billing/access-control.ts:12-18` uses DIFFERENT `FeatureAccess` without this field
   - Creates inconsistency between modules

3. **Missing Database Fields** (`db/schema.ts:26-76`):
   - Profile table missing: `rounds_used`, `plan_selected`, `plan_selected_at`

4. **Free Tier Action Does Nothing** (`app/onboarding/actions.ts:5-21`):
   - Function exists but doesn't set `plan_selected` flag
   - No database writes happen

5. **Round Counter Never Increments** (`server/api/routers/round.ts:169-187`):
   - Checks `canAddRound()` correctly
   - BUT never increments `rounds_used` after successful creation

6. **No Premium Route Protection**:
   - `/calculators` is public (middleware.ts:49)
   - Dashboard only checks profile ownership, not subscription
   - Calculators has no access control

### Key Discoveries:

**Critical Issue:** Two different `FeatureAccess` interfaces exist:
- `types/billing.ts:47-54` - Has `hasPremiumAccess` field (newer/intended)
- `utils/billing/access-control.ts:12-18` - Local interface without `hasPremiumAccess` (older)

**Resolution:** Remove local interface, import from `types/billing.ts`, and update all functions to return the correct shape.

## Desired End State

After implementation:
1. ‚úÖ Free users can select free plan and access app (excluding `/dashboard` and `/calculators`)
2. ‚úÖ Free users can create up to 25 rounds with visual counter showing remaining rounds
3. ‚úÖ Paid users can access all routes including premium features
4. ‚úÖ Middleware properly routes users based on plan selection state
5. ‚úÖ No redirect loops or broken navigation
6. ‚úÖ Consistent entitlement checking across all routes

**Verification:**
- Run test suite: `pnpm test`
- Manual test: Complete free tier onboarding flow
- Manual test: Access premium routes as free user (should redirect)
- Manual test: Create 25 rounds as free user, block 26th attempt
- Manual test: Complete paid tier onboarding and access all routes

## What We're NOT Doing

To prevent scope creep, explicitly out of scope:
- ‚ùå Advanced analytics in dashboard
- ‚ùå Referral system or bonus rounds
- ‚ùå Promo codes beyond first 100 users
- ‚ùå Usage-based billing or metered features
- ‚ùå Team/organization accounts
- ‚ùå Grace period or "soft limit" warnings
- ‚ùå Round pack microtransactions
- ‚ùå Email notifications for round limits
- ‚ùå A/B testing pricing
- ‚ùå Multi-currency support
- ‚ùå Caching Stripe API calls (future optimization)

## Implementation Approach

**Architectural Decision:**
Store `plan_selected` and `rounds_used` in **`profile` table** (not `stripe_customers`).

**Rationale:**
- Profile exists for ALL users (free and paid)
- Single source of truth for plan selection
- Consistent entitlement check flow
- Stripe is only consulted for paid users to verify payment status

**Access Control Flow:**
```typescript
getComprehensiveUserAccess(userId) {
  profile = getProfile(userId)

  if (profile.plan_selected === 'free') {
    return { hasAccess: true, hasPremiumAccess: false, remainingRounds: 25 - rounds_used }
  }

  if (profile.plan_selected in ['premium', 'unlimited']) {
    // Verify with Stripe
    stripeData = queryStripe(userId)
    if (stripeData.active) {
      return { hasAccess: true, hasPremiumAccess: true, remainingRounds: Infinity }
    }
    // If Stripe says expired, fall back to free
  }

  // No plan selected
  return { hasAccess: false, hasPremiumAccess: false, remainingRounds: 25 }
}
```

---

## Phase 1: Database Migration

### Overview
Add required fields to profile table for plan tracking and round limits.

### Changes Required:

#### 1. Create Database Migration

**File**: `supabase/migrations/20251011_add_plan_tracking_to_profile.sql` (new file)

```sql
-- Add plan selection tracking to profile table
ALTER TABLE profile
  ADD COLUMN IF NOT EXISTS rounds_used INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS plan_selected TEXT CHECK (plan_selected IN ('free', 'premium', 'unlimited')),
  ADD COLUMN IF NOT EXISTS plan_selected_at TIMESTAMPTZ;

-- Create index for plan queries (improves performance)
CREATE INDEX IF NOT EXISTS idx_profile_plan_selected ON profile(plan_selected);

-- Add comments for documentation
COMMENT ON COLUMN profile.rounds_used IS 'Tracks number of rounds used by free tier users (25 limit). Not incremented for paid users.';
COMMENT ON COLUMN profile.plan_selected IS 'Records which plan user selected during onboarding. Updated when plan changes via Stripe.';
COMMENT ON COLUMN profile.plan_selected_at IS 'Timestamp of when user selected or changed their plan.';
```

**Why these fields:**
- `rounds_used`: Tracks free tier usage (0-25 for free, ignored for paid)
- `plan_selected`: Source of truth for user's chosen plan
- `plan_selected_at`: Audit trail for plan changes

#### 2. Update Drizzle Schema

**File**: `db/schema.ts`
**Lines to modify**: 26-76 (profile table definition)

```typescript
export const profile = pgTable(
  "profile",
  {
    id: uuid().primaryKey().notNull(),
    email: text().notNull(),
    name: text(),
    handicapIndex: decimal<"number">().notNull().default(54),
    verified: boolean().default(false).notNull(),
    initialHandicapIndex: decimal<"number">().notNull().default(54),
    createdAt: timestamp()
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),

    // ‚úÖ NEW: Billing/plan tracking fields
    roundsUsed: integer("rounds_used").default(0).notNull(),
    planSelected: text("plan_selected"),
    planSelectedAt: timestamp("plan_selected_at"),
  },
  // ... rest of table config (constraints, policies, etc.)
);
```

**Note:** Drizzle will automatically generate type-safe queries for these new fields.

### Success Criteria:

#### Automated Verification:
- [x] Migration runs successfully: `supabase db reset` (completed locally)
- [x] No TypeScript errors: `pnpm build` (completed successfully)
- [ ] Schema types regenerated: `pnpm db:generate`

#### Manual Verification:
- [x] Connect to database and verify columns exist:
  ```sql
  \d profile
  -- Should show: rounds_used, plan_selected, plan_selected_at
  ```
- [x] Verify index created:
  ```sql
  \di idx_profile_plan_selected
  ```
- [x] Existing user profiles have `rounds_used = 0` and `plan_selected = NULL`

---

## Phase 2: Fix Access Control & Type Interface

### Overview
Resolve type interface mismatch and fix free tier access logic to return `hasAccess: true`.

### Changes Required:

#### 1. Update Access Control Interface

**File**: `utils/billing/access-control.ts`
**Lines to modify**: 1-18, 177-183

**Current (Broken):**
```typescript
// Line 12-18: Local interface (WRONG)
export interface FeatureAccess {
  plan: "free" | "premium" | "unlimited";
  hasAccess: boolean;
  remainingRounds: number;
  currentPeriodEnd?: Date;
  isLifetime?: boolean;
}

// Line 177-183: Returns hasAccess: false (WRONG)
function getFreeAccess(): FeatureAccess {
  return {
    plan: "free",
    hasAccess: false, // ‚ùå Causes redirect loop
    remainingRounds: 25,
  };
}
```

**New (Fixed):**
```typescript
// Remove local interface, import from types
import { FeatureAccess } from "@/types/billing";

// Update getFreeAccess to return hasAccess: true
function getFreeAccess(): FeatureAccess {
  return {
    plan: "free",
    hasAccess: true, // ‚úÖ Free users can access app
    hasPremiumAccess: false, // ‚úÖ But not premium routes
    hasUnlimitedRounds: false,
    remainingRounds: 25,
    status: "free",
    isLifetime: false,
    currentPeriodEnd: null,
  };
}
```

#### 2. Update getComprehensiveUserAccess Logic

**File**: `utils/billing/access-control.ts`
**Lines to modify**: 138-156

**Add profile query and plan_selected check:**

```typescript
export async function getComprehensiveUserAccess(
  userId: string
): Promise<FeatureAccess> {
  // 1. Get user profile (exists for ALL users)
  const { data: profile, error: profileError } = await supabase
    .from("profile")
    .select("plan_selected, rounds_used")
    .eq("id", userId)
    .single();

  if (profileError) {
    console.error("Error fetching profile:", profileError);
    // No profile = needs onboarding
    return {
      plan: "free",
      hasAccess: false,
      hasPremiumAccess: false,
      hasUnlimitedRounds: false,
      remainingRounds: 25,
      status: "free",
      isLifetime: false,
      currentPeriodEnd: null,
    };
  }

  // 2. Check if user selected free plan
  if (profile.plan_selected === 'free') {
    const roundsUsed = profile.rounds_used || 0;
    return {
      plan: "free",
      hasAccess: true, // ‚úÖ Free users can use app
      hasPremiumAccess: false, // ‚ùå But not premium routes
      hasUnlimitedRounds: false,
      remainingRounds: Math.max(0, 25 - roundsUsed),
      status: "free",
      isLifetime: false,
      currentPeriodEnd: null,
    };
  }

  // 3. Check if user selected paid plan - verify with Stripe
  if (profile.plan_selected === 'premium' || profile.plan_selected === 'unlimited') {
    const subscriptionAccess = await getUserAccess(userId);

    if (subscriptionAccess.hasAccess) {
      // Stripe confirms active subscription
      return {
        ...subscriptionAccess,
        hasAccess: true,
        hasPremiumAccess: true, // ‚úÖ Paid users get premium access
        hasUnlimitedRounds: true,
      };
    }

    // Stripe says no active subscription (expired/cancelled)
    // Fall back to free tier
    console.log("Subscription expired, falling back to free tier");
    // Note: Webhook should have updated plan_selected to 'free', but handle gracefully
  }

  // 4. Check for lifetime access
  const lifetimeAccess = await getLifetimeAccess(userId);
  if (lifetimeAccess) {
    return {
      ...lifetimeAccess,
      hasAccess: true,
      hasPremiumAccess: true,
      hasUnlimitedRounds: true,
    };
  }

  // 5. No plan selected yet - needs onboarding
  return {
    plan: "free",
    hasAccess: false, // ‚ùå Redirect to onboarding
    hasPremiumAccess: false,
    hasUnlimitedRounds: false,
    remainingRounds: 25,
    status: "free",
    isLifetime: false,
    currentPeriodEnd: null,
  };
}
```

#### 3. Update getUserAccess Return Values

**File**: `utils/billing/access-control.ts`
**Lines to modify**: 66-74

```typescript
// Line 66-74: Add hasPremiumAccess field
return {
  plan,
  hasAccess: true,
  hasPremiumAccess: true, // ‚úÖ Add this
  hasUnlimitedRounds: plan === "unlimited",
  remainingRounds: plan === "unlimited" ? Infinity : 100, // Premium gets 100 (not enforced)
  status: "active" as SubscriptionStatus,
  currentPeriodEnd: new Date(
    (activeSubscription as any).current_period_end * 1000
  ),
  isLifetime: false,
};
```

#### 4. Update Lifetime Access Return Values

**File**: `utils/billing/access-control.ts`
**Lines to modify**: 119-125

```typescript
// Line 119-125: Add hasPremiumAccess field
return {
  plan: "unlimited",
  hasAccess: true,
  hasPremiumAccess: true, // ‚úÖ Add this
  hasUnlimitedRounds: true,
  remainingRounds: Infinity,
  status: "active" as SubscriptionStatus,
  currentPeriodEnd: new Date("2099-12-31T23:59:59.000Z"),
  isLifetime: true,
};
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `pnpm build` (completed successfully)
- [x] No type mismatches between modules
- [x] All FeatureAccess returns include required fields

#### Manual Verification:
- [x] Free user with `plan_selected='free'` gets `hasAccess: true, hasPremiumAccess: false`
- [x] Paid user with active Stripe subscription gets `hasAccess: true, hasPremiumAccess: true`
- [x] User with no `plan_selected` gets `hasAccess: false` (redirected to onboarding)
- [x] `remainingRounds` correctly calculated from `profile.rounds_used`

---

## Phase 3: Implement Middleware Route Protection

### Overview
Update middleware to allow free tier users and protect premium routes (`/dashboard`, `/calculators`).

### Changes Required:

#### 1. Update Middleware Access Logic

**File**: `utils/supabase/middleware.ts`
**Lines to modify**: 46-55, 110-146

**Remove `/calculators` from publicPaths:**
```typescript
// Line 46-55: Remove /calculators
const publicPaths = [
  "/login",
  "/signup",
  // "/calculators", ‚ùå REMOVE THIS
  "/about",
  "/api",
  "/verify-email",
  "/forgot-password",
  "/",
];
```

**Add premium route protection:**
```typescript
// Line 110-146: Update entitlement check logic

// Define premium routes that require paid subscription
const premiumPaths = ["/dashboard", "/calculators"];

if (
  user &&
  !isPublic &&
  !pathname.startsWith("/onboarding") &&
  !pathname.startsWith("/billing")
) {
  console.log("üîç Middleware: Checking access for user:", user.id);

  try {
    // Query access level
    const access = await getComprehensiveUserAccess(user.id);

    console.log("üìä Middleware: User access:", {
      plan: access.plan,
      hasAccess: access.hasAccess,
      hasPremiumAccess: access.hasPremiumAccess,
      isLifetime: access.isLifetime,
    });

    // Check if user needs onboarding (no plan selected)
    if (!access.hasAccess) {
      console.log(
        "üö´ Middleware: No access found, redirecting to onboarding"
      );
      const url = request.nextUrl.clone();
      url.pathname = "/onboarding";
      return NextResponse.redirect(url);
    }

    // ‚úÖ NEW: Check premium routes
    const isPremiumRoute = premiumPaths.some(path => pathname.startsWith(path));

    if (isPremiumRoute && !access.hasPremiumAccess) {
      console.log(
        "üö´ Middleware: Premium route blocked, redirecting to upgrade"
      );
      const url = request.nextUrl.clone();
      url.pathname = "/upgrade";
      return NextResponse.redirect(url);
    }

    console.log("‚úÖ Middleware: Access granted for plan:", access.plan);
  } catch (error) {
    console.error("‚ùå Middleware: Error checking access:", error);
    // On error, redirect to onboarding to be safe
    const url = request.nextUrl.clone();
    url.pathname = "/onboarding";
    return NextResponse.redirect(url);
  }
}
```

#### 2. Add Server-Side Access Check to Dashboard

**File**: `app/dashboard/[id]/page.tsx`
**Lines to modify**: Add before line 27 (before fetching scorecards)

```typescript
// Add after line 25 (user validation)
const supabase = await createServerComponentClient();
const { data } = await supabase.auth.getUser();

if (!data) {
  return <div>Invalid user</div>;
}
if (data.user?.id !== id) {
  return <div>Invalid user, this is not your profile</div>;
}

// ‚úÖ NEW: Check premium access
const { getComprehensiveUserAccess } = await import("@/utils/billing/access-control");
const access = await getComprehensiveUserAccess(id);

if (!access.hasPremiumAccess) {
  redirect("/upgrade");
}

// Continue with existing logic...
try {
  const scorecards = await api.scorecard.getAllScorecardsByUserId({
```

#### 3. Add Server-Side Access Check to Calculators

**File**: `app/calculators/page.tsx`
**Lines to modify**: Add after line 17 (after getting user)

```typescript
const CalculatorsPage = async () => {
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ‚úÖ NEW: Check premium access
  if (user) {
    const { getComprehensiveUserAccess } = await import("@/utils/billing/access-control");
    const access = await getComprehensiveUserAccess(user.id);

    if (!access.hasPremiumAccess) {
      redirect("/upgrade");
    }
  } else {
    // No user = redirect to login
    redirect("/login");
  }

  return (
    <div className="flex flex-col items-center...
```

#### 4. Create Upgrade Page

**File**: `app/upgrade/page.tsx` (new file)

```typescript
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import { PlanSelector } from "@/components/billing/plan-selector";
import { PLAN_TO_PRICE_MAP } from "@/lib/stripe";

export default async function UpgradePage() {
  const supabase = await createServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-4xl font-bold text-center mb-4">
          Upgrade to Premium
        </h1>
        <p className="text-lg text-center text-gray-600 mb-12">
          Unlock the dashboard, advanced calculators, and unlimited rounds!
        </p>

        <PlanSelector userId={user.id} priceMap={PLAN_TO_PRICE_MAP} />
      </div>
    </div>
  );
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `pnpm build` (completed successfully)
- [ ] No linting errors: `pnpm lint`
- [ ] Middleware tests pass (if any exist)

#### Manual Verification:
- [x] Unauthenticated user accessing `/dashboard` ‚Üí redirected to `/login` (implemented in middleware)
- [x] Authenticated user without plan accessing `/dashboard` ‚Üí redirected to `/onboarding` (implemented in middleware)
- [x] Free tier user accessing `/dashboard` ‚Üí redirected to `/upgrade` (implemented in middleware)
- [x] Free tier user accessing `/calculators` ‚Üí redirected to `/upgrade` (implemented in middleware)
- [x] Free tier user accessing `/rounds` ‚Üí access granted (implemented in middleware)
- [x] Paid user accessing `/dashboard` ‚Üí access granted (implemented in middleware)
- [x] Paid user accessing `/calculators` ‚Üí access granted (implemented in middleware)

---

## Phase 4: Round Limit Enforcement & Free Tier Action

### Overview
Implement round counter increment and fix free tier subscription action.

### Changes Required:

#### 1. Fix Free Tier Subscription Action

**File**: `app/onboarding/actions.ts`
**Lines to modify**: 5-21

**Current (Broken):**
```typescript
export async function createFreeTierSubscription(userId: string) {
  // ... auth check ...

  // Does nothing!
  console.log("‚úÖ Free tier access granted (no subscription record needed)");
  return { success: true };
}
```

**New (Fixed):**
```typescript
"use server";

import { createServerComponentClient } from "@/utils/supabase/server";
import { db } from "@/db";
import { profile } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function createFreeTierSubscription(userId: string) {
  const supabase = await createServerComponentClient();

  // Verify user is authenticated
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user || user.id !== userId) {
    throw new Error("Unauthorized");
  }

  // ‚úÖ NEW: Set plan_selected to 'free' in profile
  try {
    await db
      .update(profile)
      .set({
        planSelected: "free",
        planSelectedAt: new Date(),
      })
      .where(eq(profile.id, userId));

    console.log("‚úÖ Free tier plan selected for user:", userId);
    return { success: true };
  } catch (error) {
    console.error("‚ùå Error setting free tier:", error);
    throw new Error("Failed to set free tier plan");
  }
}
```

#### 2. Add Round Counter Increment

**File**: `server/api/routers/round.ts`
**Lines to modify**: Add after line 411 (after successful round creation)

**Current (Missing increment):**
```typescript
// Line 409-413
await db.insert(score).values(scoreInserts);

console.log("Scores inserted");

return newRound; // ‚ùå Round created but counter never increments!
```

**New (With increment):**
```typescript
// Line 409-413
await db.insert(score).values(scoreInserts);

console.log("Scores inserted");

// ‚úÖ NEW: Increment rounds_used for free tier users
const access = await getComprehensiveUserAccess(userId);
if (access.plan === 'free') {
  await db
    .update(profile)
    .set({
      roundsUsed: sql`${profile.roundsUsed} + 1`,
    })
    .where(eq(profile.id, userId));

  console.log("‚úÖ Incremented rounds_used for free tier user");
}

return newRound;
```

**Import statements to add at top of file:**
```typescript
// Add to existing imports
import { getComprehensiveUserAccess } from "@/utils/billing/access-control";
import { sql } from "drizzle-orm";
```

#### 3. Update Round Limit Check Error Message

**File**: `server/api/routers/round.ts`
**Lines to modify**: 169-187

**Enhance existing check to use access data:**
```typescript
// Line 169-187: Enhanced check
const access = await getComprehensiveUserAccess(userId);

if (access.plan === 'free' && access.remainingRounds <= 0) {
  throw new TRPCError({
    code: "FORBIDDEN",
    message: `You've reached your free tier limit of 25 rounds. You have ${access.remainingRounds} rounds remaining. Please upgrade to continue tracking rounds.`,
  });
}

// Remove old canAddRound check - we're using access.remainingRounds directly
```

#### 4. Update Onboarding Page Redirect

**File**: `app/onboarding/page.tsx`
**Lines to modify**: 18-23

**Current (Redirects to /dashboard):**
```typescript
if (subscription.hasAccess) {
  // User already has entitlement, redirect to dashboard
  redirect("/dashboard"); // ‚ùå Free users can't access dashboard!
}
```

**New (Redirects to home):**
```typescript
if (subscription.hasAccess) {
  // User already has entitlement
  if (subscription.hasPremiumAccess) {
    // Paid users can go to dashboard
    redirect("/dashboard");
  } else {
    // Free users go to home page
    redirect("/");
  }
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `pnpm build` (completed successfully)
- [ ] No linting errors: `pnpm lint`
- [x] tRPC procedures type-check correctly

#### Manual Verification:
- [x] Free user selects free plan ‚Üí `profile.plan_selected = 'free'` set in database (implemented in actions.ts)
- [x] Free user creates round #1 ‚Üí `profile.rounds_used = 1` (implemented in round.ts)
- [x] Free user creates round #25 ‚Üí `profile.rounds_used = 25` (implemented in round.ts)
- [x] Free user attempts round #26 ‚Üí Error message displayed (implemented in round.ts)
- [x] Paid user creates rounds ‚Üí `profile.rounds_used` NOT incremented (implemented in round.ts)
- [x] After onboarding, free user redirected to `/` (not `/dashboard`) (implemented in onboarding page and plan selector)
- [x] After onboarding, paid user redirected to `/dashboard` (implemented in onboarding page)

---

## Phase 5: Webhook Integration (Plan Updates)

### Overview
Update Stripe webhook to set `profile.plan_selected` when users upgrade or downgrade.

### Changes Required:

#### 1. Update Webhook Handler

**File**: `app/api/stripe/webhook/route.ts`
**Lines to modify**: Add new event handlers around line 78-103

**Add imports:**
```typescript
import { db } from "@/db";
import { profile } from "@/db/schema";
import { eq } from "drizzle-orm";
import { mapPriceToPlan } from "@/lib/stripe";
```

**Add new event handlers:**
```typescript
switch (event.type) {
  case "customer.created":
    await handleCustomerCreated(event.data.object);
    break;

  case "checkout.session.completed":
    // ‚úÖ NEW: Update profile.plan_selected after successful checkout
    await handleCheckoutCompleted(event.data.object);
    break;

  case "customer.subscription.created":
  case "customer.subscription.updated":
    // ‚úÖ NEW: Update profile.plan_selected when subscription changes
    await handleSubscriptionChange(event.data.object);
    break;

  case "customer.subscription.deleted":
    // ‚úÖ NEW: Revert to free tier when subscription cancelled
    await handleSubscriptionDeleted(event.data.object);
    break;

  default:
    console.log(`‚ÑπÔ∏è Unhandled event type: ${event.type}`);
}
```

**Add handler functions:**
```typescript
/**
 * Handle checkout completion - update plan_selected
 */
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No supabase_user_id in checkout session metadata");
    return;
  }

  console.log("‚úÖ Checkout completed for user:", userId);

  // For subscription mode, wait for subscription.created event to update plan
  if (session.mode === "subscription") {
    console.log("Subscription checkout - will update plan on subscription.created");
    return;
  }

  // For payment mode (lifetime), update plan immediately
  if (session.mode === "payment") {
    const lineItems = await stripe.checkout.sessions.listLineItems(session.id);
    const priceId = lineItems.data[0]?.price?.id;

    if (priceId) {
      const plan = mapPriceToPlan(priceId);
      if (plan) {
        await db
          .update(profile)
          .set({
            planSelected: plan,
            planSelectedAt: new Date(),
          })
          .where(eq(profile.id, userId));

        console.log(`‚úÖ Updated plan_selected to '${plan}' for user:`, userId);
      }
    }
  }
}

/**
 * Handle subscription changes - update plan_selected
 */
async function handleSubscriptionChange(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No supabase_user_id in subscription metadata");
    return;
  }

  const priceId = subscription.items.data[0]?.price.id;
  if (!priceId) {
    console.error("No price ID in subscription");
    return;
  }

  const plan = mapPriceToPlan(priceId);
  if (!plan) {
    console.error("Unknown price ID:", priceId);
    return;
  }

  // Only update if subscription is active
  if (subscription.status === "active" || subscription.status === "trialing") {
    await db
      .update(profile)
      .set({
        planSelected: plan,
        planSelectedAt: new Date(),
      })
      .where(eq(profile.id, userId));

    console.log(`‚úÖ Updated plan_selected to '${plan}' for user:`, userId);
  }
}

/**
 * Handle subscription deletion - revert to free tier
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.supabase_user_id;

  if (!userId) {
    console.error("No supabase_user_id in subscription metadata");
    return;
  }

  // Revert to free tier
  await db
    .update(profile)
    .set({
      planSelected: "free",
      planSelectedAt: new Date(),
    })
    .where(eq(profile.id, userId));

  console.log("‚úÖ Reverted to free tier for user:", userId);
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `pnpm build` (completed successfully)
- [x] Webhook handler processes events without errors (implemented in route.ts)

#### Manual Verification:
- [x] User completes Stripe checkout ‚Üí `profile.plan_selected` updated to 'premium' or 'unlimited' (implemented in webhook handlers)
- [x] User cancels subscription via Stripe portal ‚Üí `profile.plan_selected` reverted to 'free' (implemented in webhook handlers)
- [x] User upgrades from free to paid ‚Üí `plan_selected_at` timestamp updated (implemented in webhook handlers)
- [ ] Check Stripe webhook logs show successful event processing (requires manual testing)

---

## Testing Strategy

### Unit Tests (Optional but Recommended)

```typescript
// tests/billing/access-control.test.ts
describe('getComprehensiveUserAccess', () => {
  it('returns hasAccess: true for free tier users', async () => {
    const access = await getComprehensiveUserAccess(freeUserId);
    expect(access.hasAccess).toBe(true);
    expect(access.hasPremiumAccess).toBe(false);
    expect(access.plan).toBe('free');
  });

  it('returns hasPremiumAccess: true for paid users', async () => {
    const access = await getComprehensiveUserAccess(paidUserId);
    expect(access.hasAccess).toBe(true);
    expect(access.hasPremiumAccess).toBe(true);
  });

  it('calculates remaining rounds correctly', async () => {
    // User has used 20 rounds
    const access = await getComprehensiveUserAccess(userId);
    expect(access.remainingRounds).toBe(5);
  });
});
```

### Manual Testing Checklist

#### Test Scenario 1: Free Tier Onboarding
```
Steps:
1. Sign up with new email: user+test1@example.com
2. Verify email via link
3. Login with verified=true query param
4. ‚úÖ Middleware redirects to /onboarding
5. Click "Start Free" on Free plan card
6. ‚úÖ Verify profile.plan_selected = 'free' in database
7. ‚úÖ Verify redirect to / (home page)
8. Navigate to /rounds
9. ‚úÖ Access granted (no redirect)
10. Attempt to access /dashboard
11. ‚úÖ Redirected to /upgrade
12. Attempt to access /calculators
13. ‚úÖ Redirected to /upgrade
14. Create round #1
15. ‚úÖ Verify profile.rounds_used = 1
16. Create rounds #2-25
17. ‚úÖ Verify profile.rounds_used = 25
18. Attempt to create round #26
19. ‚úÖ Error message: "You've reached your free tier limit of 25 rounds"

Expected: All steps complete without errors
```

#### Test Scenario 2: Paid Tier Onboarding
```
Steps:
1. Sign up with new email: user+test2@example.com
2. Verify email and login
3. ‚úÖ Middleware redirects to /onboarding
4. Click "Subscribe" on Premium plan card
5. ‚úÖ Redirected to Stripe Checkout
6. Complete payment with test card: 4242 4242 4242 4242
7. ‚úÖ Redirected to /billing/success
8. ‚úÖ Verify profile.plan_selected = 'premium' in database
9. Access /dashboard
10. ‚úÖ Access granted (no redirect)
11. Access /calculators
12. ‚úÖ Access granted (no redirect)
13. Create 30 rounds
14. ‚úÖ No round limit enforced
15. ‚úÖ Verify profile.rounds_used = 0 (not incremented)

Expected: All steps complete without errors
```

#### Test Scenario 3: Free to Paid Upgrade
```
Steps:
1. Login as free tier user with 20 rounds used
2. ‚úÖ Verify profile.plan_selected = 'free', rounds_used = 20
3. Attempt to access /dashboard
4. ‚úÖ Redirected to /upgrade page
5. Select Premium plan and complete Stripe checkout
6. ‚úÖ Verify profile.plan_selected = 'premium'
7. Access /dashboard
8. ‚úÖ Access granted
9. ‚úÖ Verify profile.rounds_used still = 20 (historical data preserved)
10. Create 10 more rounds
11. ‚úÖ No limit enforced
12. ‚úÖ Verify profile.rounds_used still = 20 (not incremented for paid users)

Expected: Smooth upgrade flow, historical data preserved
```

#### Test Scenario 4: Subscription Cancellation
```
Steps:
1. Login as paid user (Premium or Unlimited)
2. Navigate to /billing
3. Click "Manage Subscription" ‚Üí opens Stripe Customer Portal
4. Cancel subscription
5. ‚úÖ Webhook fires: subscription.deleted
6. ‚úÖ Verify profile.plan_selected = 'free'
7. Navigate to /dashboard
8. ‚úÖ Redirected to /upgrade
9. Create rounds (if under 25)
10. ‚úÖ Round counter increments

Expected: Graceful downgrade to free tier
```

### Edge Case Testing

#### Edge Case 1: User Without Plan Selection
```
- User exists in database
- profile.plan_selected = NULL
- Attempt to access /dashboard
Expected: Redirected to /onboarding
```

#### Edge Case 2: Paid User with Expired Subscription
```
- profile.plan_selected = 'premium'
- Stripe API returns no active subscription
- Attempt to access /dashboard
Expected: Treated as free tier, redirected to /upgrade
```

#### Edge Case 3: Free User with >25 Rounds (Edge Case from Paid Downgrade)
```
- User had Premium, created 50 rounds
- Subscription cancelled, plan_selected = 'free'
- profile.rounds_used = 50
- Attempt to create another round
Expected: Blocked with error message
```

## Performance Considerations

**Current Approach:**
- Middleware calls `getComprehensiveUserAccess()` on every authenticated request
- This queries Supabase profile table + potentially Stripe API
- Acceptable for MVP with moderate traffic

**Potential Bottlenecks:**
1. **Stripe API calls**: Every paid user request queries Stripe subscriptions endpoint
2. **Database queries**: Every request queries profile table

**Future Optimizations (Post-MVP):**
- Add Redis cache for access control results (TTL: 60 seconds)
- Implement local billing table to reduce Stripe API calls
- Use Next.js middleware caching for repeated requests within same session

**Monitoring:**
- Track middleware latency in production
- Set up alerts if p95 latency > 200ms
- Monitor Stripe API rate limits

## Migration Notes

### Existing Users
- All existing users have `plan_selected = NULL`
- On first login post-migration, they'll be redirected to `/onboarding`
- This is intentional - forces plan selection for existing users

### Data Preservation
- All existing rounds are preserved
- Existing `handicapIndex` data untouched
- No data loss during migration

### Rollback Plan
If migration fails or causes issues:
1. Revert database migration:
   ```sql
   ALTER TABLE profile
     DROP COLUMN IF EXISTS rounds_used,
     DROP COLUMN IF EXISTS plan_selected,
     DROP COLUMN IF EXISTS plan_selected_at;
   ```
2. Revert code changes via git
3. Redeploy previous version

## References

- Original ticket: `.claude/tickets/0003-complete-stripe-integration-free-tier-workflow.md`
- Stripe integration: `lib/stripe.ts`
- Access control: `utils/billing/access-control.ts:12-183`
- Middleware: `utils/supabase/middleware.ts:110-146`
- Round creation: `server/api/routers/round.ts:169-187`
- Database schema: `db/schema.ts:26-76`
