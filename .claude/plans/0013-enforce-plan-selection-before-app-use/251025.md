# Enforce Plan Selection Before App Use - Implementation Plan

## Overview

This plan fixes a critical security gap where users can add up to 25 rounds without selecting any plan during onboarding. The bug exists because `subscription_status` defaults to 'active' in the database, and round submission only checks `remainingRounds > 0` instead of the `hasAccess` flag.

**Strategy:** Implement defense-in-depth by fixing the database schema AND adding server-side authorization checks at the tRPC mutation layer.

## Current State Analysis

### The Security Gap (Verified):

1. **Database Schema** (`db/schema.ts:48`):

   - `subscriptionStatus` has `.default("active").notNull()`
   - New users get 'active' status even without selecting a plan

2. **Migration** (`supabase/migrations/20251012205144_quick_morgan_stark.sql:5`):

   - Sets `DEFAULT 'active'` at database level

3. **Access Control Logic** (`utils/billing/access-control.ts:55-56`):

   - `createNoAccessResponse()` correctly returns `hasAccess=false`
   - BUT this flag is never enforced in mutations

4. **Round Submission** (`server/api/routers/round.ts:174-179`):

   - ❌ Only checks `access.plan === "free" && access.remainingRounds <= 0`
   - ❌ Does NOT check `!access.hasAccess`
   - ✅ Has race condition protection (lines 406-435)

5. **Free Plan Selection** (`app/onboarding/actions.ts:22-28`):

   - ❌ Sets `planSelected: "free"` but NOT `subscriptionStatus`
   - Relies on old DEFAULT 'active' behavior

6. **Middleware** (`middleware.ts:248-255`):
   - ✅ Redirects when `!plan` detected
   - ⚠️ Can be bypassed via direct API calls

### What Already Works:

1. **Webhook Handlers** (`app/api/stripe/webhook/route.ts`):

   - ✅ Line 182-186: Lifetime payment sets `subscriptionStatus: 'active'`
   - ✅ Line 238-241: Subscription handlers set `subscriptionStatus` from Stripe
   - ✅ Line 272: Subscription deletion sets `subscriptionStatus: 'canceled'`

2. **Middleware Onboarding Redirect**:
   - ✅ Already redirects users without plan to `/onboarding`
   - Note: This is a UX convenience, not a security boundary

## Desired End State

After this implementation:

1. **New users** have `subscription_status=NULL` (not 'active')
2. **Round submission** checks `hasAccess` flag before `remainingRounds`
3. **Free plan selection** explicitly sets `subscription_status='active'`
4. **Users without plan** cannot submit rounds (clear error message)
5. **Users with plan** (free or paid) can submit rounds normally

### Verification:

```bash
# 1. New user signup flow
- Sign up → profile created with subscription_status=NULL
- Try to submit round → Blocked with redirect to /onboarding
- Select free plan → subscription_status set to 'active'
- Submit round → Success

```

## What We're NOT Doing

- Email reminders for incomplete onboarding
- Analytics/telemetry tracking for onboarding
- Plan comparison UI improvements
- A/B testing different flows
- Additional logging beyond basic console.log statements

## Implementation Approach

**Phase-based approach:** Database schema → tRPC authorization → onboarding flow → verification

This ensures:

1. Database schema allows NULL (Phase 1)
2. Authorization layer enforces hasAccess (Phase 2)
3. Onboarding sets subscription_status (Phase 3)
4. Everything is verified end-to-end (Phase 4)

---

## Phase 1: Fix Database Schema

### Overview

Remove the problematic DEFAULT 'active' constraint and allow NULL values for `subscription_status`. This enables us to distinguish between "no plan selected" (NULL) and "free plan selected" ('active').

### Changes Required:

#### 1. Create New Migration

**File**: `supabase/migrations/20251025HHMMSS_fix_subscription_status_default.sql` (use actual timestamp)

**Changes**: Create migration to remove DEFAULT and allow NULL

```sql
-- Migration: Fix subscription_status default value
-- This fixes a security gap where new users get 'active' status without selecting a plan

-- 1. Remove DEFAULT 'active' constraint
ALTER TABLE profile
ALTER COLUMN subscription_status DROP DEFAULT;

-- 2. Allow NULL values (was NOT NULL before)
ALTER TABLE profile
ALTER COLUMN subscription_status DROP NOT NULL;

-- 3. Add helpful comment
COMMENT ON COLUMN profile.subscription_status IS
  'Subscription status from Stripe. NULL for users who have not selected a plan. Set to ''active'' when user selects free plan or completes payment.';

-- Note: Since we can reset the database locally, we don't need data migration
-- If this were production, we would add:
-- UPDATE profile
-- SET subscription_status = NULL
-- WHERE plan_selected IS NULL;
```

#### 2. Update Drizzle Schema

**File**: `db/schema.ts`
**Lines**: 46-49

**Changes**: Remove default and notNull constraints

```typescript
// BEFORE (lines 46-49):
subscriptionStatus: text("subscription_status")
  .$type<"active" | "trialing" | "past_due" | "canceled" | "paused" | "incomplete" | "incomplete_expired" | "unpaid">()
  .default("active")
  .notNull(),

// AFTER:
subscriptionStatus: text("subscription_status")
  .$type<"active" | "trialing" | "past_due" | "canceled" | "paused" | "incomplete" | "incomplete_expired" | "unpaid" | null>()
  // Removed: .default("active")
  // Removed: .notNull()
  ,
```

**Important**: Add `| null` to the type union to match the new nullable column.

### Success Criteria:

#### Automated Verification:

- [ ] Migration file created with correct timestamp
- [ ] Schema changes compile: `pnpm drizzle-kit generate`
- [ ] No TypeScript errors: `pnpm build`

#### Manual Verification:

- [ ] Reset database: `supabase db reset`
- [ ] Check schema in database:

```sql
\d+ profile
-- subscription_status should show:
--   Type: text
--   Nullable: yes
--   Default: (none)
```

- [ ] Create test user, verify `subscription_status IS NULL`

---

## Phase 2: Add hasAccess Authorization Check

### Overview

Add server-side authorization check to round submission that validates `hasAccess` flag BEFORE checking `remainingRounds`. This is the critical security fix that prevents unauthorized round submissions.

### Changes Required:

#### 1. Update Round Submission Guard

**File**: `server/api/routers/round.ts`
**Lines**: 171-180

**Changes**: Add hasAccess check before remainingRounds check

```typescript
// BEFORE (lines 171-179):
// 0. Check round limit for free tier users
const access = await getComprehensiveUserAccess(userId);

if (access.plan === "free" && access.remainingRounds <= 0) {
  throw new TRPCError({
    code: "FORBIDDEN",
    message: `You've reached your free tier limit of ${FREE_TIER_ROUND_LIMIT} rounds. You have ${access.remainingRounds} rounds remaining. Please upgrade to continue tracking rounds.`,
  });
}

console.log(
  "✅ Round limit check passed. Remaining rounds:",
  access.remainingRounds
);

// AFTER:
// 0. Check user access (plan selected)
const access = await getComprehensiveUserAccess(userId);

// 0a. First check: Has user selected a plan?
if (!access.hasAccess) {
  throw new TRPCError({
    code: "FORBIDDEN",
    message:
      "Please select a plan to continue. Visit the onboarding page to get started.",
  });
}

// 0b. Second check: Free tier round limit
if (access.plan === "free" && access.remainingRounds <= 0) {
  throw new TRPCError({
    code: "FORBIDDEN",
    message: `You've reached your free tier limit of ${FREE_TIER_ROUND_LIMIT} rounds. Please upgrade to continue tracking rounds.`,
  });
}

console.log("✅ Access checks passed", {
  plan: access.plan,
  hasAccess: access.hasAccess,
  remainingRounds: access.remainingRounds,
});
```

**Key Changes:**

1. Add `hasAccess` check as **first guard** (line ~173)
2. Check `remainingRounds` only **after** `hasAccess` passes (line ~179)
3. Update console.log to show all access flags (line ~187)

**Why This Order Matters:**

- `hasAccess=false` → No plan selected → Redirect to onboarding
- `hasAccess=true, remainingRounds=0` → Free tier limit → Upgrade prompt
- Both checks needed for complete coverage

### Success Criteria:

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Create new user (no plan selected)
- [ ] Attempt round submission → Blocked with "Please select a plan to continue" error
- [ ] Select free plan
- [ ] Submit round → Success
- [ ] Submit 25 rounds total → Success
- [ ] Attempt 26th round → Blocked with "free tier limit" error

---

## Phase 3: Update Free Plan Selection

### Overview

When users select the free plan during onboarding, explicitly set `subscription_status='active'`. This completes the onboarding flow and grants access to the application.

### Changes Required:

#### 1. Update createFreeTierSubscription Action

**File**: `app/onboarding/actions.ts`
**Lines**: 22-28

**Changes**: Add subscriptionStatus to the update

```typescript
// BEFORE (lines 22-28):
await db
  .update(profile)
  .set({
    planSelected: "free",
    planSelectedAt: new Date(),
  })
  .where(eq(profile.id, userId));

// AFTER:
await db
  .update(profile)
  .set({
    planSelected: "free",
    planSelectedAt: new Date(),
    subscriptionStatus: "active", // NEW: Explicitly set status
  })
  .where(eq(profile.id, userId));
```

**Why This Matters:**

- Before: Relied on DEFAULT 'active' (which we removed)
- After: Explicitly sets status, matching webhook behavior
- Consistent with paid plan activation logic

### Success Criteria:

#### Automated Verification:

- [ ] TypeScript compiles: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:

- [ ] Create new user, verify initial state:

```sql
SELECT id, plan_selected, subscription_status FROM profile WHERE id = '<user_id>';
-- Expected: plan_selected=NULL, subscription_status=NULL
```

- [ ] Complete onboarding, select free plan
- [ ] Verify final state:

```sql
SELECT id, plan_selected, subscription_status FROM profile WHERE id = '<user_id>';
-- Expected: plan_selected='free', subscription_status='active'
```

- [ ] Submit round → Success

---

## Phase 4: End-to-End Testing

### Overview

Comprehensive manual testing to verify all flows work correctly with the new authorization logic.

### Testing Strategy

Test all three user journeys:

1. New user (no plan)
2. Free tier user (at limit)
3. Paid user

### Test Cases:

#### Test 1: New User Flow (No Plan Selected)

**Setup:**

```bash
# Reset database
supabase db reset

# Sign up new user via UI or:
# POST /api/auth/signup
```

**Steps:**

1. Sign up new user
2. Check database state:

```sql
SELECT id, email, plan_selected, subscription_status
FROM profile
WHERE email = 'test@example.com';
-- Expected: plan_selected=NULL, subscription_status=NULL
```

3. Attempt to submit round via UI or tRPC
4. **Expected:** Error "Please select a plan to continue. Visit the onboarding page to get started."
5. Navigate to `/onboarding`
6. **Expected:** Plan selection UI shown
7. Select "Free Plan"
8. Check database state:

```sql
SELECT id, email, plan_selected, subscription_status
FROM profile
WHERE email = 'test@example.com';
-- Expected: plan_selected='free', subscription_status='active'
```

9. Submit round
10. **Expected:** Success

#### Test 2: Free Tier User (Limit Testing)

**Setup:** User with free plan selected

**Steps:**

1. Submit 24 rounds
2. **Expected:** All succeed
3. Submit 25th round
4. **Expected:** Success
5. Attempt 26th round
6. **Expected:** Error "You've reached your free tier limit of 25 rounds"
7. Verify middleware redirect on `/rounds/add`:
   - Navigate to `/rounds/add`
   - **Expected:** Redirected to `/upgrade?reason=round_limit`

#### Test 3: Paid User Flow (Lifetime)

**Setup:** Complete Stripe checkout for lifetime plan

**Steps:**

1. Create Stripe checkout session for lifetime plan
2. Complete payment in Stripe test mode
3. Verify webhook processed:

```sql
SELECT id, plan_selected, subscription_status
FROM profile
WHERE email = 'paid@example.com';
-- Expected: plan_selected='lifetime', subscription_status='active'
```

4. Submit round
5. **Expected:** Success immediately
6. Submit 100+ rounds
7. **Expected:** All succeed (unlimited)

#### Test 4: Edge Cases

**Concurrent Submissions (Race Condition):**

1. Free tier user at 24 rounds
2. Submit 2 rounds simultaneously via API
3. **Expected:** One succeeds, one blocked with race condition error
4. Verify database has exactly 25 rounds (not 26)

**Middleware Bypass Attempt:**

1. New user (no plan)
2. Disable JavaScript in browser
3. Attempt direct POST to `/api/trpc/round.submitScorecard`
4. **Expected:** Blocked with "Please select a plan to continue"

**JWT Staleness:**

1. User selects free plan
2. Wait for JWT to refresh (or manually refresh)
3. Submit round
4. **Expected:** Success (JWT updated with new billing claims)

### Success Criteria:

#### Automated Verification:

- [ ] All unit tests pass: `pnpm test` (if any exist)
- [ ] Build succeeds: `pnpm build`
- [ ] Linting passes: `pnpm lint`

#### Manual Verification:

- [ ] Test 1: New user flow passes
- [ ] Test 2: Free tier limit enforced
- [ ] Test 3: Paid user has unlimited access
- [ ] Test 4: All edge cases handled correctly
- [ ] No console errors in browser
- [ ] Error messages are user-friendly
- [ ] Database state is correct after each test

---

## Performance Considerations

### Middleware Performance

Current middleware uses JWT claims for plan checking:

- **JWT path:** ~1-10ms (no database query)
- **Fallback path:** ~50-100ms (queries database)

**No changes needed** - middleware already optimized.

### tRPC Authorization Check

The `getComprehensiveUserAccess()` function:

- Queries `profile` table (indexed on `id`)
- For free users: Counts rounds (indexed on `userId`)
- **Performance:** ~10-50ms (acceptable for mutations)

**No optimization needed** - this is a security check that must be accurate.

## Migration Notes

### Database Reset Approach

Since this is a local development environment:

```bash
# Apply new migration
supabase db reset

# Regenerate Drizzle types
pnpm drizzle-kit generate
pnpm drizzle-kit push
```

### Production Migration (Future Reference)

If deploying to production with existing users:

```sql
-- In migration file, add data migration:
UPDATE profile
SET subscription_status = CASE
  WHEN plan_selected IS NULL THEN NULL
  WHEN plan_selected = 'free' THEN 'active'
  WHEN plan_selected IN ('premium', 'unlimited', 'lifetime') THEN 'active'
  ELSE 'active'
END;
```

## Integration Points

### Systems That Read subscription_status:

1. **JWT Custom Access Token Hook** (`supabase/migrations/20251012223407_add_billing_jwt_hook.sql`):

   - Reads `subscription_status` from profile
   - Includes in JWT claims for middleware
   - **Action Required:** Verify hook handles NULL values gracefully

2. **Middleware** (`middleware.ts:135-219`):

   - Reads `billing.status` from JWT claims
   - Handles edge cases (expired, canceled, etc.)
   - **No changes needed** - already handles NULL plan

3. **Access Control** (`utils/billing/access-control.ts`):
   - `getComprehensiveUserAccess()` - Primary function
   - `createNoAccessResponse()` - Returns `hasAccess=false`
   - **No changes needed** - logic already correct

### Systems That Write subscription_status:

1. **Onboarding** (`app/onboarding/actions.ts`):

   - ✅ Updated in Phase 3 to set 'active'

2. **Stripe Webhooks** (`app/api/stripe/webhook/route.ts`):
   - ✅ Already sets subscription_status correctly
   - Line 182: Lifetime → 'active'
   - Line 238: Subscription → status from Stripe
   - Line 272: Deletion → 'canceled'

## References

- Original ticket: `.claude/tickets/0013-enforce-plan-selection-before-app-use.md`
- Related migration: `supabase/migrations/20251012205144_quick_morgan_stark.sql`
- Billing constants: `utils/billing/constants.ts`
- Access control logic: `utils/billing/access-control.ts`

## Implementation Checklist

- [ ] Phase 1: Create migration and update schema
- [ ] Phase 1: Verify database allows NULL
- [ ] Phase 2: Add hasAccess check to round submission
- [ ] Phase 2: Verify new users blocked from round submission
- [ ] Phase 3: Update free plan selection to set subscription_status
- [ ] Phase 3: Verify free plan grants access
- [ ] Phase 4: Run all manual test cases
- [ ] Phase 4: Verify edge cases handled
- [ ] Final: No TypeScript errors
- [ ] Final: No linting errors
- [ ] Final: All console.log statements working as expected
