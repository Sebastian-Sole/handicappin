# Stripe Subscription System Implementation Plan

## Overview

Implement a freemium subscription system using Stripe payment links with tiered subscriptions (Base, Premium, Unlimited, and Lifetime). The system includes round limit tracking, early adopter rewards, and infrastructure for future premium feature gating.

## Current State Analysis

### Existing Infrastructure

- **Database**: PostgreSQL via Supabase with Drizzle ORM
- **API Layer**: tRPC for type-safe endpoints (`server/api/routers/`)
- **Authentication**: Supabase auth with user context in tRPC
- **Profile Schema**: Basic fields (id, email, name, handicapIndex, verified, createdAt) - `db/schema.ts:26-76`
- **Round Creation**: `submitScorecard` mutation at `server/api/routers/round.ts:151-389` (no limit checks)
- **Environment Config**: `@t3-oss/env-nextjs` with Zod validation - `env.js:1-52`
- **Landing Page**: `components/homepage/landing.tsx` (already mentions first 100 users)
- **User Signup**: Supabase Edge Function `create-profile` at `supabase/functions/create-profile/index.ts`

### Key Discoveries

- No subscription fields in profile table
- No round counting or limit enforcement
- No payment processing infrastructure
- tRPC uses `authedProcedure` middleware for auth checks
- Existing users count: Will be fetched to determine early adopters
- Deployment: Vercel (webhook endpoint needs to be publicly accessible)

## Desired End State

### Database Schema

Profile table will have:

- Subscription tier and status tracking
- Stripe customer/subscription IDs
- Round usage counter (base tier only)
- Early adopter flag

### Payment Flow

1. User clicks upgrade link on landing page
2. Redirected to Stripe payment link
3. Completes payment
4. Stripe webhook updates database
5. User has new tier permissions

### Access Control

- Base tier: Limited to 25 rounds, basic features
- Premium tier: Unlimited rounds, basic features
- Unlimited tier: Unlimited rounds + premium features (future)
- Early adopters: Free Premium tier forever

### Round Limit Enforcement

- Middleware blocks `/rounds/add` for base tier users at limit
- Server-side validation in `submitScorecard` mutation
- Dashboard shows remaining rounds for base tier

## What We're NOT Doing

- Referral system (future ticket)
- Round pack microtransactions (future ticket)
- Admin promotional tools (future ticket)
- Custom checkout UI (using Stripe Payment Links)
- Implementing actual premium features (just infrastructure)
- Email marketing automation
- Gift subscriptions
- Multi-currency support
- Pro-rated upgrades
- Discount code system (beyond early adopter)

## Implementation Approach

Use Stripe Payment Links for simplicity and security. Webhooks handle all subscription state changes. Early adopters are automatically assigned at signup based on user count. Round limits are enforced via middleware and server-side validation.

---

## Phase 1: Database Schema & Migration

### Overview

Add subscription fields to profile table, create migration, update Drizzle schema and TypeScript types.

### Changes Required

#### 1. Create Drizzle Migration

**File**: `supabase/migrations/20251002000000_add_subscription_fields.sql`
**Changes**: Create new migration file

```sql
-- Add subscription fields to profile table
ALTER TABLE "profile" ADD COLUMN "subscription_tier" text DEFAULT 'base' NOT NULL;
ALTER TABLE "profile" ADD COLUMN "subscription_status" text DEFAULT 'active' NOT NULL;
ALTER TABLE "profile" ADD COLUMN "subscription_type" text DEFAULT 'recurring' NOT NULL;
ALTER TABLE "profile" ADD COLUMN "stripe_customer_id" text;
ALTER TABLE "profile" ADD COLUMN "stripe_subscription_id" text;
ALTER TABLE "profile" ADD COLUMN "subscription_started_at" timestamp;
ALTER TABLE "profile" ADD COLUMN "subscription_expires_at" timestamp;
ALTER TABLE "profile" ADD COLUMN "is_early_adopter" boolean DEFAULT false NOT NULL;
ALTER TABLE "profile" ADD COLUMN "rounds_used" integer DEFAULT 0 NOT NULL;
ALTER TABLE "profile" ADD COLUMN "updated_at" timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS "profile_stripe_customer_id_idx" ON "profile" ("stripe_customer_id");
CREATE INDEX IF NOT EXISTS "profile_subscription_tier_idx" ON "profile" ("subscription_tier");
CREATE INDEX IF NOT EXISTS "profile_is_early_adopter_idx" ON "profile" ("is_early_adopter");

-- Backfill existing users as early adopters (if â‰¤ 100 users exist)
DO $$
DECLARE
  user_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO user_count FROM profile;

  IF user_count <= 100 THEN
    UPDATE profile
    SET
      is_early_adopter = true,
      subscription_tier = 'premium',
      subscription_type = 'promo',
      subscription_started_at = created_at,
      updated_at = CURRENT_TIMESTAMP
    WHERE is_early_adopter = false;
  END IF;
END $$;

-- Add constraint to ensure valid tier values
ALTER TABLE "profile" ADD CONSTRAINT "profile_subscription_tier_check"
  CHECK (subscription_tier IN ('base', 'premium', 'unlimited'));

-- Add constraint to ensure valid status values
ALTER TABLE "profile" ADD CONSTRAINT "profile_subscription_status_check"
  CHECK (subscription_status IN ('active', 'cancelled', 'expired', 'trialing'));

-- Add constraint to ensure valid type values
ALTER TABLE "profile" ADD CONSTRAINT "profile_subscription_type_check"
  CHECK (subscription_type IN ('recurring', 'lifetime', 'promo'));
```

#### 2. Update Drizzle Schema

**File**: `db/schema.ts`
**Changes**: Add subscription fields to profile table definition

```typescript
// Update the profile table (lines 26-76)
export const profile = pgTable(
  "profile",
  {
    id: uuid().primaryKey().notNull(),
    email: text().notNull(),
    name: text(),
    handicapIndex: decimal<"number">().notNull().default(54),
    verified: boolean().default(false).notNull(),
    initialHandicapIndex: decimal<"number">().notNull().default(54),
    createdAt: timestamp()
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),

    // Subscription fields
    subscriptionTier: text("subscription_tier")
      .notNull()
      .default("base")
      .$type<"base" | "premium" | "unlimited">(),
    subscriptionStatus: text("subscription_status")
      .notNull()
      .default("active")
      .$type<"active" | "cancelled" | "expired" | "trialing">(),
    subscriptionType: text("subscription_type")
      .notNull()
      .default("recurring")
      .$type<"recurring" | "lifetime" | "promo">(),
    stripeCustomerId: text("stripe_customer_id"),
    stripeSubscriptionId: text("stripe_subscription_id"),
    subscriptionStartedAt: timestamp("subscription_started_at"),
    subscriptionExpiresAt: timestamp("subscription_expires_at"),
    isEarlyAdopter: boolean("is_early_adopter").default(false).notNull(),
    roundsUsed: integer("rounds_used").default(0).notNull(),
    updatedAt: timestamp("updated_at")
      .default(sql`CURRENT_TIMESTAMP`)
      .notNull(),
  },
  (table) => [
    uniqueIndex("profile_email_key").using(
      "btree",
      table.email.asc().nullsLast().op("text_ops")
    ),
    foreignKey({
      columns: [table.id],
      foreignColumns: [usersInAuth.id],
      name: "profile_id_fkey",
    })
      .onUpdate("cascade")
      .onDelete("cascade"),
    pgPolicy("Users can view their own profile", {
      as: "permissive",
      for: "select",
      to: ["authenticated"],
      using: sql`(auth.uid()::uuid = id)`,
    }),
    pgPolicy("Users can update their own profile", {
      as: "permissive",
      for: "update",
      to: ["authenticated"],
      using: sql`(auth.uid()::uuid = id)`,
    }),
    pgPolicy("Users can insert their own profile", {
      as: "permissive",
      for: "insert",
      to: ["authenticated"],
      withCheck: sql`(auth.uid()::uuid = id)`,
    }),
    pgPolicy("Users can delete their own profile", {
      as: "permissive",
      for: "delete",
      to: ["authenticated"],
      using: sql`(auth.uid()::uuid = id)`,
    }),
  ]
);
```

#### 3. Update Supabase Types

**File**: `types/supabase.ts`
**Changes**: Update Profile type definition to include new fields

```typescript
// Update the profile Row/Insert/Update types (around lines 79-107)
profile: {
  Row: {
    createdAt: string
    email: string
    handicapIndex: number
    id: string
    initialHandicapIndex: number
    name: string | null
    verified: boolean
    // Subscription fields
    subscription_tier: 'base' | 'premium' | 'unlimited'
    subscription_status: 'active' | 'cancelled' | 'expired' | 'trialing'
    subscription_type: 'recurring' | 'lifetime' | 'promo'
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    subscription_started_at: string | null
    subscription_expires_at: string | null
    is_early_adopter: boolean
    rounds_used: number
    updated_at: string
  }
  Insert: {
    createdAt?: string
    email: string
    handicapIndex?: number
    id: string
    initialHandicapIndex?: number
    name?: string | null
    verified?: boolean
    // Subscription fields
    subscription_tier?: 'base' | 'premium' | 'unlimited'
    subscription_status?: 'active' | 'cancelled' | 'expired' | 'trialing'
    subscription_type?: 'recurring' | 'lifetime' | 'promo'
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    subscription_started_at?: string | null
    subscription_expires_at?: string | null
    is_early_adopter?: boolean
    rounds_used?: number
    updated_at?: string
  }
  Update: {
    createdAt?: string
    email?: string
    handicapIndex?: number
    id?: string
    initialHandicapIndex?: number
    name?: string | null
    verified?: boolean
    // Subscription fields
    subscription_tier?: 'base' | 'premium' | 'unlimited'
    subscription_status?: 'active' | 'cancelled' | 'expired' | 'trialing'
    subscription_type?: 'recurring' | 'lifetime' | 'promo'
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    subscription_started_at?: string | null
    subscription_expires_at?: string | null
    is_early_adopter?: boolean
    rounds_used?: number
    updated_at?: string
  }
  Relationships: []
}
```

### Success Criteria

#### Automated Verification

- [ ] Migration runs successfully: `supabase db push`
- [ ] Drizzle schema generates without errors: `pnpm db:generate`
- [ ] TypeScript compilation passes: `pnpm build`
- [ ] No type errors in profile-related code

#### Manual Verification

- [ ] Migration adds all 10 new columns to profile table
- [ ] Indexes are created on stripe_customer_id, subscription_tier, is_early_adopter
- [ ] Existing users (if â‰¤ 100) are marked as early adopters with premium tier
- [ ] Check constraints enforce valid enum values
- [ ] Profile type exports include all new subscription fields

---

## Phase 2: Stripe Integration & Webhook Handler

### Overview

Set up Stripe SDK, create webhook endpoint to process subscription events, add environment variables.

### Changes Required

#### 1. Install Stripe SDK

**Command**:

```bash
pnpm add stripe
pnpm add -D @types/stripe
```

#### 2. Add Environment Variables

**File**: `env.js`
**Changes**: Add Stripe configuration to server and client schemas

```typescript
export const env = createEnv({
  server: {
    DATABASE_URL: z.string().url(),
    DIRECT_URL: z.string().url(),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),
    // Stripe server keys
    STRIPE_SECRET_KEY: z.string().min(1),
    STRIPE_WEBHOOK_SECRET: z.string().min(1),
    STRIPE_PREMIUM_PRICE_ID: z.string().min(1),
    STRIPE_UNLIMITED_PRICE_ID: z.string().min(1),
    STRIPE_UNLIMITED_LIFETIME_PRICE_ID: z.string().min(1),
  },

  client: {
    NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
    NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string(),
    NEXT_PUBLIC_BASE_URL: z.string().url().optional(),
    // Stripe client keys
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().min(1),
    NEXT_PUBLIC_STRIPE_PREMIUM_LINK: z.string().url(),
    NEXT_PUBLIC_STRIPE_UNLIMITED_LINK: z.string().url(),
    NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK: z.string().url(),
  },

  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    DIRECT_URL: process.env.DIRECT_URL,
    NODE_ENV: process.env.NODE_ENV,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
    NEXT_PUBLIC_BASE_URL: process.env.NEXT_PUBLIC_BASE_URL,
    // Stripe runtime env
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
    STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
    STRIPE_PREMIUM_PRICE_ID: process.env.STRIPE_PREMIUM_PRICE_ID,
    STRIPE_UNLIMITED_PRICE_ID: process.env.STRIPE_UNLIMITED_PRICE_ID,
    STRIPE_UNLIMITED_LIFETIME_PRICE_ID:
      process.env.STRIPE_UNLIMITED_LIFETIME_PRICE_ID,
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:
      process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,
    NEXT_PUBLIC_STRIPE_PREMIUM_LINK:
      process.env.NEXT_PUBLIC_STRIPE_PREMIUM_LINK,
    NEXT_PUBLIC_STRIPE_UNLIMITED_LINK:
      process.env.NEXT_PUBLIC_STRIPE_UNLIMITED_LINK,
    NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK:
      process.env.NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK,
  },
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  emptyStringAsUndefined: true,
});
```

**File**: `.env.local` (create/update)
**Changes**: Add Stripe test keys (example values, replace with actual)

```bash
# Stripe Configuration (Test Mode)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PREMIUM_PRICE_ID=price_...
STRIPE_UNLIMITED_PRICE_ID=price_...
STRIPE_UNLIMITED_LIFETIME_PRICE_ID=price_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
NEXT_PUBLIC_STRIPE_PREMIUM_LINK=https://buy.stripe.com/test_...
NEXT_PUBLIC_STRIPE_UNLIMITED_LINK=https://buy.stripe.com/test_...
NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK=https://buy.stripe.com/test_...
```

#### 3. Create Stripe Client Library

**File**: `lib/stripe.ts` (new file)
**Changes**: Initialize Stripe client and define subscription plans

```typescript
import Stripe from "stripe";
import { env } from "@/env";

export const stripe = new Stripe(env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-10-28.acacia",
  typescript: true,
});

export const STRIPE_PLANS = {
  PREMIUM: {
    priceId: env.STRIPE_PREMIUM_PRICE_ID,
    name: "Premium",
    price: 19,
    interval: "year" as const,
    tier: "premium" as const,
  },
  UNLIMITED: {
    priceId: env.STRIPE_UNLIMITED_PRICE_ID,
    name: "Unlimited",
    price: 29,
    interval: "year" as const,
    tier: "unlimited" as const,
  },
  UNLIMITED_LIFETIME: {
    priceId: env.STRIPE_UNLIMITED_LIFETIME_PRICE_ID,
    name: "Unlimited Lifetime",
    price: 149,
    interval: "lifetime" as const,
    tier: "unlimited" as const,
  },
} as const;

export function getPlanByPriceId(priceId: string) {
  return Object.values(STRIPE_PLANS).find((plan) => plan.priceId === priceId);
}
```

#### 4. Create Webhook Handler

**File**: `app/api/stripe/webhook/route.ts` (new file)
**Changes**: Handle Stripe webhook events

```typescript
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import Stripe from "stripe";
import { stripe, getPlanByPriceId } from "@/lib/stripe";
import { env } from "@/env";
import { createClient } from "@supabase/supabase-js";

// Disable body parsing, need raw body for webhook signature verification
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

// Create Supabase client with service role for admin access
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function updateUserSubscription(
  customerId: string,
  data: {
    subscriptionTier?: "base" | "premium" | "unlimited";
    subscriptionStatus?: "active" | "cancelled" | "expired" | "trialing";
    subscriptionType?: "recurring" | "lifetime";
    stripeSubscriptionId?: string;
    subscriptionStartedAt?: Date;
    subscriptionExpiresAt?: Date | null;
  }
) {
  // Find user by stripe_customer_id
  const { data: profile, error: findError } = await supabaseAdmin
    .from("profile")
    .select("*")
    .eq("stripe_customer_id", customerId)
    .single();

  if (findError || !profile) {
    console.error("User not found for Stripe customer:", customerId);
    throw new Error("User not found");
  }

  // Update subscription fields
  const { error: updateError } = await supabaseAdmin
    .from("profile")
    .update({
      subscription_tier: data.subscriptionTier,
      subscription_status: data.subscriptionStatus,
      subscription_type: data.subscriptionType,
      stripe_subscription_id: data.stripeSubscriptionId,
      subscription_started_at: data.subscriptionStartedAt?.toISOString(),
      subscription_expires_at:
        data.subscriptionExpiresAt?.toISOString() || null,
      updated_at: new Date().toISOString(),
    })
    .eq("stripe_customer_id", customerId);

  if (updateError) {
    console.error("Failed to update user subscription:", updateError);
    throw updateError;
  }

  console.log("Successfully updated subscription for customer:", customerId);
}

export async function POST(req: Request) {
  const body = await req.text();
  const signature = headers().get("stripe-signature");

  if (!signature) {
    return NextResponse.json(
      { error: "No signature provided" },
      { status: 400 }
    );
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error("Webhook signature verification failed:", err);
    return NextResponse.json(
      { error: "Webhook signature verification failed" },
      { status: 400 }
    );
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as Stripe.Checkout.Session;
        const customerId = session.customer as string;
        const subscriptionId = session.subscription as string | null;

        if (session.mode === "subscription") {
          // Recurring subscription (Premium or Unlimited)
          const subscription = await stripe.subscriptions.retrieve(
            subscriptionId!
          );
          const priceId = subscription.items.data[0].price.id;
          const plan = getPlanByPriceId(priceId);

          if (!plan) {
            console.error("Unknown price ID:", priceId);
            break;
          }

          await updateUserSubscription(customerId, {
            subscriptionTier: plan.tier,
            subscriptionStatus: "active",
            subscriptionType: "recurring",
            stripeSubscriptionId: subscriptionId!,
            subscriptionStartedAt: new Date(
              subscription.current_period_start * 1000
            ),
            subscriptionExpiresAt: new Date(
              subscription.current_period_end * 1000
            ),
          });
        } else if (session.mode === "payment") {
          // One-time payment (Lifetime)
          const lineItems = await stripe.checkout.sessions.listLineItems(
            session.id
          );
          const priceId = lineItems.data[0].price?.id;
          const plan = getPlanByPriceId(priceId!);

          if (!plan || plan.interval !== "lifetime") {
            console.error("Unknown lifetime price ID:", priceId);
            break;
          }

          await updateUserSubscription(customerId, {
            subscriptionTier: "unlimited",
            subscriptionStatus: "active",
            subscriptionType: "lifetime",
            subscriptionStartedAt: new Date(),
            subscriptionExpiresAt: null, // Lifetime never expires
          });
        }
        break;
      }

      case "customer.subscription.updated": {
        const subscription = event.data.object as Stripe.Subscription;
        const customerId = subscription.customer as string;
        const priceId = subscription.items.data[0].price.id;
        const plan = getPlanByPriceId(priceId);

        if (!plan) {
          console.error("Unknown price ID:", priceId);
          break;
        }

        let status: "active" | "cancelled" | "expired" | "trialing" = "active";
        if (subscription.status === "trialing") status = "trialing";
        else if (
          subscription.status === "canceled" ||
          subscription.cancel_at_period_end
        ) {
          status = "cancelled";
        }

        await updateUserSubscription(customerId, {
          subscriptionTier: plan.tier,
          subscriptionStatus: status,
          subscriptionType: "recurring",
          stripeSubscriptionId: subscription.id,
          subscriptionStartedAt: new Date(
            subscription.current_period_start * 1000
          ),
          subscriptionExpiresAt: new Date(
            subscription.current_period_end * 1000
          ),
        });
        break;
      }

      case "customer.subscription.deleted": {
        const subscription = event.data.object as Stripe.Subscription;
        const customerId = subscription.customer as string;

        await updateUserSubscription(customerId, {
          subscriptionTier: "base",
          subscriptionStatus: "expired",
          subscriptionType: "recurring",
          subscriptionExpiresAt: new Date(),
        });
        break;
      }

      case "invoice.payment_failed": {
        const invoice = event.data.object as Stripe.Invoice;
        const customerId = invoice.customer as string;

        // Mark as cancelled, they'll be downgraded at period end
        await updateUserSubscription(customerId, {
          subscriptionStatus: "cancelled",
        });
        break;
      }

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("Error processing webhook:", error);
    return NextResponse.json(
      { error: "Webhook processing failed" },
      { status: 500 }
    );
  }
}
```

#### 5. Configure Next.js for Webhook Raw Body

**File**: `next.config.mjs`
**Changes**: Add API route configuration for webhook (if needed)

Note: Next.js 13+ App Router handles this automatically via the route handler. No additional config needed.

### Success Criteria

#### Automated Verification

- [ ] Stripe SDK installs successfully: `pnpm install`
- [ ] Environment variables validate: `pnpm build`
- [ ] TypeScript compilation passes with Stripe types
- [ ] Webhook endpoint builds without errors

#### Manual Verification

- [ ] Stripe test products created (Premium, Unlimited, Lifetime)
- [ ] Payment links generated and added to .env
- [ ] Webhook endpoint deployed and accessible
- [ ] Stripe webhook configured to point to `/api/stripe/webhook`
- [ ] Test webhook with Stripe CLI: `stripe trigger checkout.session.completed`
- [ ] Webhook signature verification works
- [ ] Subscription updates reflected in database after test payment

---

## Phase 3: Access Control & Round Limits

### Overview

Implement round limit checking, middleware to block access, subscription utilities, and update round creation logic.

### Changes Required

#### 1. Create Subscription Utility Functions

**File**: `lib/subscription.ts` (new file)
**Changes**: Create utilities for checking subscription tiers and features

```typescript
import { Profile } from "@/db/schema";

export type SubscriptionTier = "base" | "premium" | "unlimited";
export type SubscriptionFeature =
  | "unlimited_rounds"
  | "round_insights"
  | "performance_analytics"
  | "trend_charts"
  | "advanced_calculators"
  | "priority_support"
  | "early_feature_access";

export const ROUND_LIMITS = {
  base: 25,
  premium: Infinity,
  unlimited: Infinity,
} as const;

export const TIER_FEATURES: Record<SubscriptionTier, SubscriptionFeature[]> = {
  base: [],
  premium: ["unlimited_rounds"],
  unlimited: [
    "unlimited_rounds",
    "round_insights",
    "performance_analytics",
    "trend_charts",
    "advanced_calculators",
    "priority_support",
    "early_feature_access",
  ],
};

export function canAddRound(
  profile: Pick<Profile, "subscriptionTier" | "roundsUsed" | "isEarlyAdopter">
): boolean {
  // Early adopters have unlimited rounds (premium tier)
  if (profile.isEarlyAdopter) return true;

  // Premium and unlimited tiers have unlimited rounds
  if (
    profile.subscriptionTier === "premium" ||
    profile.subscriptionTier === "unlimited"
  ) {
    return true;
  }

  // Base tier has 25 round limit
  return profile.roundsUsed < ROUND_LIMITS.base;
}

export function getRemainingRounds(
  profile: Pick<Profile, "subscriptionTier" | "roundsUsed" | "isEarlyAdopter">
): number | null {
  // Return null for unlimited tiers (don't show counter)
  if (
    profile.isEarlyAdopter ||
    profile.subscriptionTier === "premium" ||
    profile.subscriptionTier === "unlimited"
  ) {
    return null;
  }

  // Base tier: return remaining rounds
  return Math.max(0, ROUND_LIMITS.base - profile.roundsUsed);
}

export function canAccessFeature(
  profile: Pick<Profile, "subscriptionTier" | "isEarlyAdopter">,
  feature: SubscriptionFeature
): boolean {
  const tier = profile.subscriptionTier;
  return TIER_FEATURES[tier].includes(feature);
}

export function getUpgradeRecommendation(
  profile: Pick<Profile, "subscriptionTier">
): SubscriptionTier | null {
  if (profile.subscriptionTier === "base") return "unlimited";
  if (profile.subscriptionTier === "premium") return "unlimited";
  return null; // Already on highest tier
}
```

#### 2. Update Middleware for Round Limit Blocking

**File**: `middleware.ts`
**Changes**: Add round limit check and redirect logic

```typescript
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import { canAddRound } from "@/lib/subscription";

export async function middleware(request: NextRequest) {
  // Only check for /rounds/add route
  if (request.nextUrl.pathname === "/rounds/add") {
    const supabase = await createServerComponentClient();

    // Get authenticated user
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      // Not authenticated, redirect to login
      return NextResponse.redirect(new URL("/login", request.url));
    }

    // Get user profile with subscription info
    const { data: profile, error } = await supabase
      .from("profile")
      .select("subscription_tier, rounds_used, is_early_adopter")
      .eq("id", user.id)
      .single();

    if (error || !profile) {
      console.error("Failed to fetch profile in middleware:", error);
      return NextResponse.next();
    }

    // Check if user can add rounds
    if (!canAddRound(profile)) {
      // Redirect to upgrade page with reason
      const url = new URL("/upgrade", request.url);
      url.searchParams.set("reason", "round_limit_reached");
      return NextResponse.redirect(url);
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/rounds/add"],
};
```

#### 3. Update Round Creation Logic

**File**: `server/api/routers/round.ts`
**Changes**: Add round limit check and increment counter

```typescript
// At the top of the file, add import
import { canAddRound } from "@/lib/subscription";

// In submitScorecard mutation (around line 153), add this check after getting user profile:

export const roundRouter = createTRPCRouter({
  // ... existing routes ...

  submitScorecard: authedProcedure
    .input(scorecardSchema)
    .mutation(async ({ ctx, input }) => {
      const {
        teePlayed,
        scores,
        notes,
        approvalStatus,
        course: coursePlayed,
        teeTime,
        userId,
      } = input;

      if (!teePlayed.holes) {
        throw new Error("Tee played has no holes");
      }

      // 1. Get user profile for handicap calculations AND subscription check
      const userProfile = await db
        .select()
        .from(profile)
        .where(eq(profile.id, userId))
        .limit(1);

      if (!userProfile[0]) {
        throw new Error("User profile not found");
      }

      // NEW: Check round limit before allowing round creation
      if (!canAddRound(userProfile[0])) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message:
            "Round limit reached. Please upgrade your subscription to add more rounds.",
        });
      }

      // ... rest of existing round creation logic ...

      // 5. Insert round (around line 347)
      const [newRound] = await db.insert(round).values(roundInsert).returning();

      if (!newRound) {
        throw new Error("Failed to insert round");
      }

      // NEW: Increment rounds_used for base tier users only
      if (
        userProfile[0].subscriptionTier === "base" &&
        !userProfile[0].isEarlyAdopter
      ) {
        await db
          .update(profile)
          .set({
            roundsUsed: userProfile[0].roundsUsed + 1,
            updatedAt: new Date(),
          })
          .where(eq(profile.id, userId));
      }

      // ... rest of score insertion logic ...

      return newRound;
    }),
});
```

#### 4. Create Upgrade Page

**File**: `app/upgrade/page.tsx` (new file)
**Changes**: Create upgrade/pricing page

```typescript
import { Suspense } from "react";
import { redirect } from "next/navigation";
import { createServerComponentClient } from "@/utils/supabase/server";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { CheckCircle, XCircle } from "lucide-react";
import Link from "next/link";
import { env } from "@/env";

export default async function UpgradePage({
  searchParams,
}: {
  searchParams: { reason?: string };
}) {
  const supabase = await createServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const { data: profile } = await supabase
    .from("profile")
    .select("*")
    .eq("id", user.id)
    .single();

  const reason = searchParams.reason;
  const roundLimitReached = reason === "round_limit_reached";

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-6xl mx-auto">
        {roundLimitReached && (
          <div className="mb-8 p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg">
            <p className="text-yellow-800 dark:text-yellow-200">
              You've reached your limit of 25 rounds on the free tier. Upgrade
              to continue tracking your golf game!
            </p>
          </div>
        )}

        <h1 className="text-4xl font-bold text-center mb-4">
          Choose Your Plan
        </h1>
        <p className="text-xl text-muted-foreground text-center mb-12">
          Select the plan that best fits your golfing needs
        </p>

        <div className="grid md:grid-cols-3 gap-8">
          {/* Premium Plan */}
          <Card className="relative">
            <CardHeader>
              <CardTitle className="text-2xl">Premium</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold">$19</span>/year
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="space-y-3 mb-6">
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Unlimited rounds</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Basic handicap calculation</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Score history</span>
                </li>
                <li className="flex items-center gap-2">
                  <XCircle className="h-5 w-5 text-gray-400" />
                  <span className="text-muted-foreground">Round insights</span>
                </li>
                <li className="flex items-center gap-2">
                  <XCircle className="h-5 w-5 text-gray-400" />
                  <span className="text-muted-foreground">
                    Advanced analytics
                  </span>
                </li>
              </ul>
              <Link href={env.NEXT_PUBLIC_STRIPE_PREMIUM_LINK} target="_blank">
                <Button className="w-full" variant="outline">
                  Upgrade to Premium
                </Button>
              </Link>
            </CardContent>
          </Card>

          {/* Unlimited Plan - Recommended */}
          <Card className="relative border-primary shadow-lg">
            <div className="absolute -top-4 left-1/2 -translate-x-1/2 bg-primary text-primary-foreground px-4 py-1 rounded-full text-sm font-semibold">
              Recommended
            </div>
            <CardHeader>
              <CardTitle className="text-2xl">Unlimited</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold">$29</span>/year
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="space-y-3 mb-6">
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Unlimited rounds</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Advanced handicap calculation</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Round insights</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Performance analytics</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Trend charts & calculators</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Priority support</span>
                </li>
              </ul>
              <Link
                href={env.NEXT_PUBLIC_STRIPE_UNLIMITED_LINK}
                target="_blank"
              >
                <Button className="w-full">Upgrade to Unlimited</Button>
              </Link>
            </CardContent>
          </Card>

          {/* Lifetime Plan */}
          <Card className="relative">
            <CardHeader>
              <CardTitle className="text-2xl">Lifetime</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold">$149</span> one-time
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="space-y-3 mb-6">
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Everything in Unlimited</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>Pay once, use forever</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>All future features included</span>
                </li>
                <li className="flex items-center gap-2">
                  <CheckCircle className="h-5 w-5 text-green-500" />
                  <span>VIP support</span>
                </li>
              </ul>
              <Link
                href={env.NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK}
                target="_blank"
              >
                <Button className="w-full" variant="outline">
                  Get Lifetime Access
                </Button>
              </Link>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
```

### Success Criteria

#### Automated Verification

- [ ] TypeScript compilation passes: `pnpm build`
- [ ] Subscription utilities have correct types
- [ ] Middleware compiles without errors
- [ ] Round creation logic updated successfully

#### Manual Verification

- [ ] Base tier user with 25 rounds cannot access `/rounds/add` (redirected to /upgrade)
- [ ] Base tier user with <25 rounds can access `/rounds/add`
- [ ] Premium/Unlimited/Early adopter users always access `/rounds/add`
- [ ] Round creation increments `rounds_used` for base tier only
- [ ] Server-side validation throws error when limit reached
- [ ] Upgrade page displays correctly with all three plans
- [ ] Payment links redirect to Stripe correctly

---

## Phase 4: Early Adopter Assignment & UI Updates

### Overview

Update signup flow to assign early adopter status, update landing page with pricing, update dashboard to show subscription info.

### Changes Required

#### 1. Update Profile Creation for Early Adopters

**File**: `supabase/functions/create-profile/index.ts`
**Changes**: Add early adopter detection and assignment

```typescript
// Update the profile creation logic (around line 66-85)

export const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        ...corsHeaders,
      },
      status: 204,
    });
  }

  try {
    const { email, name, handicapIndex, userId } = await req.json();

    if (!email || !name || !userId) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: email, name, or userId",
        }),
        {
          status: 400,
          headers: {
            ...corsHeaders,
            "Content-Type": "application/json",
          },
        }
      );
    }

    const supabaseUrl =
      Deno.env.get("SUPABASE_URL") ?? Deno.env.get("LOCAL_SUPABASE_URL");
    const supabaseServiceRoleKey =
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ??
      Deno.env.get("LOCAL_SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseServiceRoleKey) {
      console.error("Missing Supabase environment variables");
      return new Response(
        JSON.stringify({ error: "Missing Supabase environment variables" }),
        {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

    // Check if user count is 100 or less to determine early adopter status
    const { count: userCount, error: countError } = await supabase
      .from("profile")
      .select("id", { count: "exact", head: true });

    if (countError) {
      console.error("Error counting users:", countError);
      return new Response(JSON.stringify({ error: "Failed to count users" }), {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const isEarlyAdopter = (userCount ?? 0) < 100;

    // Prepare profile data
    const profileData: any = {
      email,
      name,
      handicapIndex: handicapIndex || 54,
      id: userId,
      verified: false,
      is_early_adopter: isEarlyAdopter,
      rounds_used: 0,
    };

    // If early adopter, set premium tier and promo type
    if (isEarlyAdopter) {
      profileData.subscription_tier = "premium";
      profileData.subscription_type = "promo";
      profileData.subscription_status = "active";
      profileData.subscription_started_at = new Date().toISOString();
    }

    // Insert the profile into the database
    const { error } = await supabase.from("profile").insert([profileData]);

    if (error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      });
    }

    return new Response(
      JSON.stringify({
        success: true,
        isEarlyAdopter,
      }),
      {
        status: 200,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      }
    );
  } catch (error) {
    console.error("Unexpected error:", error);
    return new Response(
      JSON.stringify({ error: "An unexpected error occurred" }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
```

#### 2. Update Landing Page with Pricing

**File**: `components/homepage/landing.tsx`
**Changes**: Add pricing section with Stripe payment links

```typescript
// Add after the features section (around line 493), before closing div:

{
  /* Pricing Section */
}
<section className="py-20 bg-muted/50">
  <div className="container mx-auto px-4 sm:px-6 lg:px-8">
    <div className="text-center max-w-3xl mx-auto mb-16">
      <h2 className="text-3xl md:text-4xl font-bold mb-4">
        Simple, Transparent Pricing
      </h2>
      <p className="text-xl text-muted-foreground">
        Start free, upgrade when you need more rounds
      </p>
    </div>

    <div className="grid md:grid-cols-4 gap-6 max-w-7xl mx-auto">
      {/* Base Plan - Free */}
      <Card>
        <CardHeader>
          <CardTitle>Base</CardTitle>
          <CardDescription>
            <span className="text-3xl font-bold">Free</span>
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ul className="space-y-3 mb-6 text-sm">
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>25 rounds total</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Basic handicap calculation</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Score history</span>
            </li>
          </ul>
          <Link href="/signup">
            <Button className="w-full" variant="outline">
              Get Started
            </Button>
          </Link>
        </CardContent>
      </Card>

      {/* Premium Plan */}
      <Card>
        <CardHeader>
          <CardTitle>Premium</CardTitle>
          <CardDescription>
            <span className="text-3xl font-bold">$19</span>/year
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ul className="space-y-3 mb-6 text-sm">
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Unlimited rounds</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>All Base features</span>
            </li>
          </ul>
          <Link
            href={process.env.NEXT_PUBLIC_STRIPE_PREMIUM_LINK!}
            target="_blank"
          >
            <Button className="w-full" variant="outline">
              Upgrade
            </Button>
          </Link>
        </CardContent>
      </Card>

      {/* Unlimited Plan - Most Popular */}
      <Card className="border-primary shadow-lg relative">
        <div className="absolute -top-3 left-1/2 -translate-x-1/2 bg-primary text-primary-foreground px-3 py-1 rounded-full text-xs font-semibold">
          Most Popular
        </div>
        <CardHeader>
          <CardTitle>Unlimited</CardTitle>
          <CardDescription>
            <span className="text-3xl font-bold">$29</span>/year
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ul className="space-y-3 mb-6 text-sm">
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Unlimited rounds</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Advanced analytics</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Round insights</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Priority support</span>
            </li>
          </ul>
          <Link
            href={process.env.NEXT_PUBLIC_STRIPE_UNLIMITED_LINK!}
            target="_blank"
          >
            <Button className="w-full">Upgrade</Button>
          </Link>
        </CardContent>
      </Card>

      {/* Lifetime Plan */}
      <Card>
        <CardHeader>
          <CardTitle>Lifetime</CardTitle>
          <CardDescription>
            <span className="text-3xl font-bold">$149</span> once
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ul className="space-y-3 mb-6 text-sm">
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Everything in Unlimited</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>Pay once, use forever</span>
            </li>
            <li className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
              <span>All future features</span>
            </li>
          </ul>
          <Link
            href={process.env.NEXT_PUBLIC_STRIPE_UNLIMITED_LIFETIME_LINK!}
            target="_blank"
          >
            <Button className="w-full" variant="outline">
              Get Lifetime
            </Button>
          </Link>
        </CardContent>
      </Card>
    </div>

    <p className="text-center text-sm text-muted-foreground mt-8">
      * First 100 users get Premium tier for free forever
    </p>
  </div>
</section>;
```

#### 3. Update Dashboard to Show Subscription Status

**File**: `components/dashboard/dashboardInfo.tsx`
**Changes**: Add subscription status and remaining rounds display

```typescript
import { Badge } from "@/components/ui/badge";
import { getRemainingRounds } from "@/lib/subscription";
import Link from "next/link";

interface DashboardIndexProps {
  handicapIndex: number;
  header: string;
  profile: {
    subscriptionTier: "base" | "premium" | "unlimited";
    roundsUsed: number;
    isEarlyAdopter: boolean;
  };
}

const DashboardIndex = ({
  handicapIndex,
  header,
  profile,
}: DashboardIndexProps) => {
  const remainingRounds = getRemainingRounds(profile);
  const tierDisplay =
    profile.subscriptionTier.charAt(0).toUpperCase() +
    profile.subscriptionTier.slice(1);

  return (
    <div className="bg-card rounded-lg p-6 rounded-r-none">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold">Handicap</h2>
        <Badge
          variant={
            profile.subscriptionTier === "unlimited" ? "default" : "secondary"
          }
        >
          {profile.isEarlyAdopter ? "ðŸŽ‰ Early Adopter" : tierDisplay}
        </Badge>
      </div>

      <div className="text-6xl font-bold text-primary">{handicapIndex}</div>
      <p className="text-muted-foreground">Current Handicap</p>

      {/* Subscription Status */}
      {remainingRounds !== null && (
        <div className="mt-4 p-3 bg-muted rounded-lg">
          <p className="text-sm font-semibold">
            {remainingRounds} rounds remaining
          </p>
          {remainingRounds <= 5 && (
            <Link href="/upgrade">
              <Button
                variant="link"
                className="text-primary underline px-0 text-sm"
              >
                Upgrade for unlimited rounds â†’
              </Button>
            </Link>
          )}
        </div>
      )}

      <div className="mt-4">
        <Button variant="link" className="text-primary underline px-0 mb-10">
          How is my handicap calculated?
        </Button>
        <H4 className="mb-2!">{header}</H4>
        <P className="mt-4!">
          Handicappin&apos; believes in transparency and making golf accessible.
          It can be difficult to find accurate and consistent information on the
          calculations of scores, handicaps and the rules of golf online. We aim
          to be a reliable source of information and aim to ease the unnecessary
          confusion around golf.
        </P>
        <P>
          An easy, interactive way to understand the calculations behind
          handicaps and scoring can be viewed by clicking the button below, or
          by viewing a specific round&apos;s calculation.
        </P>
        <Button variant="link" className="text-primary underline px-0 mb-6">
          Click here to learn more
        </Button>
      </div>
    </div>
  );
};

export default DashboardIndex;
```

**File**: `components/dashboard/dashboard.tsx`
**Changes**: Pass profile to DashboardInfo

```typescript
// Update the DashboardInfo component call (around line 45)
<DashboardInfo
  handicapIndex={profile.handicapIndex}
  header={header}
  profile={{
    subscriptionTier: profile.subscriptionTier,
    roundsUsed: profile.roundsUsed,
    isEarlyAdopter: profile.isEarlyAdopter,
  }}
/>
```

### Success Criteria

#### Automated Verification

- [ ] TypeScript compilation passes: `pnpm build`
- [ ] Supabase Edge Function deploys: `supabase functions deploy create-profile`
- [ ] No type errors in updated components

#### Manual Verification

- [ ] New user signup (when <100 users exist) sets `is_early_adopter = true`
- [ ] New user signup (when â‰¥100 users exist) sets `is_early_adopter = false`
- [ ] Early adopter gets premium tier with promo type automatically
- [ ] Landing page displays all 4 pricing tiers correctly
- [ ] Payment links on landing page redirect to Stripe
- [ ] Dashboard shows subscription tier badge
- [ ] Dashboard shows remaining rounds counter for base tier users
- [ ] Dashboard shows "Upgrade" prompt when rounds â‰¤ 5
- [ ] Early adopter badge displays correctly

---

## Testing Strategy

### Unit Tests

Create `tests/unit/subscription.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import {
  canAddRound,
  getRemainingRounds,
  canAccessFeature,
} from "@/lib/subscription";

describe("Subscription Utils", () => {
  it("should allow premium users to add unlimited rounds", () => {
    const profile = {
      subscriptionTier: "premium" as const,
      roundsUsed: 100,
      isEarlyAdopter: false,
    };
    expect(canAddRound(profile)).toBe(true);
  });

  it("should block base users at 25 rounds", () => {
    const profile = {
      subscriptionTier: "base" as const,
      roundsUsed: 25,
      isEarlyAdopter: false,
    };
    expect(canAddRound(profile)).toBe(false);
  });

  it("should allow early adopters unlimited rounds", () => {
    const profile = {
      subscriptionTier: "premium" as const,
      roundsUsed: 100,
      isEarlyAdopter: true,
    };
    expect(canAddRound(profile)).toBe(true);
  });

  it("should return correct remaining rounds for base tier", () => {
    const profile = {
      subscriptionTier: "base" as const,
      roundsUsed: 20,
      isEarlyAdopter: false,
    };
    expect(getRemainingRounds(profile)).toBe(5);
  });

  it("should return null for premium tier (unlimited)", () => {
    const profile = {
      subscriptionTier: "premium" as const,
      roundsUsed: 0,
      isEarlyAdopter: false,
    };
    expect(getRemainingRounds(profile)).toBe(null);
  });

  it("should correctly check feature access", () => {
    const baseProfile = {
      subscriptionTier: "base" as const,
      isEarlyAdopter: false,
    };
    const unlimitedProfile = {
      subscriptionTier: "unlimited" as const,
      isEarlyAdopter: false,
    };

    expect(canAccessFeature(baseProfile, "round_insights")).toBe(false);
    expect(canAccessFeature(unlimitedProfile, "round_insights")).toBe(true);
  });
});
```

### Integration Tests

Manual testing scenarios:

#### Scenario 1: Free User Journey

1. Sign up as new user (user #50)
2. Verify early adopter status in database
3. Check dashboard shows "Early Adopter" badge
4. Add 30 rounds - should succeed (no limit)
5. Verify `rounds_used` stays at 0 for early adopters

#### Scenario 2: Base Tier User Journey

1. Sign up as new user (user #150 - after 100 limit)
2. Verify `is_early_adopter = false`, `subscription_tier = 'base'`
3. Add 20 rounds successfully
4. Dashboard shows "5 rounds remaining"
5. Add 5 more rounds (total 25)
6. Attempt to access `/rounds/add` - redirected to `/upgrade`
7. Attempt API call to `submitScorecard` - receives error

#### Scenario 3: Stripe Payment Flow

1. Base tier user clicks "Upgrade to Unlimited" on landing page
2. Redirected to Stripe payment link
3. Complete test payment (use test card: 4242 4242 4242 4242)
4. Webhook receives `checkout.session.completed` event
5. Database updated: `subscription_tier = 'unlimited'`, `subscription_status = 'active'`
6. User can now add unlimited rounds
7. Premium features unlocked (future implementation)

#### Scenario 4: Subscription Cancellation

1. Unlimited user has active subscription
2. Cancel subscription in Stripe dashboard
3. Webhook receives `customer.subscription.deleted` event
4. Database updated: `subscription_tier = 'base'`, `subscription_status = 'expired'`
5. User limited to 25 rounds again
6. `rounds_used` counter starts tracking

### Webhook Testing with Stripe CLI

```bash
# Install Stripe CLI
brew install stripe/stripe-cli/stripe

# Login to Stripe
stripe login

# Forward webhooks to local endpoint
stripe listen --forward-to localhost:3000/api/stripe/webhook

# Trigger test events
stripe trigger checkout.session.completed
stripe trigger customer.subscription.updated
stripe trigger customer.subscription.deleted
stripe trigger invoice.payment_failed

# Verify events are processed correctly in terminal output
```

## Performance Considerations

### Database Optimization

- Indexes on `stripe_customer_id`, `subscription_tier`, `is_early_adopter` ensure fast lookups
- Webhook updates use direct Supabase client (bypasses RLS for performance)
- Round limit checks use minimal field selection

### Caching Strategy

- Consider caching subscription status in session/cookie for faster middleware checks
- Invalidate cache on webhook updates
- Current implementation: Fresh DB query on each request (acceptable for MVP)

### Monitoring

- Log all webhook events for debugging
- Track conversion metrics (base â†’ paid)
- Monitor failed webhook deliveries in Stripe dashboard

## Migration Notes

### Deploying to Production

1. **Run migration**:

   ```bash
   supabase db push
   ```

2. **Deploy Edge Function**:

   ```bash
   supabase functions deploy create-profile
   ```

3. **Create Stripe products** (in Stripe dashboard):

   - Premium: $19/year recurring
   - Unlimited: $29/year recurring
   - Unlimited Lifetime: $149 one-time

4. **Create Stripe payment links** for each product

5. **Configure webhook**:

   - Add endpoint: `https://your-domain.com/api/stripe/webhook`
   - Select events: `checkout.session.completed`, `customer.subscription.*`, `invoice.payment_*`
   - Copy webhook secret to production env

6. **Update environment variables** in Vercel:

   - All Stripe keys (secret, publishable, webhook secret)
   - All price IDs
   - All payment links

7. **Test in production**:
   - Use Stripe test mode first
   - Verify webhooks are received
   - Test full payment flow
   - Switch to live mode when ready

### Rollback Plan

If issues arise:

1. Set environment variable: `DISABLE_SUBSCRIPTIONS=true`
2. Update middleware to skip checks when disabled
3. Remove pricing section from landing page temporarily
4. Investigate and fix issues
5. Re-enable when stable

## References

- Original ticket: `.cursor/tickets/0001-stripe-subscription-and-monetization-system.md`
- Stripe Webhook Documentation: https://stripe.com/docs/webhooks
- Stripe Payment Links: https://stripe.com/docs/payment-links
- Supabase Edge Functions: https://supabase.com/docs/guides/functions
- Next.js Middleware: https://nextjs.org/docs/app/building-your-application/routing/middleware
