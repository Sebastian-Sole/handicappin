# Stripe Endpoint Rate Limiting Implementation Plan

## Overview

Implement rate limiting on Stripe API endpoints (`/api/stripe/checkout`, `/api/stripe/portal`, `/api/stripe/webhook`) to prevent API abuse, DoS attacks, and Stripe API rate limit violations. Uses Vercel KV (Upstash Redis) for distributed rate limiting across serverless instances, with configurable limits and graceful failure handling.

## Current State Analysis

### Existing Endpoints (No Rate Limiting):
- `app/api/stripe/checkout/route.ts:11` - POST endpoint for checkout session creation
- `app/api/stripe/portal/route.ts:5` - POST endpoint for billing portal session creation
- `app/api/stripe/webhook/route.ts:20` - POST endpoint for webhook events

### Key Findings:
- Next.js 15 app deployed on Vercel (serverless)
- No existing rate limiting infrastructure
- Endpoints are vulnerable to spam/abuse (detailed in ticket #0023)
- Webhook has idempotency protection (ticket #0015) but no rate limiting

### Environment:
- Serverless deployment requires distributed rate limiting (in-memory won't work)
- No Redis/KV infrastructure currently configured
- Application in development phase (no real users yet)

## Desired End State

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compilation passes: `pnpm build`
- [ ] No linting errors: `pnpm lint`
- [ ] Environment variables properly configured in Vercel dashboard
- [ ] Vercel KV store created and connected to project

#### Manual Verification:
- [ ] Checkout endpoint returns 429 after 10 requests in 1 minute from same user
- [ ] Portal endpoint returns 429 after 5 requests in 1 minute from same user
- [ ] Webhook endpoint returns 429 after 100 requests in 1 minute from same IP
- [ ] Rate limit headers present in responses: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- [ ] 429 responses include `Retry-After` header
- [ ] Client displays user-friendly error message when rate limited
- [ ] Rate limiting disabled in local development
- [ ] Rate limiting enabled in production (Vercel)
- [ ] If Redis unavailable, requests succeed with error logged (fail open)

## What We're NOT Doing

- Unit tests or load tests (to avoid Redis costs during development)
- Dynamic rate limit adjustment based on user plan (premium vs free)
- Rate limit dashboard or analytics UI
- IP reputation scoring
- CAPTCHA integration for rate-limited requests
- Distributed rate limiting across multiple regions
- Rate limit bypass for admin users
- Per-endpoint rate limit monitoring alerts

## Implementation Approach

### Strategy:
1. **Phase 1**: Set up Vercel KV infrastructure and configuration
2. **Phase 2**: Create rate limiting library with sliding window algorithm
3. **Phase 3**: Integrate rate limiting into Stripe endpoints
4. **Phase 4**: Add client-side error handling for 429 responses

### Technical Decisions:

**Why Vercel KV?**
- Native integration with Vercel (3-click setup)
- Upstash Redis under the hood (serverless-optimized)
- Free tier: 30K commands/month (enough for development)
- Hobby tier: $1/month for 500K commands (sufficient for early production)
- HTTP-based (works with Edge Runtime)

**Why Sliding Window Algorithm?**
- More accurate than fixed window
- Prevents "burst at boundary" attacks
- Example: 10 req/min = max 10 in ANY 60-second rolling window
- Built into `@upstash/ratelimit` library

**Why Fail Open?**
- If Redis is unavailable, allow requests through
- Logs error for monitoring
- Prevents rate limiting from causing outages
- Security vs availability tradeoff (availability wins for early stage)

**Cost Estimates:**
- Development: $0/month (free tier)
- Production (<1K users): $1/month (hobby tier)
- Production (10K active users): ~$12/month
- Protection from Stripe API abuse: Priceless

---

## Phase 1: Vercel KV Setup & Configuration

### Overview
Set up Vercel KV storage (managed Upstash Redis) and configure environment variables for rate limiting.

### Changes Required:

#### 1. Vercel Dashboard - Create KV Store

**Steps:**
1. Go to [Vercel Dashboard](https://vercel.com/dashboard)
2. Navigate to your project (handicappin)
3. Go to **Storage** tab
4. Click **Create Database**
5. Select **KV (Redis compatible)**
6. Choose a name: `handicappin-rate-limit-kv`
7. Select region: Choose closest to your users (e.g., `us-east-1`)
8. Click **Create**

**Result:** Vercel automatically adds environment variables to your project:
- `KV_URL`
- `KV_REST_API_URL`
- `KV_REST_API_TOKEN`
- `KV_REST_API_READ_ONLY_TOKEN`

#### 2. Environment Variables - Add Rate Limit Configuration

**File**: Vercel Dashboard → Settings → Environment Variables

Add the following variables:

| Variable | Value | Scope |
|----------|-------|-------|
| `RATE_LIMIT_ENABLED` | `false` | Development |
| `RATE_LIMIT_ENABLED` | `true` | Production, Preview |
| `RATE_LIMIT_CHECKOUT_PER_MIN` | `10` | All |
| `RATE_LIMIT_PORTAL_PER_MIN` | `5` | All |
| `RATE_LIMIT_WEBHOOK_PER_MIN` | `100` | All |

**Alternative:** Set development limits very high instead of disabling:
```
RATE_LIMIT_CHECKOUT_PER_MIN=1000 (Development)
RATE_LIMIT_CHECKOUT_PER_MIN=10 (Production, Preview)
```

#### 3. Install Dependencies

**File**: Terminal
**Command**:
```bash
pnpm add @upstash/ratelimit @vercel/kv
```

**Dependencies Added:**
- `@upstash/ratelimit` - Rate limiting library with sliding window algorithm
- `@vercel/kv` - Vercel KV client (wraps Upstash Redis)

#### 4. Update Local Environment

**File**: `.env.local`
**Changes**: Add local development overrides

```bash
# Rate Limiting (Development)
RATE_LIMIT_ENABLED=false

# Rate Limit Configuration (optional local overrides)
RATE_LIMIT_CHECKOUT_PER_MIN=10
RATE_LIMIT_PORTAL_PER_MIN=5
RATE_LIMIT_WEBHOOK_PER_MIN=100

# Vercel KV (automatically populated by `vercel env pull`)
# KV_REST_API_URL=
# KV_REST_API_TOKEN=
# KV_REST_API_READ_ONLY_TOKEN=
```

**Note:** After creating Vercel KV store, run `vercel env pull` to sync environment variables locally.

#### 5. Pull Vercel Environment Variables

**File**: Terminal
**Command**:
```bash
vercel env pull .env.local
```

This pulls `KV_*` variables from Vercel dashboard to your local `.env.local` file.

### Success Criteria:

#### Automated Verification:
- [x] Dependencies installed successfully: `pnpm install`
- [ ] Vercel KV store visible in Vercel Dashboard → Storage
- [ ] Environment variables present in Vercel Dashboard → Settings → Environment Variables

#### Manual Verification:
- [ ] `.env.local` contains `KV_REST_API_URL` and `KV_REST_API_TOKEN` after running `vercel env pull`
- [ ] Vercel Dashboard shows KV store with 0 keys initially
- [x] Can run `pnpm build` without errors

---

## Phase 2: Rate Limiting Library

### Overview
Create reusable rate limiting utilities with sliding window algorithm, configurable limits, and graceful failure handling.

### Changes Required:

#### 1. Rate Limiting Core Library

**File**: `lib/rate-limit.ts` (new file)
**Changes**: Create rate limiting utilities

```typescript
import { Ratelimit } from '@upstash/ratelimit';
import { kv } from '@vercel/kv';

/**
 * Rate limiting configuration
 * - Development: Disabled or very high limits
 * - Production: Conservative limits to prevent abuse
 */
const isEnabled = process.env.RATE_LIMIT_ENABLED !== 'false';
const isDevelopment = process.env.NODE_ENV === 'development';

// Configurable rate limits from environment variables
const CHECKOUT_LIMIT = parseInt(process.env.RATE_LIMIT_CHECKOUT_PER_MIN || '10', 10);
const PORTAL_LIMIT = parseInt(process.env.RATE_LIMIT_PORTAL_PER_MIN || '5', 10);
const WEBHOOK_LIMIT = parseInt(process.env.RATE_LIMIT_WEBHOOK_PER_MIN || '100', 10);

/**
 * Create rate limiter with sliding window algorithm
 * @param limit - Max requests per window
 * @param prefix - Redis key prefix for this limiter
 */
function createRateLimiter(limit: number, prefix: string) {
  // If rate limiting disabled or in development, return bypass limiter
  if (!isEnabled || isDevelopment) {
    console.log(`[Rate Limit] Disabled for ${prefix} (${isDevelopment ? 'development' : 'RATE_LIMIT_ENABLED=false'})`);
    return {
      limit: async () => ({
        success: true,
        limit,
        remaining: limit,
        reset: Date.now() + 60000,
      }),
    };
  }

  try {
    return new Ratelimit({
      redis: kv,
      limiter: Ratelimit.slidingWindow(limit, '1 m'),
      analytics: false, // Disable analytics to save Redis commands
      prefix: `ratelimit:${prefix}`,
    });
  } catch (error) {
    console.error(`[Rate Limit] Failed to create limiter for ${prefix}:`, error);
    // Fail open - return bypass limiter
    return {
      limit: async () => ({
        success: true,
        limit,
        remaining: limit,
        reset: Date.now() + 60000,
      }),
    };
  }
}

// Create rate limiters for each endpoint
export const checkoutRateLimit = createRateLimiter(CHECKOUT_LIMIT, 'checkout');
export const portalRateLimit = createRateLimiter(PORTAL_LIMIT, 'portal');
export const webhookRateLimit = createRateLimiter(WEBHOOK_LIMIT, 'webhook');

/**
 * Extract identifier for rate limiting
 * - Authenticated requests: Use user ID (per-user limits)
 * - Unauthenticated requests: Use IP address (per-IP limits)
 *
 * @param request - Next.js request object
 * @param userId - Optional user ID from auth
 * @returns Identifier string for rate limiting
 */
export function getIdentifier(request: Request, userId?: string): string {
  // Prefer user ID for authenticated requests
  if (userId) {
    return `user:${userId}`;
  }

  // Fall back to IP address for unauthenticated requests
  const forwarded = request.headers.get('x-forwarded-for');
  const realIp = request.headers.get('x-real-ip');

  // x-forwarded-for can contain multiple IPs (client, proxy1, proxy2)
  // Take the first one (original client IP)
  const ip = forwarded?.split(',')[0]?.trim() || realIp || 'unknown';

  return `ip:${ip}`;
}

/**
 * Type guard to check if rate limiter is available
 */
export function isRateLimitEnabled(): boolean {
  return isEnabled && !isDevelopment;
}
```

**Key Design Decisions:**
- **Sliding window algorithm**: More accurate, prevents boundary exploits
- **Fail open**: If Redis unavailable, allow requests through
- **Configurable**: All limits from environment variables
- **Development bypass**: Disabled in development to avoid annoyance
- **User-based limiting**: Prefer user ID over IP when available
- **Analytics disabled**: Saves Redis commands (costs)

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [x] File created at `lib/rate-limit.ts`
- [x] Exports `checkoutRateLimit`, `portalRateLimit`, `webhookRateLimit`, `getIdentifier`

---

## Phase 3: Integrate Rate Limiting into Stripe Endpoints

### Overview
Add rate limiting checks to checkout, portal, and webhook endpoints with proper error handling and HTTP headers.

### Changes Required:

#### 1. Checkout Endpoint - Add Rate Limiting

**File**: `app/api/stripe/checkout/route.ts`
**Changes**: Add rate limiting before checkout session creation

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import {
  createCheckoutSession,
  createLifetimeCheckoutSession,
  PLAN_TO_PRICE_MAP,
  stripe,
} from "@/lib/stripe";
import { verifyPaymentAmount, formatAmount } from '@/utils/billing/pricing';
import { checkoutRateLimit, getIdentifier } from '@/lib/rate-limit'; // NEW

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerComponentClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // ✅ NEW: Rate limiting check
    const identifier = getIdentifier(request, user.id);
    const { success, limit, remaining, reset } = await checkoutRateLimit.limit(identifier);

    // Build rate limit headers
    const rateLimitHeaders = {
      'X-RateLimit-Limit': limit.toString(),
      'X-RateLimit-Remaining': remaining.toString(),
      'X-RateLimit-Reset': new Date(reset).toISOString(),
    };

    // If rate limit exceeded, return 429
    if (!success) {
      const retryAfterSeconds = Math.ceil((reset - Date.now()) / 1000);

      console.warn(`[Rate Limit] Checkout rate limit exceeded for ${identifier}`);

      return NextResponse.json(
        {
          error: 'Too many checkout requests. Please try again in a moment.',
          retryAfter: retryAfterSeconds,
        },
        {
          status: 429,
          headers: {
            ...rateLimitHeaders,
            'Retry-After': retryAfterSeconds.toString(),
          },
        }
      );
    }

    const { plan } = (await request.json()) as { plan: string };

    if (plan !== "premium" && plan !== "unlimited" && plan !== "lifetime") {
      return NextResponse.json({ error: "Invalid plan" }, { status: 400 });
    }

    const priceId =
      PLAN_TO_PRICE_MAP[plan as "premium" | "unlimited" | "lifetime"];

    if (!priceId) {
      return NextResponse.json(
        { error: "Price ID not configured for this plan" },
        { status: 500 }
      );
    }

    // ✅ Existing: Verify price ID points to correct amount (Defense in Depth)
    try {
      const price = await stripe.prices.retrieve(priceId);

      const verification = verifyPaymentAmount(
        plan as "premium" | "unlimited" | "lifetime",
        price.currency,
        price.unit_amount || 0,
        price.type === 'recurring'
      );

      if (!verification.valid) {
        console.error('❌ CRITICAL: Price verification failed at checkout', {
          plan,
          priceId,
          expected: formatAmount(verification.expected),
          actual: formatAmount(verification.actual),
          variance: verification.variance,
          severity: 'HIGH',
          action: 'Check environment variables and Stripe dashboard',
        });

        return NextResponse.json(
          { error: 'Pricing configuration error. Please contact support.' },
          { status: 500 }
        );
      }

      console.log('✅ Price verification passed at checkout', {
        plan,
        amount: formatAmount(verification.actual),
        currency: price.currency,
      });
    } catch (error) {
      console.error('❌ Failed to verify price during checkout', error);
      return NextResponse.json(
        { error: 'Failed to verify pricing' },
        { status: 500 }
      );
    }

    console.log("Price ID:", priceId);
    console.log("User ID:", user.id);
    console.log("User Email:", user.email);
    console.log("Plan:", plan);
    console.log(
      "Success URL:",
      `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`
    );
    console.log(
      "Cancel URL:",
      `${process.env.NEXT_PUBLIC_SITE_URL}/onboarding`
    );

    // Create the checkout session (lifetime uses payment mode, others use subscription mode)
    const session =
      plan === "lifetime"
        ? await createLifetimeCheckoutSession({
            userId: user.id,
            email: user.email!,
            priceId,
            successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
            cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/onboarding`,
          })
        : await createCheckoutSession({
            userId: user.id,
            email: user.email!,
            priceId,
            successUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
            cancelUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/onboarding`,
          });

    console.log("Checkout session created:", session);

    // ✅ NEW: Include rate limit headers in success response
    return NextResponse.json({ url: session.url }, { headers: rateLimitHeaders });
  } catch (error) {
    console.error("Error creating checkout session:", error);
    return NextResponse.json(
      { error: "Failed to create checkout session" },
      { status: 500 }
    );
  }
}
```

**Key Changes:**
- Rate limit check after authentication (line 23)
- Extract identifier (user ID or IP) for rate limiting
- Return 429 with `Retry-After` header if limit exceeded
- Include rate limit headers in all responses
- Log rate limit violations for monitoring

#### 2. Portal Endpoint - Add Rate Limiting

**File**: `app/api/stripe/portal/route.ts`
**Changes**: Add rate limiting before portal session creation

```typescript
import { NextRequest, NextResponse } from "next/server";
import { createServerComponentClient } from "@/utils/supabase/server";
import { createPortalSession, stripe } from "@/lib/stripe";
import { portalRateLimit, getIdentifier } from '@/lib/rate-limit'; // NEW

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerComponentClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // ✅ NEW: Rate limiting check
    const identifier = getIdentifier(request, user.id);
    const { success, limit, remaining, reset } = await portalRateLimit.limit(identifier);

    // Build rate limit headers
    const rateLimitHeaders = {
      'X-RateLimit-Limit': limit.toString(),
      'X-RateLimit-Remaining': remaining.toString(),
      'X-RateLimit-Reset': new Date(reset).toISOString(),
    };

    // If rate limit exceeded, return 429
    if (!success) {
      const retryAfterSeconds = Math.ceil((reset - Date.now()) / 1000);

      console.warn(`[Rate Limit] Portal rate limit exceeded for ${identifier}`);

      return NextResponse.json(
        {
          error: 'Too many portal requests. Please try again in a moment.',
          retryAfter: retryAfterSeconds,
        },
        {
          status: 429,
          headers: {
            ...rateLimitHeaders,
            'Retry-After': retryAfterSeconds.toString(),
          },
        }
      );
    }

    // Get the Stripe customer ID from the database
    const { data: stripeCustomer } = await supabase
      .from("stripe_customers")
      .select("stripe_customer_id")
      .eq("user_id", user.id)
      .single();

    if (!stripeCustomer?.stripe_customer_id) {
      return NextResponse.json(
        { error: "No Stripe customer found" },
        { status: 404 }
      );
    }

    // Create a portal session
    const session = await createPortalSession({
      customerId: stripeCustomer.stripe_customer_id,
      returnUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/billing`,
    });

    // ✅ NEW: Include rate limit headers in success response
    return NextResponse.json({ url: session.url }, { headers: rateLimitHeaders });
  } catch (error) {
    console.error("Error creating portal session:", error);
    return NextResponse.json(
      { error: "Failed to create portal session" },
      { status: 500 }
    );
  }
}
```

**Key Changes:**
- Rate limit check after authentication (line 19)
- Same pattern as checkout endpoint
- Lower limit (5/min vs 10/min) since portal accessed less frequently

#### 3. Webhook Endpoint - Add Rate Limiting (IP-based)

**File**: `app/api/stripe/webhook/route.ts`
**Changes**: Add IP-based rate limiting at the start of webhook handler

```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { profile, stripeCustomers, webhookEvents, pendingLifetimePurchases } from "@/db/schema";
import { eq, sql } from "drizzle-orm";
import Stripe from "stripe";
import { stripe, mapPriceToPlan } from "@/lib/stripe";
import {
  logWebhookReceived,
  logWebhookSuccess,
  logWebhookError,
  logWebhookWarning,
  logWebhookDebug,
  logWebhookInfo,
  logPaymentEvent,
  logSubscriptionEvent,
} from "@/lib/webhook-logger";
import { verifyCustomerOwnership } from "@/lib/stripe-security";
import { verifyPaymentAmount, formatAmount } from '@/utils/billing/pricing';
import { webhookRateLimit, getIdentifier } from '@/lib/rate-limit'; // NEW

export async function POST(request: NextRequest) {
  let event: any = null; // Declare in outer scope for failure recording

  try {
    // ✅ NEW: Rate limiting check (IP-based, no user context)
    const identifier = getIdentifier(request); // No userId = uses IP
    const { success, limit, remaining, reset } = await webhookRateLimit.limit(identifier);

    if (!success) {
      const retryAfterSeconds = Math.ceil((reset - Date.now()) / 1000);

      console.warn(`[Rate Limit] Webhook rate limit exceeded for ${identifier}`);

      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          retryAfter: retryAfterSeconds,
        },
        {
          status: 429,
          headers: {
            'Retry-After': retryAfterSeconds.toString(),
          },
        }
      );
    }

    const body = await request.text();
    const signature = request.headers.get("stripe-signature");

    if (!signature) {
      return NextResponse.json(
        { error: "No signature provided" },
        { status: 400 }
      );
    }

    // Verify webhook signature
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );

    logWebhookReceived(event.type);

    // ... rest of webhook handler unchanged ...
```

**Key Changes:**
- Rate limit check BEFORE signature verification (line 22)
- IP-based limiting (no user context in webhooks)
- Higher limit (100/min) since Stripe is only caller
- No rate limit headers in response (Stripe doesn't need them)

**Note:** Only showing the beginning of the file. The rest remains unchanged.

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [x] All three endpoints have rate limiting imports
- [x] Rate limit check happens after auth (checkout/portal) or at start (webhook)
- [x] 429 responses include proper headers

---

## Phase 4: Client-Side Error Handling

### Overview
Add user-friendly error handling for rate limit responses (429) on the client side.

### Changes Required:

#### 1. Find Client-Side Checkout Calls

**Action**: Search for files that call `/api/stripe/checkout` and `/api/stripe/portal`

Likely locations:
- Components that trigger checkout (e.g., pricing page, upgrade buttons)
- Billing management page components

**Example Pattern to Find:**
```typescript
// Search for these patterns:
fetch('/api/stripe/checkout', ...)
fetch('/api/stripe/portal', ...)
```

#### 2. Add 429 Error Handling

**Pattern**: Wherever you find API calls to Stripe endpoints, add handling:

```typescript
// BEFORE (example):
try {
  const response = await fetch('/api/stripe/checkout', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ plan: 'premium' }),
  });

  const data = await response.json();

  if (!response.ok) {
    throw new Error(data.error || 'Failed to create checkout session');
  }

  window.location.href = data.url;
} catch (error) {
  console.error('Checkout failed:', error);
  alert('Failed to start checkout. Please try again.');
}

// AFTER (with 429 handling):
try {
  const response = await fetch('/api/stripe/checkout', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ plan: 'premium' }),
  });

  const data = await response.json();

  // ✅ NEW: Handle rate limit specifically
  if (response.status === 429) {
    const retryAfter = data.retryAfter || 60;
    alert(`Too many requests. Please wait ${retryAfter} seconds and try again.`);
    return;
  }

  if (!response.ok) {
    throw new Error(data.error || 'Failed to create checkout session');
  }

  window.location.href = data.url;
} catch (error) {
  console.error('Checkout failed:', error);
  alert('Failed to start checkout. Please try again.');
}
```

**Better UX with Toast Notification** (if you have a toast system):
```typescript
if (response.status === 429) {
  const retryAfter = data.retryAfter || 60;
  toast({
    title: "Too many requests",
    description: `Please wait ${retryAfter} seconds before trying again.`,
    variant: "destructive",
  });
  return;
}
```

#### 3. Update All Stripe API Calls

**Files to Update** (find with grep/search):
- Any component calling `/api/stripe/checkout`
- Any component calling `/api/stripe/portal`
- Server actions or API route handlers that call these endpoints

**Search Commands:**
```bash
# Find all files calling Stripe endpoints
grep -r "api/stripe/checkout" --include="*.ts" --include="*.tsx" .
grep -r "api/stripe/portal" --include="*.ts" --include="*.tsx" .
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `pnpm build`
- [x] No linting errors: `pnpm lint`

#### Manual Verification:
- [x] All client-side calls to Stripe endpoints handle 429 status
- [x] Error messages are user-friendly (no technical jargon)
- [x] Retry-after time displayed to user

---

## Testing Strategy

### Manual Testing (Required)

#### Test 1: Checkout Rate Limit

**Setup:**
1. Deploy to Vercel or run locally with `RATE_LIMIT_ENABLED=true`
2. Ensure `RATE_LIMIT_CHECKOUT_PER_MIN=10`
3. Log in as a test user

**Test Steps:**
```bash
# Get your auth token from browser DevTools → Application → Cookies
TOKEN="your-auth-token"

# Send 15 requests rapidly
for i in {1..15}; do
  echo "Request $i:"
  curl -X POST https://your-app.vercel.app/api/stripe/checkout \
    -H "Cookie: your-auth-cookie" \
    -H "Content-Type: application/json" \
    -d '{"plan":"premium"}' \
    -w "\nStatus: %{http_code}\n\n" \
    -s
done
```

**Expected Results:**
- First 10 requests: Return 200 with checkout URL
- Request 11-15: Return 429 with error message
- 429 responses include `Retry-After` header
- 429 responses include `X-RateLimit-*` headers

**Verify in Vercel KV Dashboard:**
- Go to Vercel Dashboard → Storage → Your KV store
- You should see keys like `ratelimit:checkout:user:{userId}`

#### Test 2: Portal Rate Limit

**Test Steps:**
```bash
# Send 10 requests rapidly (limit is 5/min)
for i in {1..10}; do
  echo "Request $i:"
  curl -X POST https://your-app.vercel.app/api/stripe/portal \
    -H "Cookie: your-auth-cookie" \
    -w "\nStatus: %{http_code}\n\n" \
    -s
done
```

**Expected Results:**
- First 5 requests: Return 200 with portal URL
- Requests 6-10: Return 429 with error message

#### Test 3: Rate Limit Reset

**Test Steps:**
1. Trigger rate limit (send 11 checkout requests)
2. Wait for `Retry-After` seconds (should be ~60 seconds)
3. Send another request

**Expected Results:**
- After waiting, rate limit resets
- New request succeeds (200 response)

#### Test 4: Development Bypass

**Test Steps:**
1. Run locally: `pnpm dev`
2. Ensure `.env.local` has `RATE_LIMIT_ENABLED=false`
3. Send 100 checkout requests rapidly

**Expected Results:**
- All 100 requests succeed (no rate limiting)
- Console logs show: `[Rate Limit] Disabled for checkout (development)`

#### Test 5: Client-Side Error Handling

**Test Steps:**
1. In browser, trigger rate limit by clicking checkout button 11 times rapidly
2. Observe error message

**Expected Results:**
- User sees friendly error: "Too many requests. Please wait X seconds."
- Error message includes retry time
- No technical error details shown to user

#### Test 6: Webhook Rate Limit (IP-based)

**Test Steps:**
```bash
# Simulate webhook replay attack
for i in {1..105}; do
  echo "Request $i:"
  curl -X POST https://your-app.vercel.app/api/stripe/webhook \
    -H "Stripe-Signature: fake-signature" \
    -d '{"type":"test"}' \
    -w "\nStatus: %{http_code}\n\n" \
    -s
done
```

**Expected Results:**
- First 100 requests: Return 400 (invalid signature) or 200
- Requests 101-105: Return 429 (rate limited)

**Note:** This test will create failed signature verifications in logs, which is expected.

### Load Testing (Optional - Skip to Avoid Costs)

Not included per user request to avoid Redis costs during development.

### Monitoring Checklist

After deployment, monitor for:
- [ ] Rate limit violations in logs (search for `[Rate Limit]`)
- [ ] Redis connection errors (indicates KV issues)
- [ ] Increased 429 responses in Vercel Analytics
- [ ] User reports of "too many requests" errors (may indicate limits too low)

---

## Performance Considerations

### Redis Command Cost:
- Each rate limit check = 2-3 Redis commands
- Checkout limited to 10/min/user = max 20-30 commands/min/user
- With 100 concurrent users = ~2,000-3,000 commands/min = ~120K-180K/hour
- Well within hobby tier (500K commands/month)

### Latency Impact:
- Vercel KV latency: ~20-50ms per request
- Added to API response time (acceptable for checkout/portal flows)
- Webhook latency: Minimal impact (webhooks already async)

### Scaling Considerations:
- Sliding window algorithm prevents thundering herd
- Redis stores minimal data (counters + timestamps)
- Automatic cleanup after window expires (1 minute)
- No manual cleanup jobs needed

---

## Migration Notes

### No Data Migration Required:
- New feature, no existing rate limit data
- Endpoints continue working normally if rate limiting fails
- Safe to deploy incrementally

### Rollout Strategy:
1. Deploy to preview environment first
2. Test manually with steps above
3. Monitor for Redis errors or unexpected 429s
4. Deploy to production
5. Monitor Vercel KV usage in dashboard

### Rollback Plan:
If issues arise:
1. Set `RATE_LIMIT_ENABLED=false` in Vercel environment variables
2. Redeploy (or wait for auto-deploy if env var changes trigger deploy)
3. Rate limiting disabled, endpoints work normally

### Cost Monitoring:
- Check Vercel KV usage: Dashboard → Storage → Your KV store → Usage tab
- Free tier: 30K commands/month
- If approaching limit, upgrade to Hobby tier ($1/month for 500K commands)
- Set up Vercel usage alerts (optional)

---

## References

- Original ticket: `.claude/tickets/0023-add-rate-limiting-to-stripe-endpoints.md`
- Related: Ticket #0015 (Webhook Idempotency)
- Vercel KV docs: https://vercel.com/docs/storage/vercel-kv
- Upstash Ratelimit docs: https://upstash.com/docs/oss/sdks/ts/ratelimit/overview
- HTTP 429 spec (RFC 6585): https://tools.ietf.org/html/rfc6585#section-4
- Stripe rate limits: https://stripe.com/docs/rate-limits

---

## Post-Implementation Checklist

- [ ] Vercel KV store created and connected
- [ ] Environment variables configured in Vercel dashboard
- [ ] `@upstash/ratelimit` and `@vercel/kv` installed
- [ ] `lib/rate-limit.ts` created with rate limiting logic
- [ ] Checkout endpoint updated with rate limiting
- [ ] Portal endpoint updated with rate limiting
- [ ] Webhook endpoint updated with rate limiting
- [ ] Client-side 429 error handling added
- [ ] Manual testing completed for all endpoints
- [ ] Rate limiting works in production
- [ ] Rate limiting disabled in development
- [ ] Documentation updated (if applicable)
- [ ] Team notified of new rate limits
