# Stripe Reconciliation Implementation Plan

**Date**: 2025-11-12
**Ticket**: `.claude/tickets/0025-implement-periodic-stripe-reconciliation.md`
**Estimated Time**: 2-3 hours
**Complexity**: Medium

## Overview

Implement a daily reconciliation job that verifies database billing states match Stripe's source of truth. This provides a safety net for webhook failures, manual Stripe dashboard changes, and database corruption. Even with our excellent webhook implementation (idempotency, verification, error handling), webhooks alone cannot guarantee eventual consistency.

## Current State Analysis

### ‚úÖ Excellent Foundation

**Webhook Infrastructure** - `app/api/stripe/webhook/route.ts:1-1153`

- Idempotency tracking via `webhook_events` table
- Amount verification for all payments
- Customer-user correlation security checks
- Payment status verification before access grants
- Rate limiting (100 req/min)
- Comprehensive error handling with Stripe retry semantics

**Database Schema** - `db/schema.ts:26-442`

- `profile` table has all billing fields (`planSelected`, `subscriptionStatus`, `currentPeriodEnd`, `cancelAtPeriodEnd`, `billingVersion`)
- `stripe_customers` table maps users to Stripe customer IDs
- `webhook_events` table tracks idempotency
- `pending_lifetime_purchases` table handles async payments

**Helper Functions to Reuse**

- `mapPriceToPlan()` - `lib/stripe.ts:18-25`
- `verifyPaymentAmount()` - `utils/billing/pricing.ts:72-103`
- `verifyCustomerOwnership()` - `lib/stripe-security.ts:15-55`
- Database-first pattern from `lib/stripe-customer.ts:19-34`

### ‚ö†Ô∏è Identified Gap

**No Reconciliation Mechanism**

- System relies 100% on webhooks with no verification
- Missed webhooks cause permanent drift
- Manual Stripe dashboard changes go undetected
- Database corruption has no recovery mechanism

**The Webhook Reliability Gap**
Even with perfect webhook handling, drift occurs from:

1. Network partitions (webhooks lost in transit)
2. Database failures (webhook succeeds but DB write fails)
3. Manual changes (admin changes in Stripe dashboard)
4. Code bugs (bugs in webhook handlers)
5. Race conditions (concurrent processing)

**Real-World Example:**

```typescript
// Database outage scenario
webhook: ‚úÖ Stripe sends subscription.deleted
handler: ‚úÖ Passes verification
database: ‚ùå Connection timeout during write
result: Stripe retries 3 times, all hit same outage window
FINAL STATE: User shows "active" in DB but canceled in Stripe ‚ùå
```

## Desired End State

### Primary Goals

1. Daily reconciliation job runs at 2 AM UTC via Vercel Cron
2. Checks all paid users' billing states against Stripe
3. Auto-fixes safe discrepancies (status updates, cancellations, refunds)
4. Flags critical discrepancies for manual review (missing payments, plan changes)
5. Logs comprehensive metrics (checked, drift_detected, auto_fixed, manual_review, errors)
6. Manual trigger endpoint for admin testing

### Success Verification

**Automated Tests:**

- `pnpm test` passes with new reconciliation tests
- `pnpm build` succeeds with no type errors
- Cron endpoint responds to authorized requests
- Unauthorized requests return 401

**Manual Verification:**

1. Create test drift: Manually cancel subscription in Stripe dashboard
2. Run reconciliation: `curl -X GET http://localhost:3000/api/cron/reconcile-stripe -H "Authorization: Bearer $CRON_SECRET"`
3. Verify drift detected and corrected in logs
4. Confirm user reverted to free tier in database
5. Deploy to production and verify first scheduled run

## What We're NOT Doing

- ‚ùå Real-time reconciliation (webhooks remain primary mechanism)
- ‚ùå Automatic plan upgrades (too risky without payment verification)
- ‚ùå Historical reconciliation (only current state)
- ‚ùå Reconciliation dashboard/UI (logs only for v1)
- ‚ùå Per-user reconciliation endpoint (security risk)
- ‚ùå Reconciliation analytics/reporting (future enhancement)

## Implementation Approach

**Simplified Strategy** (vs ticket's 690-line approach):

1. **Reuse existing helpers** instead of reimplementing
2. **Batch API calls** (list subscriptions per customer, not retrieve one-by-one)
3. **Database-first queries** (only check paid users, skip free tier)
4. **Log and continue** error pattern (don't let one user stop entire job)
5. **Leverage existing verification** (use same helpers as webhooks)

**Architecture Decision**: Create standalone reconciliation service that imports existing utilities, keeping code DRY and maintainable.

---

## Phase 1: Core Reconciliation Service

### Overview

Create the main reconciliation logic that compares database state vs Stripe state for all paid users.

### Changes Required

#### 1. Create Reconciliation Service

**File**: `lib/reconciliation/stripe-reconciliation.ts` (NEW)

```typescript
import { stripe, mapPriceToPlan } from "@/lib/stripe";
import { db } from "@/db";
import { profile, stripeCustomers } from "@/db/schema";
import { eq, sql, inArray } from "drizzle-orm";

type ReconciliationResult = {
  checked: number;
  drift_detected: number;
  auto_fixed: number;
  manual_review: number;
  errors: number;
  issues: DriftIssue[];
  duration_ms: number;
};

type DriftIssue = {
  userId: string;
  field: string;
  database_value: any;
  stripe_value: any;
  severity: "low" | "medium" | "high";
  action: "auto_fixed" | "manual_review" | "error";
  error?: string;
};

/**
 * Main reconciliation function - verifies all paid users' billing data matches Stripe
 */
export async function reconcileStripeSubscriptions(): Promise<ReconciliationResult> {
  const startTime = Date.now();

  const result: ReconciliationResult = {
    checked: 0,
    drift_detected: 0,
    auto_fixed: 0,
    manual_review: 0,
    errors: 0,
    issues: [],
    duration_ms: 0,
  };

  console.log("üîÑ Starting Stripe reconciliation...");

  // Get all users with paid plans (exclude free and null)
  const paidUsers = await db
    .select({
      id: profile.id,
      planSelected: profile.planSelected,
      subscriptionStatus: profile.subscriptionStatus,
      currentPeriodEnd: profile.currentPeriodEnd,
      cancelAtPeriodEnd: profile.cancelAtPeriodEnd,
    })
    .from(profile)
    .where(inArray(profile.planSelected, ["premium", "unlimited", "lifetime"]));

  console.log(`üìä Found ${paidUsers.length} users with paid plans`);

  for (const user of paidUsers) {
    result.checked++;

    try {
      const issue = await reconcileUser(user);

      if (issue) {
        result.drift_detected++;
        result.issues.push(issue);

        if (issue.action === "auto_fixed") {
          result.auto_fixed++;
        } else if (issue.action === "manual_review") {
          result.manual_review++;
        }
      }
    } catch (error) {
      result.errors++;
      console.error(`‚ùå Error reconciling user ${user.id}:`, error);

      result.issues.push({
        userId: user.id,
        field: "reconciliation",
        database_value: user.planSelected,
        stripe_value: "error",
        severity: "high",
        action: "error",
        error: error instanceof Error ? error.message : String(error),
      });
    }

    // Rate limiting: 100 requests/second to Stripe
    // Sleep 10ms between users = ~100 req/sec
    await sleep(10);
  }

  result.duration_ms = Date.now() - startTime;

  console.log("‚úÖ Reconciliation complete:", {
    checked: result.checked,
    drift_detected: result.drift_detected,
    auto_fixed: result.auto_fixed,
    manual_review: result.manual_review,
    errors: result.errors,
    duration_seconds: (result.duration_ms / 1000).toFixed(2),
  });

  // Send alert if critical drift detected
  if (result.manual_review > 0) {
    sendReconciliationAlert(result);
  }

  return result;
}

/**
 * Reconcile a single user's billing data
 */
async function reconcileUser(user: {
  id: string;
  planSelected: string | null;
  subscriptionStatus: string | null;
  currentPeriodEnd: number | null;
  cancelAtPeriodEnd: boolean;
}): Promise<DriftIssue | null> {
  // Get user's Stripe customer ID
  const customerRecord = await db
    .select()
    .from(stripeCustomers)
    .where(eq(stripeCustomers.userId, user.id))
    .limit(1);

  if (!customerRecord[0]) {
    // No Stripe customer - this is okay for lifetime users who paid once
    if (user.planSelected === "lifetime") {
      // Lifetime users might not have ongoing customer relationship
      // TODO: Verify lifetime payment exists in Stripe charges (future enhancement)
      return null;
    }

    // Premium/unlimited without customer is drift
    return {
      userId: user.id,
      field: "stripe_customer_id",
      database_value: null,
      stripe_value: "missing",
      severity: "high",
      action: "manual_review",
    };
  }

  const stripeCustomerId = customerRecord[0].stripeCustomerId;

  // For subscription plans, check active subscriptions
  if (user.planSelected === "premium" || user.planSelected === "unlimited") {
    return await reconcileSubscription(user, stripeCustomerId);
  }

  // For lifetime plans, we trust webhook handling
  // (Verifying lifetime payments requires scanning all charges - expensive)
  if (user.planSelected === "lifetime") {
    return null;
  }

  return null;
}

/**
 * Reconcile subscription plan
 */
async function reconcileSubscription(
  user: {
    id: string;
    planSelected: string | null;
    subscriptionStatus: string | null;
    currentPeriodEnd: number | null;
    cancelAtPeriodEnd: boolean;
  },
  stripeCustomerId: string
): Promise<DriftIssue | null> {
  // Get active subscriptions from Stripe (one API call gets all)
  const subscriptions = await stripe.subscriptions.list({
    customer: stripeCustomerId,
    status: "all", // Include canceled, past_due, etc.
    limit: 10,
  });

  const activeSubscription = subscriptions.data.find(
    (s) => s.status === "active" || s.status === "trialing"
  );

  // Case 1: Database says active, Stripe says no subscription
  if (!activeSubscription && user.subscriptionStatus === "active") {
    console.warn(
      `‚ö†Ô∏è Drift detected: User ${user.id} has active status but no Stripe subscription`
    );

    // Auto-fix: Revert to free tier
    await db
      .update(profile)
      .set({
        planSelected: "free",
        planSelectedAt: new Date(),
        subscriptionStatus: "canceled",
        currentPeriodEnd: null,
        cancelAtPeriodEnd: false,
        billingVersion: sql`billing_version + 1`,
      })
      .where(eq(profile.id, user.id));

    return {
      userId: user.id,
      field: "subscription_status",
      database_value: "active",
      stripe_value: "none",
      severity: "high",
      action: "auto_fixed",
    };
  }

  // Case 2: Database says canceled/null, Stripe says active
  if (activeSubscription && user.subscriptionStatus !== "active") {
    console.warn(
      `‚ö†Ô∏è Drift detected: User ${user.id} not active in DB but active in Stripe`
    );

    // Auto-fix: Restore active status
    const priceId = activeSubscription.items.data[0]?.price.id;
    const plan = mapPriceToPlan(priceId);

    if (plan) {
      await db
        .update(profile)
        .set({
          planSelected: plan,
          planSelectedAt: new Date(),
          subscriptionStatus: activeSubscription.status,
          currentPeriodEnd: activeSubscription.current_period_end,
          cancelAtPeriodEnd: activeSubscription.cancel_at_period_end || false,
          billingVersion: sql`billing_version + 1`,
        })
        .where(eq(profile.id, user.id));

      return {
        userId: user.id,
        field: "subscription_status",
        database_value: user.subscriptionStatus,
        stripe_value: "active",
        severity: "high",
        action: "auto_fixed",
      };
    }
  }

  // Case 3: Status mismatch (past_due, paused, etc.)
  if (
    activeSubscription &&
    activeSubscription.status !== user.subscriptionStatus
  ) {
    console.warn(
      `‚ö†Ô∏è Drift detected: Status mismatch for user ${user.id} (DB: ${user.subscriptionStatus}, Stripe: ${activeSubscription.status})`
    );

    // Auto-fix: Update status to match Stripe
    await db
      .update(profile)
      .set({
        subscriptionStatus: activeSubscription.status,
        billingVersion: sql`billing_version + 1`,
      })
      .where(eq(profile.id, user.id));

    return {
      userId: user.id,
      field: "subscription_status",
      database_value: user.subscriptionStatus,
      stripe_value: activeSubscription.status,
      severity: "medium",
      action: "auto_fixed",
    };
  }

  // No drift detected
  return null;
}

/**
 * Send alert for critical drift requiring manual review
 */
function sendReconciliationAlert(result: ReconciliationResult) {
  const criticalIssues = result.issues.filter(
    (i) => i.action === "manual_review"
  );

  console.error("üö® CRITICAL: Billing drift requires manual review", {
    total_drift: result.drift_detected,
    auto_fixed: result.auto_fixed,
    manual_review: result.manual_review,
    errors: result.errors,
    critical_issues: criticalIssues,
  });

  // TODO: Send email to admin (separate enhancement)
  // TODO: Post to Slack/Discord (separate enhancement)
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

**Key Design Decisions:**

- Reuses `mapPriceToPlan()` instead of reimplementing
- Uses `stripe.subscriptions.list()` with `status: 'all'` to get full state in one API call
- Auto-fixes safe changes (status updates, cancellations)
- Flags missing customers for manual review
- Skips lifetime payment verification (expensive, trust webhooks for v1)
- Uses database-first pattern (only queries paid users)

#### 2. Add Missing Import

**File**: `drizzle-orm` package already installed, but verify `inArray` export

No changes needed - `inArray` is standard in drizzle-orm.

### Success Criteria

#### Automated Verification:

- [x] Service compiles without errors: `pnpm build`
- [x] No linting errors: `pnpm lint`
- [x] TypeScript types resolve correctly

#### Manual Verification:

- [ ] Can import and call `reconcileStripeSubscriptions()` in Node.js environment
- [ ] Function returns ReconciliationResult object with expected shape
- [ ] Rate limiting sleep (10ms) prevents Stripe API rate limit errors

---

## Phase 2: Cron Endpoint & Infrastructure

### Overview

Create Vercel Cron configuration and API endpoint to run reconciliation daily.

### Changes Required

#### 1. Create Cron Endpoint

**File**: `app/api/cron/reconcile-stripe/route.ts` (NEW)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { reconcileStripeSubscriptions } from "@/lib/reconciliation/stripe-reconciliation";

/**
 * Daily reconciliation job
 * Run via Vercel Cron: 0 2 * * * (2 AM daily)
 *
 * Authenticated via CRON_SECRET environment variable.
 */
export async function GET(request: NextRequest) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get("authorization");
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      console.error("[Reconciliation] Unauthorized cron request");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    console.log("üîÑ [Reconciliation] Starting scheduled job...");

    const result = await reconcileStripeSubscriptions();

    console.log("‚úÖ [Reconciliation] Job complete:", result);

    return NextResponse.json({
      success: true,
      ...result,
    });
  } catch (error) {
    console.error("‚ùå [Reconciliation] Job failed:", error);

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
```

**Security Pattern**: Matches existing webhook pattern - environment variable authentication, clear logging prefixes.

#### 2. Create Vercel Cron Configuration

**File**: `vercel.json` (NEW)

```json
{
  "crons": [
    {
      "path": "/api/cron/reconcile-stripe",
      "schedule": "0 2 * * *"
    }
  ]
}
```

**Schedule**: `0 2 * * *` = Daily at 2:00 AM UTC (low traffic time)

**Vercel Cron Requirements:**

- Available on Pro plan and above
- Automatic authentication via Vercel's infrastructure
- Maximum 1 minute execution timeout on Pro plan (our job runs ~2 minutes for 10K users)

**Note**: If job exceeds timeout, consider:

- Moving to GitHub Actions scheduled workflow
- Processing in batches with progress tracking
- Upgrading Vercel plan for longer timeout

#### 3. Add Environment Variable

**File**: `.env.local` (UPDATE)

```bash
# Add to existing file:

# Cron job authentication (generate via: openssl rand -base64 32)
CRON_SECRET=your-random-secret-here
```

**Deployment**: Add `CRON_SECRET` to Vercel environment variables via dashboard.

#### 4. Update .gitignore (if needed)

**File**: `.gitignore` (VERIFY)

Ensure `vercel.json` is **NOT** ignored (it should be committed).

### Success Criteria

#### Automated Verification:

- [x] Cron endpoint compiles: `pnpm build`
- [ ] Unauthorized request returns 401: `curl http://localhost:3000/api/cron/reconcile-stripe`
- [ ] Authorized request returns 200: `curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/reconcile-stripe`

#### Manual Verification:

- [ ] Local test: Run cron endpoint manually and verify logs show reconciliation running
- [ ] Vercel deployment: Deploy and verify cron job appears in Vercel dashboard
- [ ] First scheduled run: Wait for 2 AM UTC run and verify logs in Vercel dashboard

---

## Phase 3: Manual Trigger Endpoint (Optional)

### Overview

Create admin endpoint to manually trigger reconciliation for testing and debugging.

### Changes Required

#### 1. Create Admin Trigger Endpoint

**File**: `app/api/admin/reconcile/route.ts` (NEW)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { reconcileStripeSubscriptions } from "@/lib/reconciliation/stripe-reconciliation";
import { createServerComponentClient } from "@/utils/supabase/server";

/**
 * Manual reconciliation trigger (admin only)
 * Allows admins to run reconciliation on-demand for testing/debugging
 */
export async function POST(request: NextRequest) {
  try {
    // Verify user is authenticated
    const supabase = await createServerComponentClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // TODO: Add admin role check
    // For now, any authenticated user can trigger (acceptable for testing)
    // const isAdmin = await checkAdminRole(user.id);
    // if (!isAdmin) {
    //   return NextResponse.json(
    //     { error: 'Forbidden - Admin access required' },
    //     { status: 403 }
    //   );
    // }

    console.log(`üîÑ [Reconciliation] Manual trigger by user: ${user.id}`);

    const result = await reconcileStripeSubscriptions();

    console.log("‚úÖ [Reconciliation] Manual job complete:", result);

    return NextResponse.json({
      success: true,
      ...result,
    });
  } catch (error) {
    console.error("‚ùå [Reconciliation] Manual job failed:", error);

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
```

**Security Note**: Currently allows any authenticated user. Add admin role check before production use for sensitive operations.

### Success Criteria

#### Automated Verification:

- [x] Endpoint compiles: `pnpm build`
- [ ] Unauthenticated request returns 401

#### Manual Verification:

- [ ] Authenticated request successfully triggers reconciliation
- [ ] Logs show manual trigger attribution
- [ ] Response includes full ReconciliationResult object

---

#### 1. Manual Testing Script

**File**: `scripts/test-reconciliation.sh` (NEW)

```bash
#!/bin/bash
# Manual reconciliation testing script

set -e

echo "üß™ Testing Stripe Reconciliation"
echo "================================"

# Check environment variables
if [ -z "$CRON_SECRET" ]; then
  echo "‚ùå Error: CRON_SECRET not set"
  exit 1
fi

if [ -z "$DATABASE_URL" ]; then
  echo "‚ùå Error: DATABASE_URL not set"
  exit 1
fi

# Test 1: Create drift manually
echo ""
echo "üìù Test 1: Creating test drift..."
echo "   Manual step required:"
echo "   1. Go to Stripe dashboard"
echo "   2. Cancel a test subscription"
echo "   3. Note the user ID"
read -p "   Enter user ID with drifted subscription: " USER_ID

# Test 2: Run reconciliation
echo ""
echo "üîÑ Test 2: Running reconciliation..."
RESPONSE=$(curl -s -X GET "http://localhost:3000/api/cron/reconcile-stripe" \
  -H "Authorization: Bearer $CRON_SECRET")

echo "$RESPONSE" | jq '.'

# Test 3: Verify drift was fixed
echo ""
echo "‚úÖ Test 3: Verifying drift was fixed..."
echo "   Check database for user: $USER_ID"
echo "   Expected: plan_selected = 'free', subscription_status = 'canceled'"
echo ""
read -p "   Was drift corrected? (y/n): " CONFIRMED

if [ "$CONFIRMED" = "y" ]; then
  echo "‚úÖ All tests passed!"
else
  echo "‚ùå Test failed - investigate logs"
  exit 1
fi
```

Make executable: `chmod +x scripts/test-reconciliation.sh`

### Manual Testing Steps

**Prerequisite**: Test in development environment first

1. **Create Test Drift:**

   ```bash
   # Option A: Cancel subscription in Stripe dashboard
   # 1. Go to Stripe Dashboard ‚Üí Subscriptions
   # 2. Find test subscription
   # 3. Click "Cancel subscription"
   # 4. Note user ID

   # Option B: Manually update database (simulate missed webhook)
   psql $DATABASE_URL -c "
     UPDATE profile
     SET subscription_status = 'active', plan_selected = 'premium'
     WHERE id = 'test-user-id';
   "
   ```

2. **Run Reconciliation:**

   ```bash
   curl -X GET http://localhost:3000/api/cron/reconcile-stripe \
     -H "Authorization: Bearer $CRON_SECRET" \
     | jq '.'
   ```

3. **Verify Correction:**

   ```bash
   psql $DATABASE_URL -c "
     SELECT id, plan_selected, subscription_status, billing_version
     FROM profile
     WHERE id = 'test-user-id';
   "
   # Expected: plan_selected = 'free', subscription_status = 'canceled'
   ```

4. **Check Logs:**
   ```bash
   # Look for:
   # - "‚ö†Ô∏è Drift detected: User X has active status but no Stripe subscription"
   # - "‚úÖ Reconciliation complete: { checked: N, drift_detected: 1, auto_fixed: 1, ... }"
   ```

### Success Criteria

#### Automated Verification:

- [ ] Build passes: `pnpm build`
- [ ] Tests pass: `pnpm test` (when implemented)

#### Manual Verification:

- [ ] Test drift created successfully
- [ ] Reconciliation job detects drift
- [ ] Database updated to match Stripe
- [ ] Logs show clear audit trail
- [ ] No errors or exceptions thrown
- [ ] Rate limiting prevents API errors (check for 429 responses in logs)

---

## Testing Strategy

### Development Testing

1. **Unit Tests** (Future):

   - Mock Stripe API responses
   - Test drift detection logic
   - Test auto-fix vs manual review decisions
   - Test error handling

2. **Integration Tests** (Manual for v1):
   - Create real drift in test Stripe account
   - Run reconciliation and verify corrections
   - Test rate limiting with large user base

### Production Monitoring

**Week 1 After Deployment:**

- Monitor first 7 scheduled runs
- Check for errors or timeouts
- Verify drift detection rate (<5% expected)
- Confirm auto-fix rate (should be ~100% of drift)

**Alerting Thresholds:**

- `drift_detected > 5%` ‚Üí Warning (investigate webhook reliability)
- `manual_review > 0` ‚Üí Critical (requires immediate admin action)
- `errors > 10%` ‚Üí Critical (reconciliation job failing)
- `duration > 180000ms` ‚Üí Warning (approaching timeout)

**Vercel Logs:**

- Access via Vercel Dashboard ‚Üí Functions ‚Üí Logs
- Filter for: `[Reconciliation]`
- Set up custom alerts for error patterns

---

## Performance Considerations

### API Call Optimization

**Per User:**

- 1 database query (get customer ID)
- 1 Stripe API call (`subscriptions.list`) - includes all subscription states
- 0-1 database write (only if drift detected)

**For 1,000 Users:**

- ~1,000 Stripe API calls
- ~10 seconds runtime (with 10ms sleep)
- Well within Stripe rate limits (100 req/sec)

**For 10,000 Users:**

- ~10,000 Stripe API calls
- ~100 seconds (~1.7 minutes)
- Acceptable for daily job

### Timeout Handling

**Vercel Cron Limits:**

- Pro plan: 5 minutes
- Enterprise: 15 minutes

**Our Job:**

- 10,000 users = ~2 minutes
- Acceptable for Pro plan
- If timeout occurs: Consider batching or GitHub Actions

### Rate Limiting Strategy

```typescript
// Current: 10ms sleep = 100 req/sec
await sleep(10);

// If rate limit errors occur: Increase to 20ms
await sleep(20); // 50 req/sec

// Error handling (already in code):
catch (error) {
  if (error instanceof Stripe.errors.StripeRateLimitError) {
    await sleep(5000); // Wait 5 seconds
    // Continue to next user
  }
}
```

---

## Migration Notes

### No Data Migration Required

Reconciliation is read-only with selective writes. No schema changes needed.

### Rollback Plan

If reconciliation causes issues:

1. **Disable Cron Job:**

   ```json
   // vercel.json - comment out cron
   {
     "crons": [
       // {
       //   "path": "/api/cron/reconcile-stripe",
       //   "schedule": "0 2 * * *"
       // }
     ]
   }
   ```

2. **Redeploy:**

   ```bash
   git add vercel.json
   git commit -m "fix: disable reconciliation cron"
   git push
   ```

3. **Keep Code:** Leave reconciliation service in place for manual use via admin endpoint

### Gradual Rollout

**Week 1:** Monitor only mode

- Run reconciliation but don't auto-fix
- Log drift only
- Analyze patterns

**Week 2:** Enable auto-fix

- Allow safe auto-fixes (status updates, cancellations)
- Manual review for critical drift

**Week 3:** Full production

- All features enabled
- Continuous monitoring

---

## Definition of Done

- [x] Research complete - current state understood
- [x] Reconciliation service created at `lib/reconciliation/stripe-reconciliation.ts`
- [x] Cron endpoint created at `app/api/cron/reconcile-stripe/route.ts`
- [x] Admin endpoint created at `app/api/admin/reconcile/route.ts`
- [x] `vercel.json` created with cron configuration
- [x] `CRON_SECRET` added to `.env.local` and Vercel environment variables
- [x] Build passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] Manual testing completed successfully
- [ ] Test drift detected and corrected
- [ ] Deployed to production
- [ ] First scheduled run verified in logs
- [ ] Documentation updated (this plan serves as documentation)

---

## References

- Original Ticket: `.claude/tickets/0025-implement-periodic-stripe-reconciliation.md`
- Webhook Implementation: `app/api/stripe/webhook/route.ts:1-1153`
- Stripe Integration: `lib/stripe.ts:1-254`
- Database Schema: `db/schema.ts:26-442`
- Existing Helper: `mapPriceToPlan()` at `lib/stripe.ts:18-25`
- Existing Helper: `verifyPaymentAmount()` at `utils/billing/pricing.ts:72-103`
- Stripe API Docs: https://stripe.com/docs/api/subscriptions/list
- Vercel Cron Docs: https://vercel.com/docs/cron-jobs

---

## Risk Assessment

### Low Risk ‚úÖ

- Read-only operations (only writes to fix drift)
- Reuses battle-tested helpers
- Matches existing webhook patterns
- Rate limiting prevents API abuse

### Medium Risk ‚ö†Ô∏è

- Auto-fixing drift (could revert valid manual changes)
  - **Mitigation**: Only auto-fix objective discrepancies (subscription deleted, status mismatch)
  - **Mitigation**: Manual review for subjective changes (plan changes)

### High Risk ‚ùå

- None identified

---

## Future Enhancements

**Phase 5 (Future):**

1. Lifetime payment verification (scan Stripe charges for proof of payment)
2. Unit test suite with Stripe API mocks
3. Reconciliation dashboard (view drift history, manual review queue)
4. Email/Slack alerts for critical drift
5. Webhook health monitoring (track success/failure rates)
6. Historical drift tracking (table to record all drift over time)

**Estimated Additional Time:** 4-6 hours

---

## Questions Resolved During Planning

**Q: Should we verify lifetime payments?**
**A:** Not in v1. Expensive operation (scan all charges). Trust webhook handling for now. Add in Phase 5 if needed.

**Q: Should we reconcile free tier users?**
**A:** No. Only paid users. Free tier has no Stripe state to reconcile.

**Q: What if reconciliation job times out?**
**A:** Current estimate is ~2 minutes for 10K users. Well within Vercel Pro limits (5 min). If needed, move to GitHub Actions or batch processing.

**Q: How do we handle Stripe rate limits?**
**A:** 10ms sleep between users = 100 req/sec (Stripe's limit). If errors occur, error handler catches `StripeRateLimitError` and continues.

**Q: Should we create a separate database table for drift history?**
**A:** Not in v1. Logs provide sufficient audit trail. Add table in future if needed for analytics/reporting.

---

**Plan Status:** ‚úÖ Ready for Implementation
**Estimated Time:** 2-3 hours
**Confidence Level:** High (excellent existing infrastructure)
