# Fix Missing current_period_end for Subscriptions - Implementation Plan

## Overview

This plan fixes the bug where `profile.current_period_end` remains NULL for premium/unlimited subscription users. The root cause is that the webhook handler reads from the wrong location in the Stripe subscription object.

## Current State Analysis

### What We Discovered

**The Bug:**
- Webhook handler reads `subscription.current_period_end` (which doesn't exist)
- Actual value is at `subscription.items.data[0].current_period_end`
- This causes NULL to be written to the database

**Stripe Subscription Object Structure (Verified):**
```json
{
  "id": "sub_xxx",
  "status": "active",
  "customer": "cus_xxx",
  // ‚ùå NO current_period_end at root level
  "items": {
    "data": [
      {
        "id": "si_xxx",
        "current_period_end": 1794820311,  // ‚úÖ Value is HERE
        "current_period_start": 1763284311,
        "price": { "id": "price_xxx" }
      }
    ]
  }
}
```

**Affected Locations:**
1. `app/api/stripe/webhook/route.ts:433` - `handleCheckoutCompleted()` for subscriptions
2. `app/api/stripe/webhook/route.ts:1199` - `handleSubscriptionChange()`

**Database Schema:**
- Type: `integer` (can store ~2.1 billion max)
- Unix timestamps in 2025: ~1.7 billion
- **Y2038 Problem**: Will overflow in year 2038 (13 years away)

### Current Dependencies

- Webhook handler: `app/api/stripe/webhook/route.ts`
- Database schema: `db/schema.ts`
- JWT hook: `supabase/migrations/20251012223407_add_billing_jwt_hook.sql`
- Middleware: `utils/supabase/middleware.ts`
- Access control: `utils/billing/access-control.ts`

## Desired End State

### Success Criteria

After implementation:
1. New subscription webhooks populate `current_period_end` correctly
2. Existing subscriptions backfilled with correct values
3. Database schema uses `bigint` to prevent Y2038 overflow
4. All tests pass
5. Manual verification shows correct period end dates

### Verification Steps

**Database Query:**
```sql
SELECT
  id,
  email,
  plan_selected,
  current_period_end,
  TO_TIMESTAMP(current_period_end)::text as period_end_human,
  subscription_status
FROM profile
WHERE plan_selected IN ('premium', 'unlimited')
ORDER BY created_at DESC
LIMIT 10;
```

**Expected Result:**
- `current_period_end` is NOT NULL for active subscriptions
- Timestamp converts to valid future date
- Lifetime users still have NULL (correct behavior)

## What We're NOT Doing

- ‚úÖ NOT adding complex debug logging (unnecessary)
- ‚úÖ NOT checking database constraints (they're fine)
- ‚úÖ NOT investigating ORM mapping issues (no issues exist)
- ‚úÖ NOT changing subscription renewal logic
- ‚úÖ NOT modifying Stripe webhook configuration
- ‚úÖ NOT changing how lifetime plans work (they should have NULL)

## Implementation Approach

**Strategy:**
1. Fix webhook handler to read from correct location (2-line change)
2. Update database schema to use bigint (future-proof)
3. Create migration to convert existing integer column
4. Backfill existing subscription data from Stripe
5. Verify with tests and manual checks

**Risk Mitigation:**
- Migration includes rollback strategy
- Backfill script is idempotent (safe to run multiple times)
- No breaking changes to existing API contracts

---

## Phase 1: Fix Webhook Handler

### Overview

Update webhook handler to read `current_period_end` from the correct location in Stripe subscription objects.

### Changes Required

#### 1. Update handleCheckoutCompleted() for Subscription Mode

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Line 433
**Changes**: Read from subscription item instead of root

```typescript
// BEFORE (line 426-437)
await db
  .update(profile)
  .set({
    planSelected: plan,
    planSelectedAt: new Date(),
    subscriptionStatus: subscription.status,
    currentPeriodEnd: subscription.current_period_end, // ‚ùå WRONG - always NULL
    cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
    billingVersion: sql`billing_version + 1`,
  })
  .where(eq(profile.id, userId));

// AFTER
await db
  .update(profile)
  .set({
    planSelected: plan,
    planSelectedAt: new Date(),
    subscriptionStatus: subscription.status,
    currentPeriodEnd: subscription.items.data[0]?.current_period_end, // ‚úÖ CORRECT
    cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
    billingVersion: sql`billing_version + 1`,
  })
  .where(eq(profile.id, userId));
```

#### 2. Update handleSubscriptionChange()

**File**: `app/api/stripe/webhook/route.ts`
**Location**: Line 1199
**Changes**: Read from subscription item instead of root

```typescript
// BEFORE (line 1193-1203)
await db
  .update(profile)
  .set({
    planSelected: plan,
    planSelectedAt: new Date(),
    subscriptionStatus: subscription.status,
    currentPeriodEnd: subscription.current_period_end, // ‚ùå WRONG - always NULL
    cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
    billingVersion: sql`billing_version + 1`,
  })
  .where(eq(profile.id, userId));

// AFTER
await db
  .update(profile)
  .set({
    planSelected: plan,
    planSelectedAt: new Date(),
    subscriptionStatus: subscription.status,
    currentPeriodEnd: subscription.items.data[0]?.current_period_end, // ‚úÖ CORRECT
    cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
    billingVersion: sql`billing_version + 1`,
  })
  .where(eq(profile.id, userId));
```

#### 3. Add Defensive Logging (Optional but Recommended)

**File**: `app/api/stripe/webhook/route.ts`
**Location**: After line 1188 in `handleSubscriptionChange()`

```typescript
// Add after line 1188
const currentPeriodEnd = subscription.items.data[0]?.current_period_end;

if (!currentPeriodEnd) {
  logWebhookWarning(
    `No current_period_end found in subscription items for ${subscription.id}`,
    {
      subscriptionId: subscription.id,
      userId,
      itemsCount: subscription.items.data.length,
    }
  );
}

logWebhookDebug("Subscription period info", {
  subscriptionId: subscription.id,
  currentPeriodEnd,
  currentPeriodStart: subscription.items.data[0]?.current_period_start,
  periodEndDate: currentPeriodEnd ? new Date(currentPeriodEnd * 1000).toISOString() : null,
});
```

### Success Criteria

#### Automated Verification:
- [ ] Code compiles without errors: `pnpm build`
- [ ] No linting errors: `pnpm lint`

#### Manual Verification:
- [ ] Create new test subscription via Stripe CLI
- [ ] Webhook fires and returns 200
- [ ] Database query shows non-NULL `current_period_end`
- [ ] Timestamp converts to valid future date
- [ ] Lifetime users still have NULL `current_period_end`

---

## Phase 2: Update Database Schema (Y2038 Future-Proofing)

### Overview

Change `current_period_end` from `integer` to `bigint` to prevent Y2038 overflow (13 years from now).

### Changes Required

#### 1. Update Drizzle Schema

**File**: `db/schema.ts`
**Location**: Line 48
**Changes**: Change integer to bigint

```typescript
// BEFORE
currentPeriodEnd: integer("current_period_end"), // bigint stored as integer

// AFTER
currentPeriodEnd: bigint("current_period_end", { mode: "number" }),
```

**Note:** The `{ mode: "number" }` option tells Drizzle to return JavaScript numbers instead of strings, maintaining compatibility with existing code.

#### 2. Create Migration

**File**: `supabase/migrations/YYYYMMDDHHMMSS_fix_current_period_end_bigint.sql`
**Changes**: Alter column type

```sql
-- Migration: Fix current_period_end to use bigint (Y2038 prevention)
-- This prevents overflow in year 2038 when unix timestamps exceed integer max

BEGIN;

-- Alter column from integer to bigint
-- Safe because:
-- 1. All existing values are NULL or valid small integers
-- 2. USING clause converts any existing values
-- 3. Bigint is backward compatible (can store all integer values)
ALTER TABLE profile
  ALTER COLUMN current_period_end TYPE bigint
  USING current_period_end::bigint;

-- Add comment for documentation
COMMENT ON COLUMN profile.current_period_end IS
  'Unix timestamp (seconds since epoch) of subscription period end. NULL for free/lifetime plans. Uses bigint to prevent Y2038 overflow.';

COMMIT;
```

#### 3. Generate Drizzle Migration

Run after making schema changes:

```bash
npx drizzle-kit generate
```

This will generate the migration file that Drizzle needs.

### Success Criteria

#### Automated Verification:
- [ ] Migration generated successfully: `npx drizzle-kit generate`
- [ ] Schema builds without errors: `pnpm build`
- [ ] Migration runs cleanly: `supabase db reset`

#### Manual Verification:
- [ ] Verify column type changed to bigint:
  ```sql
  SELECT column_name, data_type, character_maximum_length
  FROM information_schema.columns
  WHERE table_name = 'profile' AND column_name = 'current_period_end';
  -- Expected: data_type = 'bigint'
  ```
- [ ] Existing NULL values preserved
- [ ] Can store large timestamps (e.g., year 2100):
  ```sql
  -- Test large timestamp (year 2100: ~4 billion)
  SELECT TO_TIMESTAMP(4102444800)::text;
  -- Should succeed without overflow
  ```

---

## Phase 3: Backfill Existing Subscription Data

### Overview

Fetch current subscription data from Stripe API and update database records that have NULL `current_period_end` but should have values.

### Changes Required

#### 1. Create Backfill Script

**File**: `scripts/backfill-subscription-periods.ts` (NEW FILE)

```typescript
/**
 * Backfill Script: Fix NULL current_period_end values
 *
 * This script:
 * 1. Finds all users with premium/unlimited plans but NULL current_period_end
 * 2. Fetches their active subscriptions from Stripe
 * 3. Updates the database with correct values
 *
 * Safe to run multiple times (idempotent).
 */

import { db } from "@/db";
import { profile, stripeCustomers } from "@/db/schema";
import { eq, and, isNull, inArray } from "drizzle-orm";
import { stripe } from "@/lib/stripe";

async function backfillSubscriptionPeriods() {
  console.log("üîç Finding profiles with missing current_period_end...");

  // Find users with subscriptions but NULL period end
  const affectedProfiles = await db
    .select({
      userId: profile.id,
      email: profile.email,
      plan: profile.planSelected,
      stripeCustomerId: stripeCustomers.stripeCustomerId,
    })
    .from(profile)
    .leftJoin(stripeCustomers, eq(profile.id, stripeCustomers.userId))
    .where(
      and(
        inArray(profile.planSelected, ["premium", "unlimited"]),
        isNull(profile.currentPeriodEnd),
        eq(profile.subscriptionStatus, "active")
      )
    );

  console.log(`üìä Found ${affectedProfiles.length} profiles to backfill`);

  if (affectedProfiles.length === 0) {
    console.log("‚úÖ No profiles need backfilling!");
    return;
  }

  let successCount = 0;
  let skipCount = 0;
  let errorCount = 0;

  for (const profileData of affectedProfiles) {
    const { userId, email, plan, stripeCustomerId } = profileData;

    if (!stripeCustomerId) {
      console.log(`‚ö†Ô∏è  Skipping ${email} - no Stripe customer ID`);
      skipCount++;
      continue;
    }

    try {
      console.log(`üîÑ Processing ${email} (${plan})...`);

      // Fetch active subscriptions from Stripe
      const subscriptions = await stripe.subscriptions.list({
        customer: stripeCustomerId,
        status: "active",
        limit: 10,
      });

      if (subscriptions.data.length === 0) {
        console.log(`‚ö†Ô∏è  No active subscriptions in Stripe for ${email}`);
        skipCount++;
        continue;
      }

      // Get the first active subscription
      const subscription = subscriptions.data[0];
      const currentPeriodEnd = subscription.items.data[0]?.current_period_end;

      if (!currentPeriodEnd) {
        console.log(`‚ö†Ô∏è  No current_period_end in subscription for ${email}`);
        skipCount++;
        continue;
      }

      // Update database
      await db
        .update(profile)
        .set({
          currentPeriodEnd,
          subscriptionStatus: subscription.status,
          cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
        })
        .where(eq(profile.id, userId));

      console.log(
        `‚úÖ Updated ${email} - period ends ${new Date(currentPeriodEnd * 1000).toISOString()}`
      );
      successCount++;
    } catch (error) {
      console.error(`‚ùå Error processing ${email}:`, error);
      errorCount++;
    }
  }

  console.log("\nüìà Backfill Summary:");
  console.log(`  ‚úÖ Success: ${successCount}`);
  console.log(`  ‚ö†Ô∏è  Skipped: ${skipCount}`);
  console.log(`  ‚ùå Errors: ${errorCount}`);
  console.log(`  üìä Total: ${affectedProfiles.length}`);
}

// Run the script
backfillSubscriptionPeriods()
  .then(() => {
    console.log("\n‚úÖ Backfill complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n‚ùå Backfill failed:", error);
    process.exit(1);
  });
```

#### 2. Add Script to package.json

**File**: `package.json`
**Changes**: Add new script command

```json
{
  "scripts": {
    "backfill:subscription-periods": "tsx scripts/backfill-subscription-periods.ts"
  }
}
```

#### 3. Run the Backfill

```bash
# Dry run first (check what would be updated)
pnpm backfill:subscription-periods

# Review output, then run if looks correct
# (Script is already idempotent, safe to run multiple times)
```

### Success Criteria

#### Automated Verification:
- [ ] Script compiles: `pnpm build`
- [ ] Script runs without errors: `pnpm backfill:subscription-periods`

#### Manual Verification:
- [ ] Run database query to verify backfill:
  ```sql
  SELECT
    COUNT(*) as total_subscriptions,
    COUNT(current_period_end) as with_period_end,
    COUNT(*) - COUNT(current_period_end) as missing_period_end
  FROM profile
  WHERE plan_selected IN ('premium', 'unlimited')
    AND subscription_status = 'active';
  -- Expected: missing_period_end = 0
  ```
- [ ] Verify period end dates are in the future:
  ```sql
  SELECT
    email,
    plan_selected,
    TO_TIMESTAMP(current_period_end) as period_end_date,
    subscription_status
  FROM profile
  WHERE plan_selected IN ('premium', 'unlimited')
    AND current_period_end IS NOT NULL
  ORDER BY current_period_end DESC
  LIMIT 10;
  ```
- [ ] Verify lifetime users still have NULL:
  ```sql
  SELECT COUNT(*)
  FROM profile
  WHERE plan_selected = 'lifetime'
    AND current_period_end IS NOT NULL;
  -- Expected: 0
  ```

---

## Phase 4: Testing & Verification

### Overview

Comprehensive testing to ensure the fix works correctly for all scenarios.

### Test Scenarios

#### 1. New Subscription Creation (End-to-End)

**Steps:**
1. Create new user account
2. Subscribe to Premium plan via Stripe Checkout
3. Wait for webhook to process
4. Query database

**Expected Results:**
- Webhook returns 200 OK
- `profile.current_period_end` is NOT NULL
- Value is a unix timestamp ~1 year in future (for yearly plan)
- `TO_TIMESTAMP(current_period_end)` shows valid date

**SQL Verification:**
```sql
SELECT
  email,
  plan_selected,
  current_period_end,
  TO_TIMESTAMP(current_period_end)::text as period_end_human,
  subscription_status,
  cancel_at_period_end
FROM profile
WHERE email = 'test-user@example.com';
```

#### 2. Subscription Update Event

**Steps:**
1. Use existing subscription
2. Trigger update via Stripe CLI:
   ```bash
   stripe subscriptions update sub_xxx --metadata[test_update]="true"
   ```
3. Verify webhook processes

**Expected Results:**
- `customer.subscription.updated` webhook fires
- Database value remains correct (not overwritten with NULL)

#### 3. Subscription Cancellation (Graceful)

**Steps:**
1. Cancel subscription with `cancel_at_period_end=true`
2. Verify webhook processes

**Expected Results:**
- `current_period_end` remains set (access until end of period)
- `cancel_at_period_end` set to `true`
- `subscription_status` remains `active`

#### 4. Subscription Deletion (Immediate)

**Steps:**
1. Delete subscription immediately
2. Verify webhook processes

**Expected Results:**
- `customer.subscription.deleted` webhook fires
- `current_period_end` set to NULL
- `plan_selected` changed to `free`
- `subscription_status` changed to `canceled`

#### 5. Lifetime Plan (No Period End)

**Steps:**
1. Create lifetime purchase
2. Verify webhook processes

**Expected Results:**
- `current_period_end` is NULL (correct for lifetime)
- `plan_selected` is `lifetime`
- `subscription_status` is `active`

### Success Criteria

#### Automated Verification:
- [ ] All unit tests pass: `pnpm test`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`

#### Manual Verification:
- [ ] New subscriptions populate `current_period_end` correctly
- [ ] Subscription updates preserve `current_period_end`
- [ ] Graceful cancellations keep period end until expiry
- [ ] Immediate cancellations clear period end
- [ ] Lifetime plans have NULL period end
- [ ] JWT claims include correct `current_period_end`
- [ ] Middleware reads period correctly for access control
- [ ] No errors in webhook logs

---

## Testing Strategy

### Unit Tests

**File**: `app/api/stripe/webhook/route.test.ts` (if exists, otherwise create)

Test webhook handlers with mocked Stripe objects:

```typescript
describe("handleSubscriptionChange", () => {
  it("should extract current_period_end from subscription items", async () => {
    const mockSubscription = {
      id: "sub_test",
      status: "active",
      customer: "cus_test",
      metadata: { supabase_user_id: "user-uuid" },
      items: {
        data: [
          {
            current_period_end: 1735689600, // Jan 1, 2025
            current_period_start: 1704153600,
            price: { id: "price_premium" },
          },
        ],
      },
    };

    // Mock database operations
    // Call handler
    // Assert currentPeriodEnd was set to 1735689600
  });

  it("should handle missing current_period_end gracefully", async () => {
    const mockSubscription = {
      id: "sub_test",
      status: "active",
      items: { data: [] }, // Empty items
    };

    // Should log warning but not crash
  });
});
```

### Integration Tests

**Manual testing with Stripe CLI:**

```bash
# 1. Listen to webhooks
stripe listen --forward-to localhost:3000/api/stripe/webhook

# 2. Trigger subscription creation event
stripe trigger customer.subscription.created

# 3. Check logs and database
# Verify current_period_end populated
```

### Regression Tests

Verify existing functionality still works:
- [ ] Lifetime purchases still work (NULL period end)
- [ ] Free tier users unaffected
- [ ] Subscription cancellation flow unchanged
- [ ] JWT claims still include billing info
- [ ] Middleware access control still works

---

## Performance Considerations

### Database Impact

**Migration:**
- Changing `integer` to `bigint` is a metadata-only change (no data rewrite needed)
- Minimal downtime expected (< 1 second)
- No index rebuilds required

**Backfill Script:**
- Processes records sequentially to avoid rate limiting
- Idempotent (safe to run multiple times)
- Can be run during low-traffic period if concerned

### API Impact

**Stripe API Calls:**
- Backfill makes 1 API call per affected user
- Stripe rate limit: 100 requests/second (we're nowhere near this)
- Estimated time: < 1 second per user

---

## Migration Notes

### Rollback Strategy

If issues occur after deployment:

**1. Revert Code Changes:**
```bash
git revert <commit-hash>
git push
```

**2. Revert Database Migration (if needed):**
```sql
-- Only if bigint causes issues (unlikely)
BEGIN;
ALTER TABLE profile
  ALTER COLUMN current_period_end TYPE integer
  USING current_period_end::integer;
COMMIT;
```

**3. Monitor:**
- Check webhook logs for errors
- Verify database writes succeed
- Test subscription creation flow

### Deployment Checklist

- [ ] Merge webhook handler fix to main branch
- [ ] Deploy application (webhook fix goes live)
- [ ] Run database migration (integer ‚Üí bigint)
- [ ] Run backfill script
- [ ] Verify with test subscription
- [ ] Monitor for 24 hours
- [ ] Mark ticket as complete

---

## References

- Original ticket: `.claude/tickets/0014-investigate-missing-current-period-end.md`
- Webhook handler: `app/api/stripe/webhook/route.ts:433, 1199`
- Database schema: `db/schema.ts:48`
- JWT hook: `supabase/migrations/20251012223407_add_billing_jwt_hook.sql`
- Middleware: `utils/supabase/middleware.ts:205-208, 225-226`
- Stripe API Docs: [Subscription Object](https://docs.stripe.com/api/subscriptions/object)

---

## Risk Assessment

### Low Risk ‚úÖ

- Simple 2-line code change
- Database schema change is backward compatible
- Backfill is idempotent and safe
- No breaking changes to API contracts

### Medium Risk ‚ö†Ô∏è

- Y2038 issue requires schema change (but we have 13 years)
- Backfill touches production data (but is read-mostly)

### High Risk ‚ùå

- None identified

### Mitigation

- Test thoroughly in development first
- Run backfill during low-traffic period
- Monitor webhook logs for 24 hours post-deployment
- Have rollback plan ready (git revert + SQL rollback)

---

## Timeline Estimate

**Phase 1 (Webhook Fix):** 30 minutes
- Edit 2 lines of code
- Test with Stripe CLI
- Deploy

**Phase 2 (Schema Update):** 1 hour
- Update schema definition
- Generate migration
- Test migration locally
- Run in production

**Phase 3 (Backfill):** 1 hour
- Write backfill script
- Test with sample data
- Run in production
- Verify results

**Phase 4 (Testing):** 2 hours
- End-to-end testing
- Regression testing
- Documentation update

**Total:** ~4-5 hours of focused work

---

## Success Metrics

After implementation, we should see:

1. **Zero NULL values** for active premium/unlimited subscriptions
2. **All period end dates** in the future (not past)
3. **Lifetime users** still have NULL (expected)
4. **Zero webhook errors** related to period end
5. **JWT claims** include correct period end values
6. **Middleware** correctly calculates access expiry

**Final Verification Query:**
```sql
SELECT
  plan_selected,
  COUNT(*) as total,
  COUNT(current_period_end) as with_period,
  COUNT(*) - COUNT(current_period_end) as without_period
FROM profile
GROUP BY plan_selected;
```

**Expected Results:**
- `free`: without_period = total (all NULL)
- `lifetime`: without_period = total (all NULL)
- `premium`: without_period = 0 (all have values)
- `unlimited`: without_period = 0 (all have values)
